#pragma once
#include <cstdint>
#include <reg.h>

namespace STM32F303 {
    /*
        General-purpose I/Os
     */
    namespace GPIOA {
        /*
            GPIO port mode register
         */
        namespace MODER {

            static constexpr uint32_t RESETVALUE = 0x28000000;
            typedef reg_t<0x48000000, 0xffffffff, 0, rw_t> MODER_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000000, 0x00000003, 30, rw_t> MODER15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000000, 0x00000003, 28, rw_t> MODER14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000000, 0x00000003, 26, rw_t> MODER13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000000, 0x00000003, 24, rw_t> MODER12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000000, 0x00000003, 22, rw_t> MODER11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000000, 0x00000003, 20, rw_t> MODER10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000000, 0x00000003, 18, rw_t> MODER9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000000, 0x00000003, 16, rw_t> MODER8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000000, 0x00000003, 14, rw_t> MODER7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000000, 0x00000003, 12, rw_t> MODER6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000000, 0x00000003, 10, rw_t> MODER5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000000, 0x00000003, 8, rw_t> MODER4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000000, 0x00000003, 6, rw_t> MODER3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000000, 0x00000003, 4, rw_t> MODER2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000000, 0x00000003, 2, rw_t> MODER1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000000, 0x00000003, 0, rw_t> MODER0;
        };
        /*
            GPIO port output type register
         */
        namespace OTYPER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000004, 0xffffffff, 0, rw_t> OTYPER_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000004, 0x00000001, 15, rw_t> OT15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000004, 0x00000001, 14, rw_t> OT14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000004, 0x00000001, 13, rw_t> OT13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000004, 0x00000001, 12, rw_t> OT12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000004, 0x00000001, 11, rw_t> OT11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000004, 0x00000001, 10, rw_t> OT10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000004, 0x00000001, 9, rw_t> OT9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000004, 0x00000001, 8, rw_t> OT8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000004, 0x00000001, 7, rw_t> OT7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000004, 0x00000001, 6, rw_t> OT6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000004, 0x00000001, 5, rw_t> OT5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000004, 0x00000001, 4, rw_t> OT4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000004, 0x00000001, 3, rw_t> OT3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000004, 0x00000001, 2, rw_t> OT2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000004, 0x00000001, 1, rw_t> OT1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000004, 0x00000001, 0, rw_t> OT0;
        };
        /*
            GPIO port output speed
          register
         */
        namespace OSPEEDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000008, 0xffffffff, 0, rw_t> OSPEEDR_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000008, 0x00000003, 30, rw_t> OSPEEDR15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000008, 0x00000003, 28, rw_t> OSPEEDR14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000008, 0x00000003, 26, rw_t> OSPEEDR13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000008, 0x00000003, 24, rw_t> OSPEEDR12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000008, 0x00000003, 22, rw_t> OSPEEDR11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000008, 0x00000003, 20, rw_t> OSPEEDR10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000008, 0x00000003, 18, rw_t> OSPEEDR9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000008, 0x00000003, 16, rw_t> OSPEEDR8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000008, 0x00000003, 14, rw_t> OSPEEDR7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000008, 0x00000003, 12, rw_t> OSPEEDR6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000008, 0x00000003, 10, rw_t> OSPEEDR5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000008, 0x00000003, 8, rw_t> OSPEEDR4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000008, 0x00000003, 6, rw_t> OSPEEDR3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000008, 0x00000003, 4, rw_t> OSPEEDR2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000008, 0x00000003, 2, rw_t> OSPEEDR1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000008, 0x00000003, 0, rw_t> OSPEEDR0;
        };
        /*
            GPIO port pull-up/pull-down
          register
         */
        namespace PUPDR {

            static constexpr uint32_t RESETVALUE = 0x24000000;
            typedef reg_t<0x4800000c, 0xffffffff, 0, rw_t> PUPDR_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800000c, 0x00000003, 30, rw_t> PUPDR15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800000c, 0x00000003, 28, rw_t> PUPDR14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800000c, 0x00000003, 26, rw_t> PUPDR13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800000c, 0x00000003, 24, rw_t> PUPDR12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800000c, 0x00000003, 22, rw_t> PUPDR11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800000c, 0x00000003, 20, rw_t> PUPDR10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800000c, 0x00000003, 18, rw_t> PUPDR9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800000c, 0x00000003, 16, rw_t> PUPDR8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800000c, 0x00000003, 14, rw_t> PUPDR7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800000c, 0x00000003, 12, rw_t> PUPDR6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800000c, 0x00000003, 10, rw_t> PUPDR5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800000c, 0x00000003, 8, rw_t> PUPDR4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800000c, 0x00000003, 6, rw_t> PUPDR3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800000c, 0x00000003, 4, rw_t> PUPDR2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800000c, 0x00000003, 2, rw_t> PUPDR1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800000c, 0x00000003, 0, rw_t> PUPDR0;
        };
        /*
            GPIO port input data register
         */
        namespace IDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000010, 0xffffffff, 0, ro_t> IDR_REG;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000010, 0x00000001, 15, ro_t> IDR15;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000010, 0x00000001, 14, ro_t> IDR14;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000010, 0x00000001, 13, ro_t> IDR13;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000010, 0x00000001, 12, ro_t> IDR12;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000010, 0x00000001, 11, ro_t> IDR11;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000010, 0x00000001, 10, ro_t> IDR10;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000010, 0x00000001, 9, ro_t> IDR9;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000010, 0x00000001, 8, ro_t> IDR8;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000010, 0x00000001, 7, ro_t> IDR7;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000010, 0x00000001, 6, ro_t> IDR6;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000010, 0x00000001, 5, ro_t> IDR5;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000010, 0x00000001, 4, ro_t> IDR4;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000010, 0x00000001, 3, ro_t> IDR3;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000010, 0x00000001, 2, ro_t> IDR2;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000010, 0x00000001, 1, ro_t> IDR1;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000010, 0x00000001, 0, ro_t> IDR0;
        };
        /*
            GPIO port output data register
         */
        namespace ODR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000014, 0xffffffff, 0, rw_t> ODR_REG;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000014, 0x00000001, 15, rw_t> ODR15;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000014, 0x00000001, 14, rw_t> ODR14;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000014, 0x00000001, 13, rw_t> ODR13;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000014, 0x00000001, 12, rw_t> ODR12;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000014, 0x00000001, 11, rw_t> ODR11;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000014, 0x00000001, 10, rw_t> ODR10;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000014, 0x00000001, 9, rw_t> ODR9;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000014, 0x00000001, 8, rw_t> ODR8;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000014, 0x00000001, 7, rw_t> ODR7;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000014, 0x00000001, 6, rw_t> ODR6;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000014, 0x00000001, 5, rw_t> ODR5;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000014, 0x00000001, 4, rw_t> ODR4;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000014, 0x00000001, 3, rw_t> ODR3;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000014, 0x00000001, 2, rw_t> ODR2;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000014, 0x00000001, 1, rw_t> ODR1;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000014, 0x00000001, 0, rw_t> ODR0;
        };
        /*
            GPIO port bit set/reset
          register
         */
        namespace BSRR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000018, 0xffffffff, 0, wo_t> BSRR_REG;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 31, wo_t> BR15;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 30, wo_t> BR14;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 29, wo_t> BR13;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 28, wo_t> BR12;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 27, wo_t> BR11;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 26, wo_t> BR10;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 25, wo_t> BR9;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 24, wo_t> BR8;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 23, wo_t> BR7;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 22, wo_t> BR6;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 21, wo_t> BR5;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 20, wo_t> BR4;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 19, wo_t> BR3;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 18, wo_t> BR2;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 17, wo_t> BR1;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 16, wo_t> BR0;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 15, wo_t> BS15;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 14, wo_t> BS14;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 13, wo_t> BS13;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 12, wo_t> BS12;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 11, wo_t> BS11;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 10, wo_t> BS10;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 9, wo_t> BS9;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 8, wo_t> BS8;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 7, wo_t> BS7;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 6, wo_t> BS6;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 5, wo_t> BS5;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 4, wo_t> BS4;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 3, wo_t> BS3;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 2, wo_t> BS2;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 1, wo_t> BS1;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000018, 0x00000001, 0, wo_t> BS0;
        };
        /*
            GPIO port configuration lock
          register
         */
        namespace LCKR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4800001c, 0xffffffff, 0, rw_t> LCKR_REG;
            /*
                Lok Key
             */
            typedef reg_t<0x4800001c, 0x00000001, 16, rw_t> LCKK;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800001c, 0x00000001, 15, rw_t> LCK15;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800001c, 0x00000001, 14, rw_t> LCK14;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800001c, 0x00000001, 13, rw_t> LCK13;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800001c, 0x00000001, 12, rw_t> LCK12;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800001c, 0x00000001, 11, rw_t> LCK11;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800001c, 0x00000001, 10, rw_t> LCK10;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800001c, 0x00000001, 9, rw_t> LCK9;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800001c, 0x00000001, 8, rw_t> LCK8;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800001c, 0x00000001, 7, rw_t> LCK7;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800001c, 0x00000001, 6, rw_t> LCK6;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800001c, 0x00000001, 5, rw_t> LCK5;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800001c, 0x00000001, 4, rw_t> LCK4;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800001c, 0x00000001, 3, rw_t> LCK3;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800001c, 0x00000001, 2, rw_t> LCK2;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800001c, 0x00000001, 1, rw_t> LCK1;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800001c, 0x00000001, 0, rw_t> LCK0;
        };
        /*
            GPIO alternate function low
          register
         */
        namespace AFRL {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000020, 0xffffffff, 0, rw_t> AFRL_REG;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000020, 0x0000000f, 28, rw_t> AFRL7;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000020, 0x0000000f, 24, rw_t> AFRL6;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000020, 0x0000000f, 20, rw_t> AFRL5;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000020, 0x0000000f, 16, rw_t> AFRL4;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000020, 0x0000000f, 12, rw_t> AFRL3;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000020, 0x0000000f, 8, rw_t> AFRL2;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000020, 0x0000000f, 4, rw_t> AFRL1;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000020, 0x0000000f, 0, rw_t> AFRL0;
        };
        /*
            GPIO alternate function high
          register
         */
        namespace AFRH {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000024, 0xffffffff, 0, rw_t> AFRH_REG;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000024, 0x0000000f, 28, rw_t> AFRH15;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000024, 0x0000000f, 24, rw_t> AFRH14;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000024, 0x0000000f, 20, rw_t> AFRH13;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000024, 0x0000000f, 16, rw_t> AFRH12;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000024, 0x0000000f, 12, rw_t> AFRH11;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000024, 0x0000000f, 8, rw_t> AFRH10;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000024, 0x0000000f, 4, rw_t> AFRH9;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000024, 0x0000000f, 0, rw_t> AFRH8;
        };
        /*
            Port bit reset register
         */
        namespace BRR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000028, 0xffffffff, 0, wo_t> BRR_REG;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000028, 0x00000001, 0, wo_t> BR0;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000028, 0x00000001, 1, wo_t> BR1;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000028, 0x00000001, 2, wo_t> BR2;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000028, 0x00000001, 3, wo_t> BR3;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000028, 0x00000001, 4, wo_t> BR4;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000028, 0x00000001, 5, wo_t> BR5;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000028, 0x00000001, 6, wo_t> BR6;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000028, 0x00000001, 7, wo_t> BR7;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000028, 0x00000001, 8, wo_t> BR8;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000028, 0x00000001, 9, wo_t> BR9;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000028, 0x00000001, 10, wo_t> BR10;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000028, 0x00000001, 11, wo_t> BR11;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000028, 0x00000001, 12, wo_t> BR12;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000028, 0x00000001, 13, wo_t> BR13;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000028, 0x00000001, 14, wo_t> BR14;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000028, 0x00000001, 15, wo_t> BR15;
        };
    };
    /*
        General-purpose I/Os
     */
    namespace GPIOB {
        /*
            GPIO port mode register
         */
        namespace MODER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000400, 0xffffffff, 0, rw_t> MODER_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000400, 0x00000003, 30, rw_t> MODER15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000400, 0x00000003, 28, rw_t> MODER14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000400, 0x00000003, 26, rw_t> MODER13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000400, 0x00000003, 24, rw_t> MODER12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000400, 0x00000003, 22, rw_t> MODER11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000400, 0x00000003, 20, rw_t> MODER10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000400, 0x00000003, 18, rw_t> MODER9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000400, 0x00000003, 16, rw_t> MODER8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000400, 0x00000003, 14, rw_t> MODER7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000400, 0x00000003, 12, rw_t> MODER6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000400, 0x00000003, 10, rw_t> MODER5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000400, 0x00000003, 8, rw_t> MODER4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000400, 0x00000003, 6, rw_t> MODER3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000400, 0x00000003, 4, rw_t> MODER2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000400, 0x00000003, 2, rw_t> MODER1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000400, 0x00000003, 0, rw_t> MODER0;
        };
        /*
            GPIO port output type register
         */
        namespace OTYPER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000404, 0xffffffff, 0, rw_t> OTYPER_REG;
            /*
                Port x configuration bit
              15
             */
            typedef reg_t<0x48000404, 0x00000001, 15, rw_t> OT15;
            /*
                Port x configuration bit
              14
             */
            typedef reg_t<0x48000404, 0x00000001, 14, rw_t> OT14;
            /*
                Port x configuration bit
              13
             */
            typedef reg_t<0x48000404, 0x00000001, 13, rw_t> OT13;
            /*
                Port x configuration bit
              12
             */
            typedef reg_t<0x48000404, 0x00000001, 12, rw_t> OT12;
            /*
                Port x configuration bit
              11
             */
            typedef reg_t<0x48000404, 0x00000001, 11, rw_t> OT11;
            /*
                Port x configuration bit
              10
             */
            typedef reg_t<0x48000404, 0x00000001, 10, rw_t> OT10;
            /*
                Port x configuration bit 9
             */
            typedef reg_t<0x48000404, 0x00000001, 9, rw_t> OT9;
            /*
                Port x configuration bit 8
             */
            typedef reg_t<0x48000404, 0x00000001, 8, rw_t> OT8;
            /*
                Port x configuration bit 7
             */
            typedef reg_t<0x48000404, 0x00000001, 7, rw_t> OT7;
            /*
                Port x configuration bit 6
             */
            typedef reg_t<0x48000404, 0x00000001, 6, rw_t> OT6;
            /*
                Port x configuration bit 5
             */
            typedef reg_t<0x48000404, 0x00000001, 5, rw_t> OT5;
            /*
                Port x configuration bit 4
             */
            typedef reg_t<0x48000404, 0x00000001, 4, rw_t> OT4;
            /*
                Port x configuration bit 3
             */
            typedef reg_t<0x48000404, 0x00000001, 3, rw_t> OT3;
            /*
                Port x configuration bit 2
             */
            typedef reg_t<0x48000404, 0x00000001, 2, rw_t> OT2;
            /*
                Port x configuration bit 1
             */
            typedef reg_t<0x48000404, 0x00000001, 1, rw_t> OT1;
            /*
                Port x configuration bit 0
             */
            typedef reg_t<0x48000404, 0x00000001, 0, rw_t> OT0;
        };
        /*
            GPIO port output speed
          register
         */
        namespace OSPEEDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000408, 0xffffffff, 0, rw_t> OSPEEDR_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000408, 0x00000003, 30, rw_t> OSPEEDR15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000408, 0x00000003, 28, rw_t> OSPEEDR14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000408, 0x00000003, 26, rw_t> OSPEEDR13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000408, 0x00000003, 24, rw_t> OSPEEDR12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000408, 0x00000003, 22, rw_t> OSPEEDR11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000408, 0x00000003, 20, rw_t> OSPEEDR10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000408, 0x00000003, 18, rw_t> OSPEEDR9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000408, 0x00000003, 16, rw_t> OSPEEDR8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000408, 0x00000003, 14, rw_t> OSPEEDR7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000408, 0x00000003, 12, rw_t> OSPEEDR6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000408, 0x00000003, 10, rw_t> OSPEEDR5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000408, 0x00000003, 8, rw_t> OSPEEDR4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000408, 0x00000003, 6, rw_t> OSPEEDR3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000408, 0x00000003, 4, rw_t> OSPEEDR2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000408, 0x00000003, 2, rw_t> OSPEEDR1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000408, 0x00000003, 0, rw_t> OSPEEDR0;
        };
        /*
            GPIO port pull-up/pull-down
          register
         */
        namespace PUPDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4800040c, 0xffffffff, 0, rw_t> PUPDR_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800040c, 0x00000003, 30, rw_t> PUPDR15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800040c, 0x00000003, 28, rw_t> PUPDR14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800040c, 0x00000003, 26, rw_t> PUPDR13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800040c, 0x00000003, 24, rw_t> PUPDR12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800040c, 0x00000003, 22, rw_t> PUPDR11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800040c, 0x00000003, 20, rw_t> PUPDR10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800040c, 0x00000003, 18, rw_t> PUPDR9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800040c, 0x00000003, 16, rw_t> PUPDR8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800040c, 0x00000003, 14, rw_t> PUPDR7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800040c, 0x00000003, 12, rw_t> PUPDR6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800040c, 0x00000003, 10, rw_t> PUPDR5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800040c, 0x00000003, 8, rw_t> PUPDR4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800040c, 0x00000003, 6, rw_t> PUPDR3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800040c, 0x00000003, 4, rw_t> PUPDR2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800040c, 0x00000003, 2, rw_t> PUPDR1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800040c, 0x00000003, 0, rw_t> PUPDR0;
        };
        /*
            GPIO port input data register
         */
        namespace IDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000410, 0xffffffff, 0, ro_t> IDR_REG;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000410, 0x00000001, 15, ro_t> IDR15;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000410, 0x00000001, 14, ro_t> IDR14;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000410, 0x00000001, 13, ro_t> IDR13;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000410, 0x00000001, 12, ro_t> IDR12;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000410, 0x00000001, 11, ro_t> IDR11;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000410, 0x00000001, 10, ro_t> IDR10;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000410, 0x00000001, 9, ro_t> IDR9;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000410, 0x00000001, 8, ro_t> IDR8;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000410, 0x00000001, 7, ro_t> IDR7;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000410, 0x00000001, 6, ro_t> IDR6;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000410, 0x00000001, 5, ro_t> IDR5;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000410, 0x00000001, 4, ro_t> IDR4;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000410, 0x00000001, 3, ro_t> IDR3;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000410, 0x00000001, 2, ro_t> IDR2;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000410, 0x00000001, 1, ro_t> IDR1;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000410, 0x00000001, 0, ro_t> IDR0;
        };
        /*
            GPIO port output data register
         */
        namespace ODR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000414, 0xffffffff, 0, rw_t> ODR_REG;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000414, 0x00000001, 15, rw_t> ODR15;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000414, 0x00000001, 14, rw_t> ODR14;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000414, 0x00000001, 13, rw_t> ODR13;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000414, 0x00000001, 12, rw_t> ODR12;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000414, 0x00000001, 11, rw_t> ODR11;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000414, 0x00000001, 10, rw_t> ODR10;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000414, 0x00000001, 9, rw_t> ODR9;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000414, 0x00000001, 8, rw_t> ODR8;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000414, 0x00000001, 7, rw_t> ODR7;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000414, 0x00000001, 6, rw_t> ODR6;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000414, 0x00000001, 5, rw_t> ODR5;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000414, 0x00000001, 4, rw_t> ODR4;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000414, 0x00000001, 3, rw_t> ODR3;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000414, 0x00000001, 2, rw_t> ODR2;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000414, 0x00000001, 1, rw_t> ODR1;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000414, 0x00000001, 0, rw_t> ODR0;
        };
        /*
            GPIO port bit set/reset
          register
         */
        namespace BSRR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000418, 0xffffffff, 0, wo_t> BSRR_REG;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 31, wo_t> BR15;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 30, wo_t> BR14;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 29, wo_t> BR13;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 28, wo_t> BR12;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 27, wo_t> BR11;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 26, wo_t> BR10;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 25, wo_t> BR9;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 24, wo_t> BR8;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 23, wo_t> BR7;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 22, wo_t> BR6;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 21, wo_t> BR5;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 20, wo_t> BR4;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 19, wo_t> BR3;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 18, wo_t> BR2;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 17, wo_t> BR1;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 16, wo_t> BR0;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 15, wo_t> BS15;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 14, wo_t> BS14;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 13, wo_t> BS13;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 12, wo_t> BS12;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 11, wo_t> BS11;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 10, wo_t> BS10;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 9, wo_t> BS9;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 8, wo_t> BS8;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 7, wo_t> BS7;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 6, wo_t> BS6;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 5, wo_t> BS5;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 4, wo_t> BS4;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 3, wo_t> BS3;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 2, wo_t> BS2;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 1, wo_t> BS1;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000418, 0x00000001, 0, wo_t> BS0;
        };
        /*
            GPIO port configuration lock
          register
         */
        namespace LCKR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4800041c, 0xffffffff, 0, rw_t> LCKR_REG;
            /*
                Lok Key
             */
            typedef reg_t<0x4800041c, 0x00000001, 16, rw_t> LCKK;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800041c, 0x00000001, 15, rw_t> LCK15;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800041c, 0x00000001, 14, rw_t> LCK14;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800041c, 0x00000001, 13, rw_t> LCK13;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800041c, 0x00000001, 12, rw_t> LCK12;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800041c, 0x00000001, 11, rw_t> LCK11;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800041c, 0x00000001, 10, rw_t> LCK10;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800041c, 0x00000001, 9, rw_t> LCK9;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800041c, 0x00000001, 8, rw_t> LCK8;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800041c, 0x00000001, 7, rw_t> LCK7;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800041c, 0x00000001, 6, rw_t> LCK6;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800041c, 0x00000001, 5, rw_t> LCK5;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800041c, 0x00000001, 4, rw_t> LCK4;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800041c, 0x00000001, 3, rw_t> LCK3;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800041c, 0x00000001, 2, rw_t> LCK2;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800041c, 0x00000001, 1, rw_t> LCK1;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800041c, 0x00000001, 0, rw_t> LCK0;
        };
        /*
            GPIO alternate function low
          register
         */
        namespace AFRL {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000420, 0xffffffff, 0, rw_t> AFRL_REG;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000420, 0x0000000f, 28, rw_t> AFRL7;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000420, 0x0000000f, 24, rw_t> AFRL6;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000420, 0x0000000f, 20, rw_t> AFRL5;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000420, 0x0000000f, 16, rw_t> AFRL4;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000420, 0x0000000f, 12, rw_t> AFRL3;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000420, 0x0000000f, 8, rw_t> AFRL2;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000420, 0x0000000f, 4, rw_t> AFRL1;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000420, 0x0000000f, 0, rw_t> AFRL0;
        };
        /*
            GPIO alternate function high
          register
         */
        namespace AFRH {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000424, 0xffffffff, 0, rw_t> AFRH_REG;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000424, 0x0000000f, 28, rw_t> AFRH15;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000424, 0x0000000f, 24, rw_t> AFRH14;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000424, 0x0000000f, 20, rw_t> AFRH13;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000424, 0x0000000f, 16, rw_t> AFRH12;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000424, 0x0000000f, 12, rw_t> AFRH11;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000424, 0x0000000f, 8, rw_t> AFRH10;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000424, 0x0000000f, 4, rw_t> AFRH9;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000424, 0x0000000f, 0, rw_t> AFRH8;
        };
        /*
            Port bit reset register
         */
        namespace BRR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000428, 0xffffffff, 0, wo_t> BRR_REG;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000428, 0x00000001, 0, wo_t> BR0;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000428, 0x00000001, 1, wo_t> BR1;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000428, 0x00000001, 2, wo_t> BR2;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000428, 0x00000001, 3, wo_t> BR3;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000428, 0x00000001, 4, wo_t> BR4;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000428, 0x00000001, 5, wo_t> BR5;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000428, 0x00000001, 6, wo_t> BR6;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000428, 0x00000001, 7, wo_t> BR7;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000428, 0x00000001, 8, wo_t> BR8;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000428, 0x00000001, 9, wo_t> BR9;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000428, 0x00000001, 10, wo_t> BR10;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000428, 0x00000001, 11, wo_t> BR11;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000428, 0x00000001, 12, wo_t> BR12;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000428, 0x00000001, 13, wo_t> BR13;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000428, 0x00000001, 14, wo_t> BR14;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000428, 0x00000001, 15, wo_t> BR15;
        };
    };
    /*
        General-purpose I/Os
     */
    namespace GPIOC {
        /*
            GPIO port mode register
         */
        namespace MODER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000800, 0xffffffff, 0, rw_t> MODER_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000800, 0x00000003, 30, rw_t> MODER15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000800, 0x00000003, 28, rw_t> MODER14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000800, 0x00000003, 26, rw_t> MODER13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000800, 0x00000003, 24, rw_t> MODER12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000800, 0x00000003, 22, rw_t> MODER11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000800, 0x00000003, 20, rw_t> MODER10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000800, 0x00000003, 18, rw_t> MODER9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000800, 0x00000003, 16, rw_t> MODER8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000800, 0x00000003, 14, rw_t> MODER7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000800, 0x00000003, 12, rw_t> MODER6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000800, 0x00000003, 10, rw_t> MODER5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000800, 0x00000003, 8, rw_t> MODER4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000800, 0x00000003, 6, rw_t> MODER3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000800, 0x00000003, 4, rw_t> MODER2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000800, 0x00000003, 2, rw_t> MODER1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000800, 0x00000003, 0, rw_t> MODER0;
        };
        /*
            GPIO port output type register
         */
        namespace OTYPER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000804, 0xffffffff, 0, rw_t> OTYPER_REG;
            /*
                Port x configuration bit
              15
             */
            typedef reg_t<0x48000804, 0x00000001, 15, rw_t> OT15;
            /*
                Port x configuration bit
              14
             */
            typedef reg_t<0x48000804, 0x00000001, 14, rw_t> OT14;
            /*
                Port x configuration bit
              13
             */
            typedef reg_t<0x48000804, 0x00000001, 13, rw_t> OT13;
            /*
                Port x configuration bit
              12
             */
            typedef reg_t<0x48000804, 0x00000001, 12, rw_t> OT12;
            /*
                Port x configuration bit
              11
             */
            typedef reg_t<0x48000804, 0x00000001, 11, rw_t> OT11;
            /*
                Port x configuration bit
              10
             */
            typedef reg_t<0x48000804, 0x00000001, 10, rw_t> OT10;
            /*
                Port x configuration bit 9
             */
            typedef reg_t<0x48000804, 0x00000001, 9, rw_t> OT9;
            /*
                Port x configuration bit 8
             */
            typedef reg_t<0x48000804, 0x00000001, 8, rw_t> OT8;
            /*
                Port x configuration bit 7
             */
            typedef reg_t<0x48000804, 0x00000001, 7, rw_t> OT7;
            /*
                Port x configuration bit 6
             */
            typedef reg_t<0x48000804, 0x00000001, 6, rw_t> OT6;
            /*
                Port x configuration bit 5
             */
            typedef reg_t<0x48000804, 0x00000001, 5, rw_t> OT5;
            /*
                Port x configuration bit 4
             */
            typedef reg_t<0x48000804, 0x00000001, 4, rw_t> OT4;
            /*
                Port x configuration bit 3
             */
            typedef reg_t<0x48000804, 0x00000001, 3, rw_t> OT3;
            /*
                Port x configuration bit 2
             */
            typedef reg_t<0x48000804, 0x00000001, 2, rw_t> OT2;
            /*
                Port x configuration bit 1
             */
            typedef reg_t<0x48000804, 0x00000001, 1, rw_t> OT1;
            /*
                Port x configuration bit 0
             */
            typedef reg_t<0x48000804, 0x00000001, 0, rw_t> OT0;
        };
        /*
            GPIO port output speed
          register
         */
        namespace OSPEEDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000808, 0xffffffff, 0, rw_t> OSPEEDR_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000808, 0x00000003, 30, rw_t> OSPEEDR15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000808, 0x00000003, 28, rw_t> OSPEEDR14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000808, 0x00000003, 26, rw_t> OSPEEDR13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000808, 0x00000003, 24, rw_t> OSPEEDR12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000808, 0x00000003, 22, rw_t> OSPEEDR11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000808, 0x00000003, 20, rw_t> OSPEEDR10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000808, 0x00000003, 18, rw_t> OSPEEDR9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000808, 0x00000003, 16, rw_t> OSPEEDR8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000808, 0x00000003, 14, rw_t> OSPEEDR7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000808, 0x00000003, 12, rw_t> OSPEEDR6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000808, 0x00000003, 10, rw_t> OSPEEDR5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000808, 0x00000003, 8, rw_t> OSPEEDR4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000808, 0x00000003, 6, rw_t> OSPEEDR3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000808, 0x00000003, 4, rw_t> OSPEEDR2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000808, 0x00000003, 2, rw_t> OSPEEDR1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000808, 0x00000003, 0, rw_t> OSPEEDR0;
        };
        /*
            GPIO port pull-up/pull-down
          register
         */
        namespace PUPDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4800080c, 0xffffffff, 0, rw_t> PUPDR_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800080c, 0x00000003, 30, rw_t> PUPDR15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800080c, 0x00000003, 28, rw_t> PUPDR14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800080c, 0x00000003, 26, rw_t> PUPDR13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800080c, 0x00000003, 24, rw_t> PUPDR12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800080c, 0x00000003, 22, rw_t> PUPDR11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800080c, 0x00000003, 20, rw_t> PUPDR10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800080c, 0x00000003, 18, rw_t> PUPDR9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800080c, 0x00000003, 16, rw_t> PUPDR8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800080c, 0x00000003, 14, rw_t> PUPDR7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800080c, 0x00000003, 12, rw_t> PUPDR6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800080c, 0x00000003, 10, rw_t> PUPDR5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800080c, 0x00000003, 8, rw_t> PUPDR4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800080c, 0x00000003, 6, rw_t> PUPDR3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800080c, 0x00000003, 4, rw_t> PUPDR2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800080c, 0x00000003, 2, rw_t> PUPDR1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800080c, 0x00000003, 0, rw_t> PUPDR0;
        };
        /*
            GPIO port input data register
         */
        namespace IDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000810, 0xffffffff, 0, ro_t> IDR_REG;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000810, 0x00000001, 15, ro_t> IDR15;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000810, 0x00000001, 14, ro_t> IDR14;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000810, 0x00000001, 13, ro_t> IDR13;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000810, 0x00000001, 12, ro_t> IDR12;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000810, 0x00000001, 11, ro_t> IDR11;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000810, 0x00000001, 10, ro_t> IDR10;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000810, 0x00000001, 9, ro_t> IDR9;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000810, 0x00000001, 8, ro_t> IDR8;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000810, 0x00000001, 7, ro_t> IDR7;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000810, 0x00000001, 6, ro_t> IDR6;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000810, 0x00000001, 5, ro_t> IDR5;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000810, 0x00000001, 4, ro_t> IDR4;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000810, 0x00000001, 3, ro_t> IDR3;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000810, 0x00000001, 2, ro_t> IDR2;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000810, 0x00000001, 1, ro_t> IDR1;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000810, 0x00000001, 0, ro_t> IDR0;
        };
        /*
            GPIO port output data register
         */
        namespace ODR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000814, 0xffffffff, 0, rw_t> ODR_REG;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000814, 0x00000001, 15, rw_t> ODR15;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000814, 0x00000001, 14, rw_t> ODR14;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000814, 0x00000001, 13, rw_t> ODR13;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000814, 0x00000001, 12, rw_t> ODR12;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000814, 0x00000001, 11, rw_t> ODR11;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000814, 0x00000001, 10, rw_t> ODR10;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000814, 0x00000001, 9, rw_t> ODR9;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000814, 0x00000001, 8, rw_t> ODR8;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000814, 0x00000001, 7, rw_t> ODR7;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000814, 0x00000001, 6, rw_t> ODR6;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000814, 0x00000001, 5, rw_t> ODR5;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000814, 0x00000001, 4, rw_t> ODR4;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000814, 0x00000001, 3, rw_t> ODR3;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000814, 0x00000001, 2, rw_t> ODR2;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000814, 0x00000001, 1, rw_t> ODR1;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000814, 0x00000001, 0, rw_t> ODR0;
        };
        /*
            GPIO port bit set/reset
          register
         */
        namespace BSRR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000818, 0xffffffff, 0, wo_t> BSRR_REG;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 31, wo_t> BR15;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 30, wo_t> BR14;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 29, wo_t> BR13;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 28, wo_t> BR12;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 27, wo_t> BR11;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 26, wo_t> BR10;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 25, wo_t> BR9;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 24, wo_t> BR8;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 23, wo_t> BR7;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 22, wo_t> BR6;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 21, wo_t> BR5;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 20, wo_t> BR4;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 19, wo_t> BR3;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 18, wo_t> BR2;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 17, wo_t> BR1;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 16, wo_t> BR0;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 15, wo_t> BS15;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 14, wo_t> BS14;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 13, wo_t> BS13;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 12, wo_t> BS12;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 11, wo_t> BS11;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 10, wo_t> BS10;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 9, wo_t> BS9;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 8, wo_t> BS8;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 7, wo_t> BS7;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 6, wo_t> BS6;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 5, wo_t> BS5;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 4, wo_t> BS4;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 3, wo_t> BS3;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 2, wo_t> BS2;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 1, wo_t> BS1;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000818, 0x00000001, 0, wo_t> BS0;
        };
        /*
            GPIO port configuration lock
          register
         */
        namespace LCKR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4800081c, 0xffffffff, 0, rw_t> LCKR_REG;
            /*
                Lok Key
             */
            typedef reg_t<0x4800081c, 0x00000001, 16, rw_t> LCKK;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800081c, 0x00000001, 15, rw_t> LCK15;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800081c, 0x00000001, 14, rw_t> LCK14;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800081c, 0x00000001, 13, rw_t> LCK13;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800081c, 0x00000001, 12, rw_t> LCK12;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800081c, 0x00000001, 11, rw_t> LCK11;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800081c, 0x00000001, 10, rw_t> LCK10;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800081c, 0x00000001, 9, rw_t> LCK9;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800081c, 0x00000001, 8, rw_t> LCK8;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800081c, 0x00000001, 7, rw_t> LCK7;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800081c, 0x00000001, 6, rw_t> LCK6;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800081c, 0x00000001, 5, rw_t> LCK5;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800081c, 0x00000001, 4, rw_t> LCK4;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800081c, 0x00000001, 3, rw_t> LCK3;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800081c, 0x00000001, 2, rw_t> LCK2;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800081c, 0x00000001, 1, rw_t> LCK1;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800081c, 0x00000001, 0, rw_t> LCK0;
        };
        /*
            GPIO alternate function low
          register
         */
        namespace AFRL {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000820, 0xffffffff, 0, rw_t> AFRL_REG;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000820, 0x0000000f, 28, rw_t> AFRL7;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000820, 0x0000000f, 24, rw_t> AFRL6;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000820, 0x0000000f, 20, rw_t> AFRL5;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000820, 0x0000000f, 16, rw_t> AFRL4;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000820, 0x0000000f, 12, rw_t> AFRL3;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000820, 0x0000000f, 8, rw_t> AFRL2;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000820, 0x0000000f, 4, rw_t> AFRL1;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000820, 0x0000000f, 0, rw_t> AFRL0;
        };
        /*
            GPIO alternate function high
          register
         */
        namespace AFRH {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000824, 0xffffffff, 0, rw_t> AFRH_REG;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000824, 0x0000000f, 28, rw_t> AFRH15;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000824, 0x0000000f, 24, rw_t> AFRH14;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000824, 0x0000000f, 20, rw_t> AFRH13;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000824, 0x0000000f, 16, rw_t> AFRH12;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000824, 0x0000000f, 12, rw_t> AFRH11;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000824, 0x0000000f, 8, rw_t> AFRH10;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000824, 0x0000000f, 4, rw_t> AFRH9;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000824, 0x0000000f, 0, rw_t> AFRH8;
        };
        /*
            Port bit reset register
         */
        namespace BRR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000828, 0xffffffff, 0, wo_t> BRR_REG;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000828, 0x00000001, 0, wo_t> BR0;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000828, 0x00000001, 1, wo_t> BR1;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000828, 0x00000001, 2, wo_t> BR2;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000828, 0x00000001, 3, wo_t> BR3;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000828, 0x00000001, 4, wo_t> BR4;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000828, 0x00000001, 5, wo_t> BR5;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000828, 0x00000001, 6, wo_t> BR6;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000828, 0x00000001, 7, wo_t> BR7;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000828, 0x00000001, 8, wo_t> BR8;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000828, 0x00000001, 9, wo_t> BR9;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000828, 0x00000001, 10, wo_t> BR10;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000828, 0x00000001, 11, wo_t> BR11;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000828, 0x00000001, 12, wo_t> BR12;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000828, 0x00000001, 13, wo_t> BR13;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000828, 0x00000001, 14, wo_t> BR14;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000828, 0x00000001, 15, wo_t> BR15;
        };
    };
    /*
        General-purpose I/Os
     */
    namespace GPIOD {
        /*
            GPIO port mode register
         */
        namespace MODER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000c00, 0xffffffff, 0, rw_t> MODER_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c00, 0x00000003, 30, rw_t> MODER15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c00, 0x00000003, 28, rw_t> MODER14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c00, 0x00000003, 26, rw_t> MODER13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c00, 0x00000003, 24, rw_t> MODER12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c00, 0x00000003, 22, rw_t> MODER11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c00, 0x00000003, 20, rw_t> MODER10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c00, 0x00000003, 18, rw_t> MODER9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c00, 0x00000003, 16, rw_t> MODER8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c00, 0x00000003, 14, rw_t> MODER7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c00, 0x00000003, 12, rw_t> MODER6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c00, 0x00000003, 10, rw_t> MODER5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c00, 0x00000003, 8, rw_t> MODER4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c00, 0x00000003, 6, rw_t> MODER3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c00, 0x00000003, 4, rw_t> MODER2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c00, 0x00000003, 2, rw_t> MODER1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c00, 0x00000003, 0, rw_t> MODER0;
        };
        /*
            GPIO port output type register
         */
        namespace OTYPER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000c04, 0xffffffff, 0, rw_t> OTYPER_REG;
            /*
                Port x configuration bit
              15
             */
            typedef reg_t<0x48000c04, 0x00000001, 15, rw_t> OT15;
            /*
                Port x configuration bit
              14
             */
            typedef reg_t<0x48000c04, 0x00000001, 14, rw_t> OT14;
            /*
                Port x configuration bit
              13
             */
            typedef reg_t<0x48000c04, 0x00000001, 13, rw_t> OT13;
            /*
                Port x configuration bit
              12
             */
            typedef reg_t<0x48000c04, 0x00000001, 12, rw_t> OT12;
            /*
                Port x configuration bit
              11
             */
            typedef reg_t<0x48000c04, 0x00000001, 11, rw_t> OT11;
            /*
                Port x configuration bit
              10
             */
            typedef reg_t<0x48000c04, 0x00000001, 10, rw_t> OT10;
            /*
                Port x configuration bit 9
             */
            typedef reg_t<0x48000c04, 0x00000001, 9, rw_t> OT9;
            /*
                Port x configuration bit 8
             */
            typedef reg_t<0x48000c04, 0x00000001, 8, rw_t> OT8;
            /*
                Port x configuration bit 7
             */
            typedef reg_t<0x48000c04, 0x00000001, 7, rw_t> OT7;
            /*
                Port x configuration bit 6
             */
            typedef reg_t<0x48000c04, 0x00000001, 6, rw_t> OT6;
            /*
                Port x configuration bit 5
             */
            typedef reg_t<0x48000c04, 0x00000001, 5, rw_t> OT5;
            /*
                Port x configuration bit 4
             */
            typedef reg_t<0x48000c04, 0x00000001, 4, rw_t> OT4;
            /*
                Port x configuration bit 3
             */
            typedef reg_t<0x48000c04, 0x00000001, 3, rw_t> OT3;
            /*
                Port x configuration bit 2
             */
            typedef reg_t<0x48000c04, 0x00000001, 2, rw_t> OT2;
            /*
                Port x configuration bit 1
             */
            typedef reg_t<0x48000c04, 0x00000001, 1, rw_t> OT1;
            /*
                Port x configuration bit 0
             */
            typedef reg_t<0x48000c04, 0x00000001, 0, rw_t> OT0;
        };
        /*
            GPIO port output speed
          register
         */
        namespace OSPEEDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000c08, 0xffffffff, 0, rw_t> OSPEEDR_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c08, 0x00000003, 30, rw_t> OSPEEDR15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c08, 0x00000003, 28, rw_t> OSPEEDR14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c08, 0x00000003, 26, rw_t> OSPEEDR13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c08, 0x00000003, 24, rw_t> OSPEEDR12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c08, 0x00000003, 22, rw_t> OSPEEDR11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c08, 0x00000003, 20, rw_t> OSPEEDR10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c08, 0x00000003, 18, rw_t> OSPEEDR9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c08, 0x00000003, 16, rw_t> OSPEEDR8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c08, 0x00000003, 14, rw_t> OSPEEDR7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c08, 0x00000003, 12, rw_t> OSPEEDR6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c08, 0x00000003, 10, rw_t> OSPEEDR5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c08, 0x00000003, 8, rw_t> OSPEEDR4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c08, 0x00000003, 6, rw_t> OSPEEDR3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c08, 0x00000003, 4, rw_t> OSPEEDR2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c08, 0x00000003, 2, rw_t> OSPEEDR1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c08, 0x00000003, 0, rw_t> OSPEEDR0;
        };
        /*
            GPIO port pull-up/pull-down
          register
         */
        namespace PUPDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000c0c, 0xffffffff, 0, rw_t> PUPDR_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c0c, 0x00000003, 30, rw_t> PUPDR15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c0c, 0x00000003, 28, rw_t> PUPDR14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c0c, 0x00000003, 26, rw_t> PUPDR13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c0c, 0x00000003, 24, rw_t> PUPDR12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c0c, 0x00000003, 22, rw_t> PUPDR11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c0c, 0x00000003, 20, rw_t> PUPDR10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c0c, 0x00000003, 18, rw_t> PUPDR9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c0c, 0x00000003, 16, rw_t> PUPDR8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c0c, 0x00000003, 14, rw_t> PUPDR7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c0c, 0x00000003, 12, rw_t> PUPDR6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c0c, 0x00000003, 10, rw_t> PUPDR5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c0c, 0x00000003, 8, rw_t> PUPDR4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c0c, 0x00000003, 6, rw_t> PUPDR3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c0c, 0x00000003, 4, rw_t> PUPDR2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c0c, 0x00000003, 2, rw_t> PUPDR1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48000c0c, 0x00000003, 0, rw_t> PUPDR0;
        };
        /*
            GPIO port input data register
         */
        namespace IDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000c10, 0xffffffff, 0, ro_t> IDR_REG;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000c10, 0x00000001, 15, ro_t> IDR15;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000c10, 0x00000001, 14, ro_t> IDR14;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000c10, 0x00000001, 13, ro_t> IDR13;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000c10, 0x00000001, 12, ro_t> IDR12;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000c10, 0x00000001, 11, ro_t> IDR11;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000c10, 0x00000001, 10, ro_t> IDR10;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000c10, 0x00000001, 9, ro_t> IDR9;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000c10, 0x00000001, 8, ro_t> IDR8;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000c10, 0x00000001, 7, ro_t> IDR7;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000c10, 0x00000001, 6, ro_t> IDR6;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000c10, 0x00000001, 5, ro_t> IDR5;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000c10, 0x00000001, 4, ro_t> IDR4;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000c10, 0x00000001, 3, ro_t> IDR3;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000c10, 0x00000001, 2, ro_t> IDR2;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000c10, 0x00000001, 1, ro_t> IDR1;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48000c10, 0x00000001, 0, ro_t> IDR0;
        };
        /*
            GPIO port output data register
         */
        namespace ODR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000c14, 0xffffffff, 0, rw_t> ODR_REG;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000c14, 0x00000001, 15, rw_t> ODR15;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000c14, 0x00000001, 14, rw_t> ODR14;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000c14, 0x00000001, 13, rw_t> ODR13;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000c14, 0x00000001, 12, rw_t> ODR12;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000c14, 0x00000001, 11, rw_t> ODR11;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000c14, 0x00000001, 10, rw_t> ODR10;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000c14, 0x00000001, 9, rw_t> ODR9;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000c14, 0x00000001, 8, rw_t> ODR8;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000c14, 0x00000001, 7, rw_t> ODR7;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000c14, 0x00000001, 6, rw_t> ODR6;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000c14, 0x00000001, 5, rw_t> ODR5;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000c14, 0x00000001, 4, rw_t> ODR4;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000c14, 0x00000001, 3, rw_t> ODR3;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000c14, 0x00000001, 2, rw_t> ODR2;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000c14, 0x00000001, 1, rw_t> ODR1;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48000c14, 0x00000001, 0, rw_t> ODR0;
        };
        /*
            GPIO port bit set/reset
          register
         */
        namespace BSRR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000c18, 0xffffffff, 0, wo_t> BSRR_REG;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 31, wo_t> BR15;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 30, wo_t> BR14;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 29, wo_t> BR13;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 28, wo_t> BR12;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 27, wo_t> BR11;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 26, wo_t> BR10;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 25, wo_t> BR9;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 24, wo_t> BR8;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 23, wo_t> BR7;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 22, wo_t> BR6;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 21, wo_t> BR5;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 20, wo_t> BR4;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 19, wo_t> BR3;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 18, wo_t> BR2;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 17, wo_t> BR1;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 16, wo_t> BR0;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 15, wo_t> BS15;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 14, wo_t> BS14;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 13, wo_t> BS13;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 12, wo_t> BS12;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 11, wo_t> BS11;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 10, wo_t> BS10;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 9, wo_t> BS9;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 8, wo_t> BS8;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 7, wo_t> BS7;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 6, wo_t> BS6;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 5, wo_t> BS5;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 4, wo_t> BS4;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 3, wo_t> BS3;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 2, wo_t> BS2;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 1, wo_t> BS1;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c18, 0x00000001, 0, wo_t> BS0;
        };
        /*
            GPIO port configuration lock
          register
         */
        namespace LCKR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000c1c, 0xffffffff, 0, rw_t> LCKR_REG;
            /*
                Lok Key
             */
            typedef reg_t<0x48000c1c, 0x00000001, 16, rw_t> LCKK;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c1c, 0x00000001, 15, rw_t> LCK15;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c1c, 0x00000001, 14, rw_t> LCK14;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c1c, 0x00000001, 13, rw_t> LCK13;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c1c, 0x00000001, 12, rw_t> LCK12;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c1c, 0x00000001, 11, rw_t> LCK11;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c1c, 0x00000001, 10, rw_t> LCK10;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c1c, 0x00000001, 9, rw_t> LCK9;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c1c, 0x00000001, 8, rw_t> LCK8;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c1c, 0x00000001, 7, rw_t> LCK7;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c1c, 0x00000001, 6, rw_t> LCK6;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c1c, 0x00000001, 5, rw_t> LCK5;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c1c, 0x00000001, 4, rw_t> LCK4;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c1c, 0x00000001, 3, rw_t> LCK3;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c1c, 0x00000001, 2, rw_t> LCK2;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c1c, 0x00000001, 1, rw_t> LCK1;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48000c1c, 0x00000001, 0, rw_t> LCK0;
        };
        /*
            GPIO alternate function low
          register
         */
        namespace AFRL {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000c20, 0xffffffff, 0, rw_t> AFRL_REG;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000c20, 0x0000000f, 28, rw_t> AFRL7;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000c20, 0x0000000f, 24, rw_t> AFRL6;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000c20, 0x0000000f, 20, rw_t> AFRL5;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000c20, 0x0000000f, 16, rw_t> AFRL4;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000c20, 0x0000000f, 12, rw_t> AFRL3;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000c20, 0x0000000f, 8, rw_t> AFRL2;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000c20, 0x0000000f, 4, rw_t> AFRL1;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48000c20, 0x0000000f, 0, rw_t> AFRL0;
        };
        /*
            GPIO alternate function high
          register
         */
        namespace AFRH {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000c24, 0xffffffff, 0, rw_t> AFRH_REG;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000c24, 0x0000000f, 28, rw_t> AFRH15;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000c24, 0x0000000f, 24, rw_t> AFRH14;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000c24, 0x0000000f, 20, rw_t> AFRH13;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000c24, 0x0000000f, 16, rw_t> AFRH12;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000c24, 0x0000000f, 12, rw_t> AFRH11;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000c24, 0x0000000f, 8, rw_t> AFRH10;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000c24, 0x0000000f, 4, rw_t> AFRH9;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48000c24, 0x0000000f, 0, rw_t> AFRH8;
        };
        /*
            Port bit reset register
         */
        namespace BRR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48000c28, 0xffffffff, 0, wo_t> BRR_REG;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000c28, 0x00000001, 0, wo_t> BR0;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000c28, 0x00000001, 1, wo_t> BR1;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000c28, 0x00000001, 2, wo_t> BR2;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000c28, 0x00000001, 3, wo_t> BR3;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000c28, 0x00000001, 4, wo_t> BR4;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000c28, 0x00000001, 5, wo_t> BR5;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000c28, 0x00000001, 6, wo_t> BR6;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000c28, 0x00000001, 7, wo_t> BR7;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000c28, 0x00000001, 8, wo_t> BR8;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000c28, 0x00000001, 9, wo_t> BR9;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000c28, 0x00000001, 10, wo_t> BR10;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000c28, 0x00000001, 11, wo_t> BR11;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000c28, 0x00000001, 12, wo_t> BR12;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000c28, 0x00000001, 13, wo_t> BR13;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000c28, 0x00000001, 14, wo_t> BR14;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48000c28, 0x00000001, 15, wo_t> BR15;
        };
    };
    /*
        General-purpose I/Os
     */
    namespace GPIOE {
        /*
            GPIO port mode register
         */
        namespace MODER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001000, 0xffffffff, 0, rw_t> MODER_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001000, 0x00000003, 30, rw_t> MODER15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001000, 0x00000003, 28, rw_t> MODER14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001000, 0x00000003, 26, rw_t> MODER13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001000, 0x00000003, 24, rw_t> MODER12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001000, 0x00000003, 22, rw_t> MODER11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001000, 0x00000003, 20, rw_t> MODER10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001000, 0x00000003, 18, rw_t> MODER9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001000, 0x00000003, 16, rw_t> MODER8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001000, 0x00000003, 14, rw_t> MODER7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001000, 0x00000003, 12, rw_t> MODER6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001000, 0x00000003, 10, rw_t> MODER5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001000, 0x00000003, 8, rw_t> MODER4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001000, 0x00000003, 6, rw_t> MODER3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001000, 0x00000003, 4, rw_t> MODER2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001000, 0x00000003, 2, rw_t> MODER1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001000, 0x00000003, 0, rw_t> MODER0;
        };
        /*
            GPIO port output type register
         */
        namespace OTYPER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001004, 0xffffffff, 0, rw_t> OTYPER_REG;
            /*
                Port x configuration bit
              15
             */
            typedef reg_t<0x48001004, 0x00000001, 15, rw_t> OT15;
            /*
                Port x configuration bit
              14
             */
            typedef reg_t<0x48001004, 0x00000001, 14, rw_t> OT14;
            /*
                Port x configuration bit
              13
             */
            typedef reg_t<0x48001004, 0x00000001, 13, rw_t> OT13;
            /*
                Port x configuration bit
              12
             */
            typedef reg_t<0x48001004, 0x00000001, 12, rw_t> OT12;
            /*
                Port x configuration bit
              11
             */
            typedef reg_t<0x48001004, 0x00000001, 11, rw_t> OT11;
            /*
                Port x configuration bit
              10
             */
            typedef reg_t<0x48001004, 0x00000001, 10, rw_t> OT10;
            /*
                Port x configuration bit 9
             */
            typedef reg_t<0x48001004, 0x00000001, 9, rw_t> OT9;
            /*
                Port x configuration bit 8
             */
            typedef reg_t<0x48001004, 0x00000001, 8, rw_t> OT8;
            /*
                Port x configuration bit 7
             */
            typedef reg_t<0x48001004, 0x00000001, 7, rw_t> OT7;
            /*
                Port x configuration bit 6
             */
            typedef reg_t<0x48001004, 0x00000001, 6, rw_t> OT6;
            /*
                Port x configuration bit 5
             */
            typedef reg_t<0x48001004, 0x00000001, 5, rw_t> OT5;
            /*
                Port x configuration bit 4
             */
            typedef reg_t<0x48001004, 0x00000001, 4, rw_t> OT4;
            /*
                Port x configuration bit 3
             */
            typedef reg_t<0x48001004, 0x00000001, 3, rw_t> OT3;
            /*
                Port x configuration bit 2
             */
            typedef reg_t<0x48001004, 0x00000001, 2, rw_t> OT2;
            /*
                Port x configuration bit 1
             */
            typedef reg_t<0x48001004, 0x00000001, 1, rw_t> OT1;
            /*
                Port x configuration bit 0
             */
            typedef reg_t<0x48001004, 0x00000001, 0, rw_t> OT0;
        };
        /*
            GPIO port output speed
          register
         */
        namespace OSPEEDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001008, 0xffffffff, 0, rw_t> OSPEEDR_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001008, 0x00000003, 30, rw_t> OSPEEDR15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001008, 0x00000003, 28, rw_t> OSPEEDR14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001008, 0x00000003, 26, rw_t> OSPEEDR13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001008, 0x00000003, 24, rw_t> OSPEEDR12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001008, 0x00000003, 22, rw_t> OSPEEDR11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001008, 0x00000003, 20, rw_t> OSPEEDR10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001008, 0x00000003, 18, rw_t> OSPEEDR9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001008, 0x00000003, 16, rw_t> OSPEEDR8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001008, 0x00000003, 14, rw_t> OSPEEDR7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001008, 0x00000003, 12, rw_t> OSPEEDR6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001008, 0x00000003, 10, rw_t> OSPEEDR5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001008, 0x00000003, 8, rw_t> OSPEEDR4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001008, 0x00000003, 6, rw_t> OSPEEDR3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001008, 0x00000003, 4, rw_t> OSPEEDR2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001008, 0x00000003, 2, rw_t> OSPEEDR1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001008, 0x00000003, 0, rw_t> OSPEEDR0;
        };
        /*
            GPIO port pull-up/pull-down
          register
         */
        namespace PUPDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4800100c, 0xffffffff, 0, rw_t> PUPDR_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800100c, 0x00000003, 30, rw_t> PUPDR15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800100c, 0x00000003, 28, rw_t> PUPDR14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800100c, 0x00000003, 26, rw_t> PUPDR13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800100c, 0x00000003, 24, rw_t> PUPDR12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800100c, 0x00000003, 22, rw_t> PUPDR11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800100c, 0x00000003, 20, rw_t> PUPDR10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800100c, 0x00000003, 18, rw_t> PUPDR9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800100c, 0x00000003, 16, rw_t> PUPDR8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800100c, 0x00000003, 14, rw_t> PUPDR7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800100c, 0x00000003, 12, rw_t> PUPDR6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800100c, 0x00000003, 10, rw_t> PUPDR5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800100c, 0x00000003, 8, rw_t> PUPDR4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800100c, 0x00000003, 6, rw_t> PUPDR3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800100c, 0x00000003, 4, rw_t> PUPDR2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800100c, 0x00000003, 2, rw_t> PUPDR1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800100c, 0x00000003, 0, rw_t> PUPDR0;
        };
        /*
            GPIO port input data register
         */
        namespace IDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001010, 0xffffffff, 0, ro_t> IDR_REG;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001010, 0x00000001, 15, ro_t> IDR15;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001010, 0x00000001, 14, ro_t> IDR14;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001010, 0x00000001, 13, ro_t> IDR13;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001010, 0x00000001, 12, ro_t> IDR12;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001010, 0x00000001, 11, ro_t> IDR11;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001010, 0x00000001, 10, ro_t> IDR10;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001010, 0x00000001, 9, ro_t> IDR9;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001010, 0x00000001, 8, ro_t> IDR8;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001010, 0x00000001, 7, ro_t> IDR7;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001010, 0x00000001, 6, ro_t> IDR6;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001010, 0x00000001, 5, ro_t> IDR5;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001010, 0x00000001, 4, ro_t> IDR4;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001010, 0x00000001, 3, ro_t> IDR3;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001010, 0x00000001, 2, ro_t> IDR2;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001010, 0x00000001, 1, ro_t> IDR1;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001010, 0x00000001, 0, ro_t> IDR0;
        };
        /*
            GPIO port output data register
         */
        namespace ODR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001014, 0xffffffff, 0, rw_t> ODR_REG;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001014, 0x00000001, 15, rw_t> ODR15;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001014, 0x00000001, 14, rw_t> ODR14;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001014, 0x00000001, 13, rw_t> ODR13;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001014, 0x00000001, 12, rw_t> ODR12;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001014, 0x00000001, 11, rw_t> ODR11;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001014, 0x00000001, 10, rw_t> ODR10;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001014, 0x00000001, 9, rw_t> ODR9;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001014, 0x00000001, 8, rw_t> ODR8;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001014, 0x00000001, 7, rw_t> ODR7;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001014, 0x00000001, 6, rw_t> ODR6;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001014, 0x00000001, 5, rw_t> ODR5;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001014, 0x00000001, 4, rw_t> ODR4;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001014, 0x00000001, 3, rw_t> ODR3;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001014, 0x00000001, 2, rw_t> ODR2;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001014, 0x00000001, 1, rw_t> ODR1;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001014, 0x00000001, 0, rw_t> ODR0;
        };
        /*
            GPIO port bit set/reset
          register
         */
        namespace BSRR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001018, 0xffffffff, 0, wo_t> BSRR_REG;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 31, wo_t> BR15;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 30, wo_t> BR14;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 29, wo_t> BR13;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 28, wo_t> BR12;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 27, wo_t> BR11;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 26, wo_t> BR10;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 25, wo_t> BR9;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 24, wo_t> BR8;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 23, wo_t> BR7;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 22, wo_t> BR6;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 21, wo_t> BR5;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 20, wo_t> BR4;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 19, wo_t> BR3;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 18, wo_t> BR2;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 17, wo_t> BR1;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 16, wo_t> BR0;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 15, wo_t> BS15;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 14, wo_t> BS14;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 13, wo_t> BS13;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 12, wo_t> BS12;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 11, wo_t> BS11;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 10, wo_t> BS10;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 9, wo_t> BS9;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 8, wo_t> BS8;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 7, wo_t> BS7;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 6, wo_t> BS6;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 5, wo_t> BS5;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 4, wo_t> BS4;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 3, wo_t> BS3;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 2, wo_t> BS2;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 1, wo_t> BS1;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001018, 0x00000001, 0, wo_t> BS0;
        };
        /*
            GPIO port configuration lock
          register
         */
        namespace LCKR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4800101c, 0xffffffff, 0, rw_t> LCKR_REG;
            /*
                Lok Key
             */
            typedef reg_t<0x4800101c, 0x00000001, 16, rw_t> LCKK;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800101c, 0x00000001, 15, rw_t> LCK15;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800101c, 0x00000001, 14, rw_t> LCK14;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800101c, 0x00000001, 13, rw_t> LCK13;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800101c, 0x00000001, 12, rw_t> LCK12;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800101c, 0x00000001, 11, rw_t> LCK11;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800101c, 0x00000001, 10, rw_t> LCK10;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800101c, 0x00000001, 9, rw_t> LCK9;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800101c, 0x00000001, 8, rw_t> LCK8;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800101c, 0x00000001, 7, rw_t> LCK7;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800101c, 0x00000001, 6, rw_t> LCK6;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800101c, 0x00000001, 5, rw_t> LCK5;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800101c, 0x00000001, 4, rw_t> LCK4;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800101c, 0x00000001, 3, rw_t> LCK3;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800101c, 0x00000001, 2, rw_t> LCK2;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800101c, 0x00000001, 1, rw_t> LCK1;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800101c, 0x00000001, 0, rw_t> LCK0;
        };
        /*
            GPIO alternate function low
          register
         */
        namespace AFRL {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001020, 0xffffffff, 0, rw_t> AFRL_REG;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001020, 0x0000000f, 28, rw_t> AFRL7;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001020, 0x0000000f, 24, rw_t> AFRL6;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001020, 0x0000000f, 20, rw_t> AFRL5;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001020, 0x0000000f, 16, rw_t> AFRL4;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001020, 0x0000000f, 12, rw_t> AFRL3;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001020, 0x0000000f, 8, rw_t> AFRL2;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001020, 0x0000000f, 4, rw_t> AFRL1;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001020, 0x0000000f, 0, rw_t> AFRL0;
        };
        /*
            GPIO alternate function high
          register
         */
        namespace AFRH {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001024, 0xffffffff, 0, rw_t> AFRH_REG;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001024, 0x0000000f, 28, rw_t> AFRH15;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001024, 0x0000000f, 24, rw_t> AFRH14;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001024, 0x0000000f, 20, rw_t> AFRH13;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001024, 0x0000000f, 16, rw_t> AFRH12;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001024, 0x0000000f, 12, rw_t> AFRH11;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001024, 0x0000000f, 8, rw_t> AFRH10;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001024, 0x0000000f, 4, rw_t> AFRH9;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001024, 0x0000000f, 0, rw_t> AFRH8;
        };
        /*
            Port bit reset register
         */
        namespace BRR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001028, 0xffffffff, 0, wo_t> BRR_REG;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001028, 0x00000001, 0, wo_t> BR0;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001028, 0x00000001, 1, wo_t> BR1;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001028, 0x00000001, 2, wo_t> BR2;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001028, 0x00000001, 3, wo_t> BR3;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001028, 0x00000001, 4, wo_t> BR4;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001028, 0x00000001, 5, wo_t> BR5;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001028, 0x00000001, 6, wo_t> BR6;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001028, 0x00000001, 7, wo_t> BR7;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001028, 0x00000001, 8, wo_t> BR8;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001028, 0x00000001, 9, wo_t> BR9;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001028, 0x00000001, 10, wo_t> BR10;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001028, 0x00000001, 11, wo_t> BR11;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001028, 0x00000001, 12, wo_t> BR12;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001028, 0x00000001, 13, wo_t> BR13;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001028, 0x00000001, 14, wo_t> BR14;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001028, 0x00000001, 15, wo_t> BR15;
        };
    };
    /*
        General-purpose I/Os
     */
    namespace GPIOF {
        /*
            GPIO port mode register
         */
        namespace MODER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001400, 0xffffffff, 0, rw_t> MODER_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001400, 0x00000003, 30, rw_t> MODER15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001400, 0x00000003, 28, rw_t> MODER14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001400, 0x00000003, 26, rw_t> MODER13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001400, 0x00000003, 24, rw_t> MODER12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001400, 0x00000003, 22, rw_t> MODER11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001400, 0x00000003, 20, rw_t> MODER10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001400, 0x00000003, 18, rw_t> MODER9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001400, 0x00000003, 16, rw_t> MODER8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001400, 0x00000003, 14, rw_t> MODER7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001400, 0x00000003, 12, rw_t> MODER6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001400, 0x00000003, 10, rw_t> MODER5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001400, 0x00000003, 8, rw_t> MODER4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001400, 0x00000003, 6, rw_t> MODER3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001400, 0x00000003, 4, rw_t> MODER2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001400, 0x00000003, 2, rw_t> MODER1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001400, 0x00000003, 0, rw_t> MODER0;
        };
        /*
            GPIO port output type register
         */
        namespace OTYPER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001404, 0xffffffff, 0, rw_t> OTYPER_REG;
            /*
                Port x configuration bit
              15
             */
            typedef reg_t<0x48001404, 0x00000001, 15, rw_t> OT15;
            /*
                Port x configuration bit
              14
             */
            typedef reg_t<0x48001404, 0x00000001, 14, rw_t> OT14;
            /*
                Port x configuration bit
              13
             */
            typedef reg_t<0x48001404, 0x00000001, 13, rw_t> OT13;
            /*
                Port x configuration bit
              12
             */
            typedef reg_t<0x48001404, 0x00000001, 12, rw_t> OT12;
            /*
                Port x configuration bit
              11
             */
            typedef reg_t<0x48001404, 0x00000001, 11, rw_t> OT11;
            /*
                Port x configuration bit
              10
             */
            typedef reg_t<0x48001404, 0x00000001, 10, rw_t> OT10;
            /*
                Port x configuration bit 9
             */
            typedef reg_t<0x48001404, 0x00000001, 9, rw_t> OT9;
            /*
                Port x configuration bit 8
             */
            typedef reg_t<0x48001404, 0x00000001, 8, rw_t> OT8;
            /*
                Port x configuration bit 7
             */
            typedef reg_t<0x48001404, 0x00000001, 7, rw_t> OT7;
            /*
                Port x configuration bit 6
             */
            typedef reg_t<0x48001404, 0x00000001, 6, rw_t> OT6;
            /*
                Port x configuration bit 5
             */
            typedef reg_t<0x48001404, 0x00000001, 5, rw_t> OT5;
            /*
                Port x configuration bit 4
             */
            typedef reg_t<0x48001404, 0x00000001, 4, rw_t> OT4;
            /*
                Port x configuration bit 3
             */
            typedef reg_t<0x48001404, 0x00000001, 3, rw_t> OT3;
            /*
                Port x configuration bit 2
             */
            typedef reg_t<0x48001404, 0x00000001, 2, rw_t> OT2;
            /*
                Port x configuration bit 1
             */
            typedef reg_t<0x48001404, 0x00000001, 1, rw_t> OT1;
            /*
                Port x configuration bit 0
             */
            typedef reg_t<0x48001404, 0x00000001, 0, rw_t> OT0;
        };
        /*
            GPIO port output speed
          register
         */
        namespace OSPEEDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001408, 0xffffffff, 0, rw_t> OSPEEDR_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001408, 0x00000003, 30, rw_t> OSPEEDR15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001408, 0x00000003, 28, rw_t> OSPEEDR14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001408, 0x00000003, 26, rw_t> OSPEEDR13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001408, 0x00000003, 24, rw_t> OSPEEDR12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001408, 0x00000003, 22, rw_t> OSPEEDR11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001408, 0x00000003, 20, rw_t> OSPEEDR10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001408, 0x00000003, 18, rw_t> OSPEEDR9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001408, 0x00000003, 16, rw_t> OSPEEDR8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001408, 0x00000003, 14, rw_t> OSPEEDR7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001408, 0x00000003, 12, rw_t> OSPEEDR6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001408, 0x00000003, 10, rw_t> OSPEEDR5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001408, 0x00000003, 8, rw_t> OSPEEDR4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001408, 0x00000003, 6, rw_t> OSPEEDR3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001408, 0x00000003, 4, rw_t> OSPEEDR2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001408, 0x00000003, 2, rw_t> OSPEEDR1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001408, 0x00000003, 0, rw_t> OSPEEDR0;
        };
        /*
            GPIO port pull-up/pull-down
          register
         */
        namespace PUPDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4800140c, 0xffffffff, 0, rw_t> PUPDR_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800140c, 0x00000003, 30, rw_t> PUPDR15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800140c, 0x00000003, 28, rw_t> PUPDR14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800140c, 0x00000003, 26, rw_t> PUPDR13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800140c, 0x00000003, 24, rw_t> PUPDR12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800140c, 0x00000003, 22, rw_t> PUPDR11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800140c, 0x00000003, 20, rw_t> PUPDR10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800140c, 0x00000003, 18, rw_t> PUPDR9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800140c, 0x00000003, 16, rw_t> PUPDR8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800140c, 0x00000003, 14, rw_t> PUPDR7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800140c, 0x00000003, 12, rw_t> PUPDR6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800140c, 0x00000003, 10, rw_t> PUPDR5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800140c, 0x00000003, 8, rw_t> PUPDR4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800140c, 0x00000003, 6, rw_t> PUPDR3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800140c, 0x00000003, 4, rw_t> PUPDR2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800140c, 0x00000003, 2, rw_t> PUPDR1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800140c, 0x00000003, 0, rw_t> PUPDR0;
        };
        /*
            GPIO port input data register
         */
        namespace IDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001410, 0xffffffff, 0, ro_t> IDR_REG;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001410, 0x00000001, 15, ro_t> IDR15;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001410, 0x00000001, 14, ro_t> IDR14;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001410, 0x00000001, 13, ro_t> IDR13;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001410, 0x00000001, 12, ro_t> IDR12;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001410, 0x00000001, 11, ro_t> IDR11;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001410, 0x00000001, 10, ro_t> IDR10;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001410, 0x00000001, 9, ro_t> IDR9;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001410, 0x00000001, 8, ro_t> IDR8;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001410, 0x00000001, 7, ro_t> IDR7;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001410, 0x00000001, 6, ro_t> IDR6;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001410, 0x00000001, 5, ro_t> IDR5;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001410, 0x00000001, 4, ro_t> IDR4;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001410, 0x00000001, 3, ro_t> IDR3;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001410, 0x00000001, 2, ro_t> IDR2;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001410, 0x00000001, 1, ro_t> IDR1;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001410, 0x00000001, 0, ro_t> IDR0;
        };
        /*
            GPIO port output data register
         */
        namespace ODR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001414, 0xffffffff, 0, rw_t> ODR_REG;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001414, 0x00000001, 15, rw_t> ODR15;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001414, 0x00000001, 14, rw_t> ODR14;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001414, 0x00000001, 13, rw_t> ODR13;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001414, 0x00000001, 12, rw_t> ODR12;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001414, 0x00000001, 11, rw_t> ODR11;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001414, 0x00000001, 10, rw_t> ODR10;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001414, 0x00000001, 9, rw_t> ODR9;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001414, 0x00000001, 8, rw_t> ODR8;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001414, 0x00000001, 7, rw_t> ODR7;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001414, 0x00000001, 6, rw_t> ODR6;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001414, 0x00000001, 5, rw_t> ODR5;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001414, 0x00000001, 4, rw_t> ODR4;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001414, 0x00000001, 3, rw_t> ODR3;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001414, 0x00000001, 2, rw_t> ODR2;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001414, 0x00000001, 1, rw_t> ODR1;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001414, 0x00000001, 0, rw_t> ODR0;
        };
        /*
            GPIO port bit set/reset
          register
         */
        namespace BSRR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001418, 0xffffffff, 0, wo_t> BSRR_REG;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 31, wo_t> BR15;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 30, wo_t> BR14;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 29, wo_t> BR13;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 28, wo_t> BR12;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 27, wo_t> BR11;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 26, wo_t> BR10;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 25, wo_t> BR9;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 24, wo_t> BR8;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 23, wo_t> BR7;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 22, wo_t> BR6;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 21, wo_t> BR5;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 20, wo_t> BR4;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 19, wo_t> BR3;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 18, wo_t> BR2;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 17, wo_t> BR1;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 16, wo_t> BR0;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 15, wo_t> BS15;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 14, wo_t> BS14;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 13, wo_t> BS13;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 12, wo_t> BS12;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 11, wo_t> BS11;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 10, wo_t> BS10;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 9, wo_t> BS9;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 8, wo_t> BS8;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 7, wo_t> BS7;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 6, wo_t> BS6;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 5, wo_t> BS5;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 4, wo_t> BS4;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 3, wo_t> BS3;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 2, wo_t> BS2;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 1, wo_t> BS1;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001418, 0x00000001, 0, wo_t> BS0;
        };
        /*
            GPIO port configuration lock
          register
         */
        namespace LCKR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4800141c, 0xffffffff, 0, rw_t> LCKR_REG;
            /*
                Lok Key
             */
            typedef reg_t<0x4800141c, 0x00000001, 16, rw_t> LCKK;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800141c, 0x00000001, 15, rw_t> LCK15;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800141c, 0x00000001, 14, rw_t> LCK14;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800141c, 0x00000001, 13, rw_t> LCK13;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800141c, 0x00000001, 12, rw_t> LCK12;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800141c, 0x00000001, 11, rw_t> LCK11;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800141c, 0x00000001, 10, rw_t> LCK10;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800141c, 0x00000001, 9, rw_t> LCK9;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800141c, 0x00000001, 8, rw_t> LCK8;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800141c, 0x00000001, 7, rw_t> LCK7;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800141c, 0x00000001, 6, rw_t> LCK6;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800141c, 0x00000001, 5, rw_t> LCK5;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800141c, 0x00000001, 4, rw_t> LCK4;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800141c, 0x00000001, 3, rw_t> LCK3;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800141c, 0x00000001, 2, rw_t> LCK2;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800141c, 0x00000001, 1, rw_t> LCK1;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800141c, 0x00000001, 0, rw_t> LCK0;
        };
        /*
            GPIO alternate function low
          register
         */
        namespace AFRL {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001420, 0xffffffff, 0, rw_t> AFRL_REG;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001420, 0x0000000f, 28, rw_t> AFRL7;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001420, 0x0000000f, 24, rw_t> AFRL6;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001420, 0x0000000f, 20, rw_t> AFRL5;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001420, 0x0000000f, 16, rw_t> AFRL4;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001420, 0x0000000f, 12, rw_t> AFRL3;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001420, 0x0000000f, 8, rw_t> AFRL2;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001420, 0x0000000f, 4, rw_t> AFRL1;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001420, 0x0000000f, 0, rw_t> AFRL0;
        };
        /*
            GPIO alternate function high
          register
         */
        namespace AFRH {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001424, 0xffffffff, 0, rw_t> AFRH_REG;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001424, 0x0000000f, 28, rw_t> AFRH15;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001424, 0x0000000f, 24, rw_t> AFRH14;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001424, 0x0000000f, 20, rw_t> AFRH13;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001424, 0x0000000f, 16, rw_t> AFRH12;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001424, 0x0000000f, 12, rw_t> AFRH11;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001424, 0x0000000f, 8, rw_t> AFRH10;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001424, 0x0000000f, 4, rw_t> AFRH9;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001424, 0x0000000f, 0, rw_t> AFRH8;
        };
        /*
            Port bit reset register
         */
        namespace BRR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001428, 0xffffffff, 0, wo_t> BRR_REG;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001428, 0x00000001, 0, wo_t> BR0;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001428, 0x00000001, 1, wo_t> BR1;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001428, 0x00000001, 2, wo_t> BR2;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001428, 0x00000001, 3, wo_t> BR3;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001428, 0x00000001, 4, wo_t> BR4;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001428, 0x00000001, 5, wo_t> BR5;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001428, 0x00000001, 6, wo_t> BR6;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001428, 0x00000001, 7, wo_t> BR7;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001428, 0x00000001, 8, wo_t> BR8;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001428, 0x00000001, 9, wo_t> BR9;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001428, 0x00000001, 10, wo_t> BR10;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001428, 0x00000001, 11, wo_t> BR11;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001428, 0x00000001, 12, wo_t> BR12;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001428, 0x00000001, 13, wo_t> BR13;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001428, 0x00000001, 14, wo_t> BR14;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001428, 0x00000001, 15, wo_t> BR15;
        };
    };
    /*
        General-purpose I/Os
     */
    namespace GPIOG {
        /*
            GPIO port mode register
         */
        namespace MODER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001800, 0xffffffff, 0, rw_t> MODER_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001800, 0x00000003, 30, rw_t> MODER15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001800, 0x00000003, 28, rw_t> MODER14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001800, 0x00000003, 26, rw_t> MODER13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001800, 0x00000003, 24, rw_t> MODER12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001800, 0x00000003, 22, rw_t> MODER11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001800, 0x00000003, 20, rw_t> MODER10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001800, 0x00000003, 18, rw_t> MODER9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001800, 0x00000003, 16, rw_t> MODER8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001800, 0x00000003, 14, rw_t> MODER7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001800, 0x00000003, 12, rw_t> MODER6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001800, 0x00000003, 10, rw_t> MODER5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001800, 0x00000003, 8, rw_t> MODER4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001800, 0x00000003, 6, rw_t> MODER3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001800, 0x00000003, 4, rw_t> MODER2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001800, 0x00000003, 2, rw_t> MODER1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001800, 0x00000003, 0, rw_t> MODER0;
        };
        /*
            GPIO port output type register
         */
        namespace OTYPER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001804, 0xffffffff, 0, rw_t> OTYPER_REG;
            /*
                Port x configuration bit
              15
             */
            typedef reg_t<0x48001804, 0x00000001, 15, rw_t> OT15;
            /*
                Port x configuration bit
              14
             */
            typedef reg_t<0x48001804, 0x00000001, 14, rw_t> OT14;
            /*
                Port x configuration bit
              13
             */
            typedef reg_t<0x48001804, 0x00000001, 13, rw_t> OT13;
            /*
                Port x configuration bit
              12
             */
            typedef reg_t<0x48001804, 0x00000001, 12, rw_t> OT12;
            /*
                Port x configuration bit
              11
             */
            typedef reg_t<0x48001804, 0x00000001, 11, rw_t> OT11;
            /*
                Port x configuration bit
              10
             */
            typedef reg_t<0x48001804, 0x00000001, 10, rw_t> OT10;
            /*
                Port x configuration bit 9
             */
            typedef reg_t<0x48001804, 0x00000001, 9, rw_t> OT9;
            /*
                Port x configuration bit 8
             */
            typedef reg_t<0x48001804, 0x00000001, 8, rw_t> OT8;
            /*
                Port x configuration bit 7
             */
            typedef reg_t<0x48001804, 0x00000001, 7, rw_t> OT7;
            /*
                Port x configuration bit 6
             */
            typedef reg_t<0x48001804, 0x00000001, 6, rw_t> OT6;
            /*
                Port x configuration bit 5
             */
            typedef reg_t<0x48001804, 0x00000001, 5, rw_t> OT5;
            /*
                Port x configuration bit 4
             */
            typedef reg_t<0x48001804, 0x00000001, 4, rw_t> OT4;
            /*
                Port x configuration bit 3
             */
            typedef reg_t<0x48001804, 0x00000001, 3, rw_t> OT3;
            /*
                Port x configuration bit 2
             */
            typedef reg_t<0x48001804, 0x00000001, 2, rw_t> OT2;
            /*
                Port x configuration bit 1
             */
            typedef reg_t<0x48001804, 0x00000001, 1, rw_t> OT1;
            /*
                Port x configuration bit 0
             */
            typedef reg_t<0x48001804, 0x00000001, 0, rw_t> OT0;
        };
        /*
            GPIO port output speed
          register
         */
        namespace OSPEEDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001808, 0xffffffff, 0, rw_t> OSPEEDR_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001808, 0x00000003, 30, rw_t> OSPEEDR15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001808, 0x00000003, 28, rw_t> OSPEEDR14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001808, 0x00000003, 26, rw_t> OSPEEDR13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001808, 0x00000003, 24, rw_t> OSPEEDR12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001808, 0x00000003, 22, rw_t> OSPEEDR11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001808, 0x00000003, 20, rw_t> OSPEEDR10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001808, 0x00000003, 18, rw_t> OSPEEDR9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001808, 0x00000003, 16, rw_t> OSPEEDR8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001808, 0x00000003, 14, rw_t> OSPEEDR7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001808, 0x00000003, 12, rw_t> OSPEEDR6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001808, 0x00000003, 10, rw_t> OSPEEDR5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001808, 0x00000003, 8, rw_t> OSPEEDR4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001808, 0x00000003, 6, rw_t> OSPEEDR3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001808, 0x00000003, 4, rw_t> OSPEEDR2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001808, 0x00000003, 2, rw_t> OSPEEDR1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001808, 0x00000003, 0, rw_t> OSPEEDR0;
        };
        /*
            GPIO port pull-up/pull-down
          register
         */
        namespace PUPDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4800180c, 0xffffffff, 0, rw_t> PUPDR_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800180c, 0x00000003, 30, rw_t> PUPDR15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800180c, 0x00000003, 28, rw_t> PUPDR14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800180c, 0x00000003, 26, rw_t> PUPDR13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800180c, 0x00000003, 24, rw_t> PUPDR12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800180c, 0x00000003, 22, rw_t> PUPDR11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800180c, 0x00000003, 20, rw_t> PUPDR10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800180c, 0x00000003, 18, rw_t> PUPDR9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800180c, 0x00000003, 16, rw_t> PUPDR8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800180c, 0x00000003, 14, rw_t> PUPDR7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800180c, 0x00000003, 12, rw_t> PUPDR6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800180c, 0x00000003, 10, rw_t> PUPDR5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800180c, 0x00000003, 8, rw_t> PUPDR4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800180c, 0x00000003, 6, rw_t> PUPDR3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800180c, 0x00000003, 4, rw_t> PUPDR2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800180c, 0x00000003, 2, rw_t> PUPDR1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x4800180c, 0x00000003, 0, rw_t> PUPDR0;
        };
        /*
            GPIO port input data register
         */
        namespace IDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001810, 0xffffffff, 0, ro_t> IDR_REG;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001810, 0x00000001, 15, ro_t> IDR15;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001810, 0x00000001, 14, ro_t> IDR14;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001810, 0x00000001, 13, ro_t> IDR13;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001810, 0x00000001, 12, ro_t> IDR12;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001810, 0x00000001, 11, ro_t> IDR11;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001810, 0x00000001, 10, ro_t> IDR10;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001810, 0x00000001, 9, ro_t> IDR9;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001810, 0x00000001, 8, ro_t> IDR8;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001810, 0x00000001, 7, ro_t> IDR7;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001810, 0x00000001, 6, ro_t> IDR6;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001810, 0x00000001, 5, ro_t> IDR5;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001810, 0x00000001, 4, ro_t> IDR4;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001810, 0x00000001, 3, ro_t> IDR3;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001810, 0x00000001, 2, ro_t> IDR2;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001810, 0x00000001, 1, ro_t> IDR1;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001810, 0x00000001, 0, ro_t> IDR0;
        };
        /*
            GPIO port output data register
         */
        namespace ODR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001814, 0xffffffff, 0, rw_t> ODR_REG;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001814, 0x00000001, 15, rw_t> ODR15;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001814, 0x00000001, 14, rw_t> ODR14;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001814, 0x00000001, 13, rw_t> ODR13;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001814, 0x00000001, 12, rw_t> ODR12;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001814, 0x00000001, 11, rw_t> ODR11;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001814, 0x00000001, 10, rw_t> ODR10;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001814, 0x00000001, 9, rw_t> ODR9;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001814, 0x00000001, 8, rw_t> ODR8;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001814, 0x00000001, 7, rw_t> ODR7;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001814, 0x00000001, 6, rw_t> ODR6;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001814, 0x00000001, 5, rw_t> ODR5;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001814, 0x00000001, 4, rw_t> ODR4;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001814, 0x00000001, 3, rw_t> ODR3;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001814, 0x00000001, 2, rw_t> ODR2;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001814, 0x00000001, 1, rw_t> ODR1;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001814, 0x00000001, 0, rw_t> ODR0;
        };
        /*
            GPIO port bit set/reset
          register
         */
        namespace BSRR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001818, 0xffffffff, 0, wo_t> BSRR_REG;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 31, wo_t> BR15;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 30, wo_t> BR14;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 29, wo_t> BR13;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 28, wo_t> BR12;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 27, wo_t> BR11;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 26, wo_t> BR10;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 25, wo_t> BR9;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 24, wo_t> BR8;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 23, wo_t> BR7;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 22, wo_t> BR6;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 21, wo_t> BR5;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 20, wo_t> BR4;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 19, wo_t> BR3;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 18, wo_t> BR2;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 17, wo_t> BR1;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 16, wo_t> BR0;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 15, wo_t> BS15;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 14, wo_t> BS14;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 13, wo_t> BS13;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 12, wo_t> BS12;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 11, wo_t> BS11;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 10, wo_t> BS10;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 9, wo_t> BS9;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 8, wo_t> BS8;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 7, wo_t> BS7;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 6, wo_t> BS6;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 5, wo_t> BS5;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 4, wo_t> BS4;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 3, wo_t> BS3;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 2, wo_t> BS2;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 1, wo_t> BS1;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001818, 0x00000001, 0, wo_t> BS0;
        };
        /*
            GPIO port configuration lock
          register
         */
        namespace LCKR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4800181c, 0xffffffff, 0, rw_t> LCKR_REG;
            /*
                Lok Key
             */
            typedef reg_t<0x4800181c, 0x00000001, 16, rw_t> LCKK;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800181c, 0x00000001, 15, rw_t> LCK15;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800181c, 0x00000001, 14, rw_t> LCK14;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800181c, 0x00000001, 13, rw_t> LCK13;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800181c, 0x00000001, 12, rw_t> LCK12;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800181c, 0x00000001, 11, rw_t> LCK11;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800181c, 0x00000001, 10, rw_t> LCK10;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800181c, 0x00000001, 9, rw_t> LCK9;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800181c, 0x00000001, 8, rw_t> LCK8;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800181c, 0x00000001, 7, rw_t> LCK7;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800181c, 0x00000001, 6, rw_t> LCK6;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800181c, 0x00000001, 5, rw_t> LCK5;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800181c, 0x00000001, 4, rw_t> LCK4;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800181c, 0x00000001, 3, rw_t> LCK3;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800181c, 0x00000001, 2, rw_t> LCK2;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800181c, 0x00000001, 1, rw_t> LCK1;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x4800181c, 0x00000001, 0, rw_t> LCK0;
        };
        /*
            GPIO alternate function low
          register
         */
        namespace AFRL {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001820, 0xffffffff, 0, rw_t> AFRL_REG;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001820, 0x0000000f, 28, rw_t> AFRL7;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001820, 0x0000000f, 24, rw_t> AFRL6;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001820, 0x0000000f, 20, rw_t> AFRL5;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001820, 0x0000000f, 16, rw_t> AFRL4;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001820, 0x0000000f, 12, rw_t> AFRL3;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001820, 0x0000000f, 8, rw_t> AFRL2;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001820, 0x0000000f, 4, rw_t> AFRL1;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001820, 0x0000000f, 0, rw_t> AFRL0;
        };
        /*
            GPIO alternate function high
          register
         */
        namespace AFRH {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001824, 0xffffffff, 0, rw_t> AFRH_REG;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001824, 0x0000000f, 28, rw_t> AFRH15;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001824, 0x0000000f, 24, rw_t> AFRH14;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001824, 0x0000000f, 20, rw_t> AFRH13;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001824, 0x0000000f, 16, rw_t> AFRH12;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001824, 0x0000000f, 12, rw_t> AFRH11;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001824, 0x0000000f, 8, rw_t> AFRH10;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001824, 0x0000000f, 4, rw_t> AFRH9;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001824, 0x0000000f, 0, rw_t> AFRH8;
        };
        /*
            Port bit reset register
         */
        namespace BRR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001828, 0xffffffff, 0, wo_t> BRR_REG;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001828, 0x00000001, 0, wo_t> BR0;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001828, 0x00000001, 1, wo_t> BR1;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001828, 0x00000001, 2, wo_t> BR2;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001828, 0x00000001, 3, wo_t> BR3;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001828, 0x00000001, 4, wo_t> BR4;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001828, 0x00000001, 5, wo_t> BR5;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001828, 0x00000001, 6, wo_t> BR6;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001828, 0x00000001, 7, wo_t> BR7;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001828, 0x00000001, 8, wo_t> BR8;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001828, 0x00000001, 9, wo_t> BR9;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001828, 0x00000001, 10, wo_t> BR10;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001828, 0x00000001, 11, wo_t> BR11;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001828, 0x00000001, 12, wo_t> BR12;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001828, 0x00000001, 13, wo_t> BR13;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001828, 0x00000001, 14, wo_t> BR14;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001828, 0x00000001, 15, wo_t> BR15;
        };
    };
    /*
        General-purpose I/Os
     */
    namespace GPIOH {
        /*
            GPIO port mode register
         */
        namespace MODER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001c00, 0xffffffff, 0, rw_t> MODER_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c00, 0x00000003, 30, rw_t> MODER15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c00, 0x00000003, 28, rw_t> MODER14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c00, 0x00000003, 26, rw_t> MODER13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c00, 0x00000003, 24, rw_t> MODER12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c00, 0x00000003, 22, rw_t> MODER11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c00, 0x00000003, 20, rw_t> MODER10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c00, 0x00000003, 18, rw_t> MODER9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c00, 0x00000003, 16, rw_t> MODER8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c00, 0x00000003, 14, rw_t> MODER7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c00, 0x00000003, 12, rw_t> MODER6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c00, 0x00000003, 10, rw_t> MODER5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c00, 0x00000003, 8, rw_t> MODER4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c00, 0x00000003, 6, rw_t> MODER3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c00, 0x00000003, 4, rw_t> MODER2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c00, 0x00000003, 2, rw_t> MODER1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c00, 0x00000003, 0, rw_t> MODER0;
        };
        /*
            GPIO port output type register
         */
        namespace OTYPER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001c04, 0xffffffff, 0, rw_t> OTYPER_REG;
            /*
                Port x configuration bit
              15
             */
            typedef reg_t<0x48001c04, 0x00000001, 15, rw_t> OT15;
            /*
                Port x configuration bit
              14
             */
            typedef reg_t<0x48001c04, 0x00000001, 14, rw_t> OT14;
            /*
                Port x configuration bit
              13
             */
            typedef reg_t<0x48001c04, 0x00000001, 13, rw_t> OT13;
            /*
                Port x configuration bit
              12
             */
            typedef reg_t<0x48001c04, 0x00000001, 12, rw_t> OT12;
            /*
                Port x configuration bit
              11
             */
            typedef reg_t<0x48001c04, 0x00000001, 11, rw_t> OT11;
            /*
                Port x configuration bit
              10
             */
            typedef reg_t<0x48001c04, 0x00000001, 10, rw_t> OT10;
            /*
                Port x configuration bit 9
             */
            typedef reg_t<0x48001c04, 0x00000001, 9, rw_t> OT9;
            /*
                Port x configuration bit 8
             */
            typedef reg_t<0x48001c04, 0x00000001, 8, rw_t> OT8;
            /*
                Port x configuration bit 7
             */
            typedef reg_t<0x48001c04, 0x00000001, 7, rw_t> OT7;
            /*
                Port x configuration bit 6
             */
            typedef reg_t<0x48001c04, 0x00000001, 6, rw_t> OT6;
            /*
                Port x configuration bit 5
             */
            typedef reg_t<0x48001c04, 0x00000001, 5, rw_t> OT5;
            /*
                Port x configuration bit 4
             */
            typedef reg_t<0x48001c04, 0x00000001, 4, rw_t> OT4;
            /*
                Port x configuration bit 3
             */
            typedef reg_t<0x48001c04, 0x00000001, 3, rw_t> OT3;
            /*
                Port x configuration bit 2
             */
            typedef reg_t<0x48001c04, 0x00000001, 2, rw_t> OT2;
            /*
                Port x configuration bit 1
             */
            typedef reg_t<0x48001c04, 0x00000001, 1, rw_t> OT1;
            /*
                Port x configuration bit 0
             */
            typedef reg_t<0x48001c04, 0x00000001, 0, rw_t> OT0;
        };
        /*
            GPIO port output speed
          register
         */
        namespace OSPEEDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001c08, 0xffffffff, 0, rw_t> OSPEEDR_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c08, 0x00000003, 30, rw_t> OSPEEDR15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c08, 0x00000003, 28, rw_t> OSPEEDR14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c08, 0x00000003, 26, rw_t> OSPEEDR13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c08, 0x00000003, 24, rw_t> OSPEEDR12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c08, 0x00000003, 22, rw_t> OSPEEDR11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c08, 0x00000003, 20, rw_t> OSPEEDR10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c08, 0x00000003, 18, rw_t> OSPEEDR9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c08, 0x00000003, 16, rw_t> OSPEEDR8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c08, 0x00000003, 14, rw_t> OSPEEDR7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c08, 0x00000003, 12, rw_t> OSPEEDR6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c08, 0x00000003, 10, rw_t> OSPEEDR5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c08, 0x00000003, 8, rw_t> OSPEEDR4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c08, 0x00000003, 6, rw_t> OSPEEDR3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c08, 0x00000003, 4, rw_t> OSPEEDR2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c08, 0x00000003, 2, rw_t> OSPEEDR1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c08, 0x00000003, 0, rw_t> OSPEEDR0;
        };
        /*
            GPIO port pull-up/pull-down
          register
         */
        namespace PUPDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001c0c, 0xffffffff, 0, rw_t> PUPDR_REG;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c0c, 0x00000003, 30, rw_t> PUPDR15;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c0c, 0x00000003, 28, rw_t> PUPDR14;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c0c, 0x00000003, 26, rw_t> PUPDR13;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c0c, 0x00000003, 24, rw_t> PUPDR12;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c0c, 0x00000003, 22, rw_t> PUPDR11;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c0c, 0x00000003, 20, rw_t> PUPDR10;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c0c, 0x00000003, 18, rw_t> PUPDR9;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c0c, 0x00000003, 16, rw_t> PUPDR8;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c0c, 0x00000003, 14, rw_t> PUPDR7;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c0c, 0x00000003, 12, rw_t> PUPDR6;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c0c, 0x00000003, 10, rw_t> PUPDR5;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c0c, 0x00000003, 8, rw_t> PUPDR4;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c0c, 0x00000003, 6, rw_t> PUPDR3;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c0c, 0x00000003, 4, rw_t> PUPDR2;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c0c, 0x00000003, 2, rw_t> PUPDR1;
            /*
                Port x configuration bits (y =
              0..15)
             */
            typedef reg_t<0x48001c0c, 0x00000003, 0, rw_t> PUPDR0;
        };
        /*
            GPIO port input data register
         */
        namespace IDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001c10, 0xffffffff, 0, ro_t> IDR_REG;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001c10, 0x00000001, 15, ro_t> IDR15;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001c10, 0x00000001, 14, ro_t> IDR14;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001c10, 0x00000001, 13, ro_t> IDR13;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001c10, 0x00000001, 12, ro_t> IDR12;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001c10, 0x00000001, 11, ro_t> IDR11;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001c10, 0x00000001, 10, ro_t> IDR10;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001c10, 0x00000001, 9, ro_t> IDR9;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001c10, 0x00000001, 8, ro_t> IDR8;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001c10, 0x00000001, 7, ro_t> IDR7;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001c10, 0x00000001, 6, ro_t> IDR6;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001c10, 0x00000001, 5, ro_t> IDR5;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001c10, 0x00000001, 4, ro_t> IDR4;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001c10, 0x00000001, 3, ro_t> IDR3;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001c10, 0x00000001, 2, ro_t> IDR2;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001c10, 0x00000001, 1, ro_t> IDR1;
            /*
                Port input data (y =
              0..15)
             */
            typedef reg_t<0x48001c10, 0x00000001, 0, ro_t> IDR0;
        };
        /*
            GPIO port output data register
         */
        namespace ODR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001c14, 0xffffffff, 0, rw_t> ODR_REG;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001c14, 0x00000001, 15, rw_t> ODR15;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001c14, 0x00000001, 14, rw_t> ODR14;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001c14, 0x00000001, 13, rw_t> ODR13;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001c14, 0x00000001, 12, rw_t> ODR12;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001c14, 0x00000001, 11, rw_t> ODR11;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001c14, 0x00000001, 10, rw_t> ODR10;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001c14, 0x00000001, 9, rw_t> ODR9;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001c14, 0x00000001, 8, rw_t> ODR8;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001c14, 0x00000001, 7, rw_t> ODR7;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001c14, 0x00000001, 6, rw_t> ODR6;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001c14, 0x00000001, 5, rw_t> ODR5;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001c14, 0x00000001, 4, rw_t> ODR4;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001c14, 0x00000001, 3, rw_t> ODR3;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001c14, 0x00000001, 2, rw_t> ODR2;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001c14, 0x00000001, 1, rw_t> ODR1;
            /*
                Port output data (y =
              0..15)
             */
            typedef reg_t<0x48001c14, 0x00000001, 0, rw_t> ODR0;
        };
        /*
            GPIO port bit set/reset
          register
         */
        namespace BSRR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001c18, 0xffffffff, 0, wo_t> BSRR_REG;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 31, wo_t> BR15;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 30, wo_t> BR14;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 29, wo_t> BR13;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 28, wo_t> BR12;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 27, wo_t> BR11;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 26, wo_t> BR10;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 25, wo_t> BR9;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 24, wo_t> BR8;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 23, wo_t> BR7;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 22, wo_t> BR6;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 21, wo_t> BR5;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 20, wo_t> BR4;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 19, wo_t> BR3;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 18, wo_t> BR2;
            /*
                Port x reset bit y (y =
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 17, wo_t> BR1;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 16, wo_t> BR0;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 15, wo_t> BS15;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 14, wo_t> BS14;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 13, wo_t> BS13;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 12, wo_t> BS12;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 11, wo_t> BS11;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 10, wo_t> BS10;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 9, wo_t> BS9;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 8, wo_t> BS8;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 7, wo_t> BS7;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 6, wo_t> BS6;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 5, wo_t> BS5;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 4, wo_t> BS4;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 3, wo_t> BS3;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 2, wo_t> BS2;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 1, wo_t> BS1;
            /*
                Port x set bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c18, 0x00000001, 0, wo_t> BS0;
        };
        /*
            GPIO port configuration lock
          register
         */
        namespace LCKR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001c1c, 0xffffffff, 0, rw_t> LCKR_REG;
            /*
                Lok Key
             */
            typedef reg_t<0x48001c1c, 0x00000001, 16, rw_t> LCKK;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c1c, 0x00000001, 15, rw_t> LCK15;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c1c, 0x00000001, 14, rw_t> LCK14;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c1c, 0x00000001, 13, rw_t> LCK13;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c1c, 0x00000001, 12, rw_t> LCK12;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c1c, 0x00000001, 11, rw_t> LCK11;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c1c, 0x00000001, 10, rw_t> LCK10;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c1c, 0x00000001, 9, rw_t> LCK9;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c1c, 0x00000001, 8, rw_t> LCK8;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c1c, 0x00000001, 7, rw_t> LCK7;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c1c, 0x00000001, 6, rw_t> LCK6;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c1c, 0x00000001, 5, rw_t> LCK5;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c1c, 0x00000001, 4, rw_t> LCK4;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c1c, 0x00000001, 3, rw_t> LCK3;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c1c, 0x00000001, 2, rw_t> LCK2;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c1c, 0x00000001, 1, rw_t> LCK1;
            /*
                Port x lock bit y (y=
              0..15)
             */
            typedef reg_t<0x48001c1c, 0x00000001, 0, rw_t> LCK0;
        };
        /*
            GPIO alternate function low
          register
         */
        namespace AFRL {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001c20, 0xffffffff, 0, rw_t> AFRL_REG;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001c20, 0x0000000f, 28, rw_t> AFRL7;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001c20, 0x0000000f, 24, rw_t> AFRL6;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001c20, 0x0000000f, 20, rw_t> AFRL5;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001c20, 0x0000000f, 16, rw_t> AFRL4;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001c20, 0x0000000f, 12, rw_t> AFRL3;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001c20, 0x0000000f, 8, rw_t> AFRL2;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001c20, 0x0000000f, 4, rw_t> AFRL1;
            /*
                Alternate function selection for port x
              bit y (y = 0..7)
             */
            typedef reg_t<0x48001c20, 0x0000000f, 0, rw_t> AFRL0;
        };
        /*
            GPIO alternate function high
          register
         */
        namespace AFRH {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001c24, 0xffffffff, 0, rw_t> AFRH_REG;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001c24, 0x0000000f, 28, rw_t> AFRH15;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001c24, 0x0000000f, 24, rw_t> AFRH14;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001c24, 0x0000000f, 20, rw_t> AFRH13;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001c24, 0x0000000f, 16, rw_t> AFRH12;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001c24, 0x0000000f, 12, rw_t> AFRH11;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001c24, 0x0000000f, 8, rw_t> AFRH10;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001c24, 0x0000000f, 4, rw_t> AFRH9;
            /*
                Alternate function selection for port x
              bit y (y = 8..15)
             */
            typedef reg_t<0x48001c24, 0x0000000f, 0, rw_t> AFRH8;
        };
        /*
            Port bit reset register
         */
        namespace BRR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x48001c28, 0xffffffff, 0, wo_t> BRR_REG;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001c28, 0x00000001, 0, wo_t> BR0;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001c28, 0x00000001, 1, wo_t> BR1;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001c28, 0x00000001, 2, wo_t> BR2;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001c28, 0x00000001, 3, wo_t> BR3;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001c28, 0x00000001, 4, wo_t> BR4;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001c28, 0x00000001, 5, wo_t> BR5;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001c28, 0x00000001, 6, wo_t> BR6;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001c28, 0x00000001, 7, wo_t> BR7;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001c28, 0x00000001, 8, wo_t> BR8;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001c28, 0x00000001, 9, wo_t> BR9;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001c28, 0x00000001, 10, wo_t> BR10;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001c28, 0x00000001, 11, wo_t> BR11;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001c28, 0x00000001, 12, wo_t> BR12;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001c28, 0x00000001, 13, wo_t> BR13;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001c28, 0x00000001, 14, wo_t> BR14;
            /*
                Port x Reset bit y
             */
            typedef reg_t<0x48001c28, 0x00000001, 15, wo_t> BR15;
        };
    };
    /*
        Touch sensing controller
     */
    namespace TSC {
        /*
            control register
         */
        namespace CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40024000, 0xffffffff, 0, rw_t> CR_REG;
            /*
                Charge transfer pulse high
             */
            typedef reg_t<0x40024000, 0x0000000f, 28, rw_t> CTPH;
            /*
                Charge transfer pulse low
             */
            typedef reg_t<0x40024000, 0x0000000f, 24, rw_t> CTPL;
            /*
                Spread spectrum deviation
             */
            typedef reg_t<0x40024000, 0x0000007f, 17, rw_t> SSD;
            /*
                Spread spectrum enable
             */
            typedef reg_t<0x40024000, 0x00000001, 16, rw_t> SSE;
            /*
                Spread spectrum prescaler
             */
            typedef reg_t<0x40024000, 0x00000001, 15, rw_t> SSPSC;
            /*
                pulse generator prescaler
             */
            typedef reg_t<0x40024000, 0x00000007, 12, rw_t> PGPSC;
            /*
                Max count value
             */
            typedef reg_t<0x40024000, 0x00000007, 5, rw_t> MCV;
            /*
                I/O Default mode
             */
            typedef reg_t<0x40024000, 0x00000001, 4, rw_t> IODEF;
            /*
                Synchronization pin
              polarity
             */
            typedef reg_t<0x40024000, 0x00000001, 3, rw_t> SYNCPOL;
            /*
                Acquisition mode
             */
            typedef reg_t<0x40024000, 0x00000001, 2, rw_t> AM;
            /*
                Start a new acquisition
             */
            typedef reg_t<0x40024000, 0x00000001, 1, rw_t> START;
            /*
                Touch sensing controller
              enable
             */
            typedef reg_t<0x40024000, 0x00000001, 0, rw_t> TSCE;
        };
        /*
            interrupt enable register
         */
        namespace IER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40024004, 0xffffffff, 0, rw_t> IER_REG;
            /*
                Max count error interrupt
              enable
             */
            typedef reg_t<0x40024004, 0x00000001, 1, rw_t> MCEIE;
            /*
                End of acquisition interrupt
              enable
             */
            typedef reg_t<0x40024004, 0x00000001, 0, rw_t> EOAIE;
        };
        /*
            interrupt clear register
         */
        namespace ICR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40024008, 0xffffffff, 0, rw_t> ICR_REG;
            /*
                Max count error interrupt
              clear
             */
            typedef reg_t<0x40024008, 0x00000001, 1, rw_t> MCEIC;
            /*
                End of acquisition interrupt
              clear
             */
            typedef reg_t<0x40024008, 0x00000001, 0, rw_t> EOAIC;
        };
        /*
            interrupt status register
         */
        namespace ISR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4002400c, 0xffffffff, 0, rw_t> ISR_REG;
            /*
                Max count error flag
             */
            typedef reg_t<0x4002400c, 0x00000001, 1, rw_t> MCEF;
            /*
                End of acquisition flag
             */
            typedef reg_t<0x4002400c, 0x00000001, 0, rw_t> EOAF;
        };
        /*
            I/O hysteresis control
          register
         */
        namespace IOHCR {

            static constexpr uint32_t RESETVALUE = 0xffffffff;
            typedef reg_t<0x40024010, 0xffffffff, 0, rw_t> IOHCR_REG;
            /*
                G1_IO1 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 0, rw_t> G1_IO1;
            /*
                G1_IO2 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 1, rw_t> G1_IO2;
            /*
                G1_IO3 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 2, rw_t> G1_IO3;
            /*
                G1_IO4 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 3, rw_t> G1_IO4;
            /*
                G2_IO1 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 4, rw_t> G2_IO1;
            /*
                G2_IO2 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 5, rw_t> G2_IO2;
            /*
                G2_IO3 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 6, rw_t> G2_IO3;
            /*
                G2_IO4 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 7, rw_t> G2_IO4;
            /*
                G3_IO1 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 8, rw_t> G3_IO1;
            /*
                G3_IO2 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 9, rw_t> G3_IO2;
            /*
                G3_IO3 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 10, rw_t> G3_IO3;
            /*
                G3_IO4 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 11, rw_t> G3_IO4;
            /*
                G4_IO1 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 12, rw_t> G4_IO1;
            /*
                G4_IO2 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 13, rw_t> G4_IO2;
            /*
                G4_IO3 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 14, rw_t> G4_IO3;
            /*
                G4_IO4 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 15, rw_t> G4_IO4;
            /*
                G5_IO1 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 16, rw_t> G5_IO1;
            /*
                G5_IO2 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 17, rw_t> G5_IO2;
            /*
                G5_IO3 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 18, rw_t> G5_IO3;
            /*
                G5_IO4 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 19, rw_t> G5_IO4;
            /*
                G6_IO1 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 20, rw_t> G6_IO1;
            /*
                G6_IO2 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 21, rw_t> G6_IO2;
            /*
                G6_IO3 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 22, rw_t> G6_IO3;
            /*
                G6_IO4 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 23, rw_t> G6_IO4;
            /*
                G7_IO1 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 24, rw_t> G7_IO1;
            /*
                G7_IO2 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 25, rw_t> G7_IO2;
            /*
                G7_IO3 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 26, rw_t> G7_IO3;
            /*
                G7_IO4 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 27, rw_t> G7_IO4;
            /*
                G8_IO1 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 28, rw_t> G8_IO1;
            /*
                G8_IO2 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 29, rw_t> G8_IO2;
            /*
                G8_IO3 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 30, rw_t> G8_IO3;
            /*
                G8_IO4 Schmitt trigger hysteresis
              mode
             */
            typedef reg_t<0x40024010, 0x00000001, 31, rw_t> G8_IO4;
        };
        /*
            I/O analog switch control
          register
         */
        namespace IOASCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40024018, 0xffffffff, 0, rw_t> IOASCR_REG;
            /*
                G1_IO1 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 0, rw_t> G1_IO1;
            /*
                G1_IO2 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 1, rw_t> G1_IO2;
            /*
                G1_IO3 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 2, rw_t> G1_IO3;
            /*
                G1_IO4 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 3, rw_t> G1_IO4;
            /*
                G2_IO1 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 4, rw_t> G2_IO1;
            /*
                G2_IO2 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 5, rw_t> G2_IO2;
            /*
                G2_IO3 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 6, rw_t> G2_IO3;
            /*
                G2_IO4 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 7, rw_t> G2_IO4;
            /*
                G3_IO1 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 8, rw_t> G3_IO1;
            /*
                G3_IO2 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 9, rw_t> G3_IO2;
            /*
                G3_IO3 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 10, rw_t> G3_IO3;
            /*
                G3_IO4 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 11, rw_t> G3_IO4;
            /*
                G4_IO1 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 12, rw_t> G4_IO1;
            /*
                G4_IO2 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 13, rw_t> G4_IO2;
            /*
                G4_IO3 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 14, rw_t> G4_IO3;
            /*
                G4_IO4 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 15, rw_t> G4_IO4;
            /*
                G5_IO1 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 16, rw_t> G5_IO1;
            /*
                G5_IO2 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 17, rw_t> G5_IO2;
            /*
                G5_IO3 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 18, rw_t> G5_IO3;
            /*
                G5_IO4 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 19, rw_t> G5_IO4;
            /*
                G6_IO1 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 20, rw_t> G6_IO1;
            /*
                G6_IO2 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 21, rw_t> G6_IO2;
            /*
                G6_IO3 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 22, rw_t> G6_IO3;
            /*
                G6_IO4 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 23, rw_t> G6_IO4;
            /*
                G7_IO1 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 24, rw_t> G7_IO1;
            /*
                G7_IO2 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 25, rw_t> G7_IO2;
            /*
                G7_IO3 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 26, rw_t> G7_IO3;
            /*
                G7_IO4 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 27, rw_t> G7_IO4;
            /*
                G8_IO1 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 28, rw_t> G8_IO1;
            /*
                G8_IO2 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 29, rw_t> G8_IO2;
            /*
                G8_IO3 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 30, rw_t> G8_IO3;
            /*
                G8_IO4 analog switch
              enable
             */
            typedef reg_t<0x40024018, 0x00000001, 31, rw_t> G8_IO4;
        };
        /*
            I/O sampling control register
         */
        namespace IOSCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40024020, 0xffffffff, 0, rw_t> IOSCR_REG;
            /*
                G1_IO1 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 0, rw_t> G1_IO1;
            /*
                G1_IO2 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 1, rw_t> G1_IO2;
            /*
                G1_IO3 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 2, rw_t> G1_IO3;
            /*
                G1_IO4 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 3, rw_t> G1_IO4;
            /*
                G2_IO1 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 4, rw_t> G2_IO1;
            /*
                G2_IO2 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 5, rw_t> G2_IO2;
            /*
                G2_IO3 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 6, rw_t> G2_IO3;
            /*
                G2_IO4 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 7, rw_t> G2_IO4;
            /*
                G3_IO1 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 8, rw_t> G3_IO1;
            /*
                G3_IO2 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 9, rw_t> G3_IO2;
            /*
                G3_IO3 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 10, rw_t> G3_IO3;
            /*
                G3_IO4 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 11, rw_t> G3_IO4;
            /*
                G4_IO1 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 12, rw_t> G4_IO1;
            /*
                G4_IO2 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 13, rw_t> G4_IO2;
            /*
                G4_IO3 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 14, rw_t> G4_IO3;
            /*
                G4_IO4 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 15, rw_t> G4_IO4;
            /*
                G5_IO1 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 16, rw_t> G5_IO1;
            /*
                G5_IO2 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 17, rw_t> G5_IO2;
            /*
                G5_IO3 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 18, rw_t> G5_IO3;
            /*
                G5_IO4 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 19, rw_t> G5_IO4;
            /*
                G6_IO1 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 20, rw_t> G6_IO1;
            /*
                G6_IO2 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 21, rw_t> G6_IO2;
            /*
                G6_IO3 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 22, rw_t> G6_IO3;
            /*
                G6_IO4 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 23, rw_t> G6_IO4;
            /*
                G7_IO1 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 24, rw_t> G7_IO1;
            /*
                G7_IO2 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 25, rw_t> G7_IO2;
            /*
                G7_IO3 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 26, rw_t> G7_IO3;
            /*
                G7_IO4 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 27, rw_t> G7_IO4;
            /*
                G8_IO1 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 28, rw_t> G8_IO1;
            /*
                G8_IO2 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 29, rw_t> G8_IO2;
            /*
                G8_IO3 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 30, rw_t> G8_IO3;
            /*
                G8_IO4 sampling mode
             */
            typedef reg_t<0x40024020, 0x00000001, 31, rw_t> G8_IO4;
        };
        /*
            I/O channel control register
         */
        namespace IOCCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40024028, 0xffffffff, 0, rw_t> IOCCR_REG;
            /*
                G1_IO1 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 0, rw_t> G1_IO1;
            /*
                G1_IO2 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 1, rw_t> G1_IO2;
            /*
                G1_IO3 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 2, rw_t> G1_IO3;
            /*
                G1_IO4 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 3, rw_t> G1_IO4;
            /*
                G2_IO1 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 4, rw_t> G2_IO1;
            /*
                G2_IO2 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 5, rw_t> G2_IO2;
            /*
                G2_IO3 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 6, rw_t> G2_IO3;
            /*
                G2_IO4 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 7, rw_t> G2_IO4;
            /*
                G3_IO1 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 8, rw_t> G3_IO1;
            /*
                G3_IO2 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 9, rw_t> G3_IO2;
            /*
                G3_IO3 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 10, rw_t> G3_IO3;
            /*
                G3_IO4 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 11, rw_t> G3_IO4;
            /*
                G4_IO1 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 12, rw_t> G4_IO1;
            /*
                G4_IO2 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 13, rw_t> G4_IO2;
            /*
                G4_IO3 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 14, rw_t> G4_IO3;
            /*
                G4_IO4 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 15, rw_t> G4_IO4;
            /*
                G5_IO1 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 16, rw_t> G5_IO1;
            /*
                G5_IO2 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 17, rw_t> G5_IO2;
            /*
                G5_IO3 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 18, rw_t> G5_IO3;
            /*
                G5_IO4 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 19, rw_t> G5_IO4;
            /*
                G6_IO1 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 20, rw_t> G6_IO1;
            /*
                G6_IO2 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 21, rw_t> G6_IO2;
            /*
                G6_IO3 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 22, rw_t> G6_IO3;
            /*
                G6_IO4 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 23, rw_t> G6_IO4;
            /*
                G7_IO1 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 24, rw_t> G7_IO1;
            /*
                G7_IO2 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 25, rw_t> G7_IO2;
            /*
                G7_IO3 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 26, rw_t> G7_IO3;
            /*
                G7_IO4 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 27, rw_t> G7_IO4;
            /*
                G8_IO1 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 28, rw_t> G8_IO1;
            /*
                G8_IO2 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 29, rw_t> G8_IO2;
            /*
                G8_IO3 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 30, rw_t> G8_IO3;
            /*
                G8_IO4 channel mode
             */
            typedef reg_t<0x40024028, 0x00000001, 31, rw_t> G8_IO4;
        };
        /*
            I/O group control status
          register
         */
        namespace IOGCSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Analog I/O group x status
             */
            typedef reg_t<0x40024030, 0x00000001, 23, rw_t> G8S;
            /*
                Analog I/O group x status
             */
            typedef reg_t<0x40024030, 0x00000001, 22, rw_t> G7S;
            /*
                Analog I/O group x status
             */
            typedef reg_t<0x40024030, 0x00000001, 21, ro_t> G6S;
            /*
                Analog I/O group x status
             */
            typedef reg_t<0x40024030, 0x00000001, 20, ro_t> G5S;
            /*
                Analog I/O group x status
             */
            typedef reg_t<0x40024030, 0x00000001, 19, ro_t> G4S;
            /*
                Analog I/O group x status
             */
            typedef reg_t<0x40024030, 0x00000001, 18, ro_t> G3S;
            /*
                Analog I/O group x status
             */
            typedef reg_t<0x40024030, 0x00000001, 17, ro_t> G2S;
            /*
                Analog I/O group x status
             */
            typedef reg_t<0x40024030, 0x00000001, 16, ro_t> G1S;
            /*
                Analog I/O group x enable
             */
            typedef reg_t<0x40024030, 0x00000001, 7, rw_t> G8E;
            /*
                Analog I/O group x enable
             */
            typedef reg_t<0x40024030, 0x00000001, 6, rw_t> G7E;
            /*
                Analog I/O group x enable
             */
            typedef reg_t<0x40024030, 0x00000001, 5, rw_t> G6E;
            /*
                Analog I/O group x enable
             */
            typedef reg_t<0x40024030, 0x00000001, 4, rw_t> G5E;
            /*
                Analog I/O group x enable
             */
            typedef reg_t<0x40024030, 0x00000001, 3, rw_t> G4E;
            /*
                Analog I/O group x enable
             */
            typedef reg_t<0x40024030, 0x00000001, 2, rw_t> G3E;
            /*
                Analog I/O group x enable
             */
            typedef reg_t<0x40024030, 0x00000001, 1, rw_t> G2E;
            /*
                Analog I/O group x enable
             */
            typedef reg_t<0x40024030, 0x00000001, 0, rw_t> G1E;
        };
        /*
            I/O group x counter register
         */
        namespace IOG1CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40024034, 0xffffffff, 0, ro_t> IOG1CR_REG;
            /*
                Counter value
             */
            typedef reg_t<0x40024034, 0x00003fff, 0, ro_t> CNT;
        };
        /*
            I/O group x counter register
         */
        namespace IOG2CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40024038, 0xffffffff, 0, ro_t> IOG2CR_REG;
            /*
                Counter value
             */
            typedef reg_t<0x40024038, 0x00003fff, 0, ro_t> CNT;
        };
        /*
            I/O group x counter register
         */
        namespace IOG3CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4002403c, 0xffffffff, 0, ro_t> IOG3CR_REG;
            /*
                Counter value
             */
            typedef reg_t<0x4002403c, 0x00003fff, 0, ro_t> CNT;
        };
        /*
            I/O group x counter register
         */
        namespace IOG4CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40024040, 0xffffffff, 0, ro_t> IOG4CR_REG;
            /*
                Counter value
             */
            typedef reg_t<0x40024040, 0x00003fff, 0, ro_t> CNT;
        };
        /*
            I/O group x counter register
         */
        namespace IOG5CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40024044, 0xffffffff, 0, ro_t> IOG5CR_REG;
            /*
                Counter value
             */
            typedef reg_t<0x40024044, 0x00003fff, 0, ro_t> CNT;
        };
        /*
            I/O group x counter register
         */
        namespace IOG6CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40024048, 0xffffffff, 0, ro_t> IOG6CR_REG;
            /*
                Counter value
             */
            typedef reg_t<0x40024048, 0x00003fff, 0, ro_t> CNT;
        };
        /*
            I/O group x counter register
         */
        namespace IOG7CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4002404c, 0xffffffff, 0, ro_t> IOG7CR_REG;
            /*
                Counter value
             */
            typedef reg_t<0x4002404c, 0x00003fff, 0, ro_t> CNT;
        };
        /*
            I/O group x counter register
         */
        namespace IOG8CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40024050, 0xffffffff, 0, ro_t> IOG8CR_REG;
            /*
                Counter value
             */
            typedef reg_t<0x40024050, 0x00003fff, 0, ro_t> CNT;
        };
    };
    /*
        cyclic redundancy check calculation
      unit
     */
    namespace CRC {
        /*
            Data register
         */
        namespace DR {

            static constexpr uint32_t RESETVALUE = 0xffffffff;
            typedef reg_t<0x40023000, 0xffffffff, 0, rw_t> DR_REG;
            /*
                Data register bits
             */
            typedef reg_t<0x40023000, 0xffffffff, 0, rw_t> DR;
        };
        /*
            Independent data register
         */
        namespace IDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40023004, 0xffffffff, 0, rw_t> IDR_REG;
            /*
                General-purpose 8-bit data register
              bits
             */
            typedef reg_t<0x40023004, 0x000000ff, 0, rw_t> IDR;
        };
        /*
            Control register
         */
        namespace CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40023008, 0xffffffff, 0, rw_t> CR_REG;
            /*
                reset bit
             */
            typedef reg_t<0x40023008, 0x00000001, 0, rw_t> RESET;
            /*
                Polynomial size
             */
            typedef reg_t<0x40023008, 0x00000003, 3, rw_t> POLYSIZE;
            /*
                Reverse input data
             */
            typedef reg_t<0x40023008, 0x00000003, 5, rw_t> REV_IN;
            /*
                Reverse output data
             */
            typedef reg_t<0x40023008, 0x00000001, 7, rw_t> REV_OUT;
        };
        /*
            Initial CRC value
         */
        namespace INIT {

            static constexpr uint32_t RESETVALUE = 0xffffffff;
            typedef reg_t<0x40023010, 0xffffffff, 0, rw_t> INIT_REG;
            /*
                Programmable initial CRC
              value
             */
            typedef reg_t<0x40023010, 0xffffffff, 0, rw_t> INIT;
        };
        /*
            CRC polynomial
         */
        namespace POL {

            static constexpr uint32_t RESETVALUE = 0x04c11db7;
            typedef reg_t<0x40023014, 0xffffffff, 0, rw_t> POL_REG;
            /*
                Programmable polynomial
             */
            typedef reg_t<0x40023014, 0xffffffff, 0, rw_t> POL;
        };
    };
    /*
        Flash
     */
    namespace Flash {
        /*
            Flash access control register
         */
        namespace ACR {

            static constexpr uint32_t RESETVALUE = 0x00000030;
            /*
                LATENCY
             */
            typedef reg_t<0x40022000, 0x00000007, 0, rw_t> LATENCY;
            /*
                PRFTBE
             */
            typedef reg_t<0x40022000, 0x00000001, 4, rw_t> PRFTBE;
            /*
                PRFTBS
             */
            typedef reg_t<0x40022000, 0x00000001, 5, ro_t> PRFTBS;
        };
        /*
            Flash key register
         */
        namespace KEYR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40022004, 0xffffffff, 0, wo_t> KEYR_REG;
            /*
                Flash Key
             */
            typedef reg_t<0x40022004, 0xffffffff, 0, wo_t> FKEYR;
        };
        /*
            Flash option key register
         */
        namespace OPTKEYR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40022008, 0xffffffff, 0, wo_t> OPTKEYR_REG;
            /*
                Option byte key
             */
            typedef reg_t<0x40022008, 0xffffffff, 0, wo_t> OPTKEYR;
        };
        /*
            Flash status register
         */
        namespace SR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                End of operation
             */
            typedef reg_t<0x4002200c, 0x00000001, 5, rw_t> EOP;
            /*
                Write protection error
             */
            typedef reg_t<0x4002200c, 0x00000001, 4, rw_t> WRPRT;
            /*
                Programming error
             */
            typedef reg_t<0x4002200c, 0x00000001, 2, rw_t> PGERR;
            /*
                Busy
             */
            typedef reg_t<0x4002200c, 0x00000001, 0, ro_t> BSY;
        };
        /*
            Flash control register
         */
        namespace CR {

            static constexpr uint32_t RESETVALUE = 0x00000080;
            typedef reg_t<0x40022010, 0xffffffff, 0, rw_t> CR_REG;
            /*
                Force option byte loading
             */
            typedef reg_t<0x40022010, 0x00000001, 13, rw_t> FORCE_OPTLOAD;
            /*
                End of operation interrupt
              enable
             */
            typedef reg_t<0x40022010, 0x00000001, 12, rw_t> EOPIE;
            /*
                Error interrupt enable
             */
            typedef reg_t<0x40022010, 0x00000001, 10, rw_t> ERRIE;
            /*
                Option bytes write enable
             */
            typedef reg_t<0x40022010, 0x00000001, 9, rw_t> OPTWRE;
            /*
                Lock
             */
            typedef reg_t<0x40022010, 0x00000001, 7, rw_t> LOCK;
            /*
                Start
             */
            typedef reg_t<0x40022010, 0x00000001, 6, rw_t> STRT;
            /*
                Option byte erase
             */
            typedef reg_t<0x40022010, 0x00000001, 5, rw_t> OPTER;
            /*
                Option byte programming
             */
            typedef reg_t<0x40022010, 0x00000001, 4, rw_t> OPTPG;
            /*
                Mass erase
             */
            typedef reg_t<0x40022010, 0x00000001, 2, rw_t> MER;
            /*
                Page erase
             */
            typedef reg_t<0x40022010, 0x00000001, 1, rw_t> PER;
            /*
                Programming
             */
            typedef reg_t<0x40022010, 0x00000001, 0, rw_t> PG;
        };
        /*
            Flash address register
         */
        namespace AR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40022014, 0xffffffff, 0, wo_t> AR_REG;
            /*
                Flash address
             */
            typedef reg_t<0x40022014, 0xffffffff, 0, wo_t> FAR;
        };
        /*
            Option byte register
         */
        namespace OBR {

            static constexpr uint32_t RESETVALUE = 0xffffff02;
            typedef reg_t<0x4002201c, 0xffffffff, 0, ro_t> OBR_REG;
            /*
                Option byte error
             */
            typedef reg_t<0x4002201c, 0x00000001, 0, ro_t> OPTERR;
            /*
                Level 1 protection status
             */
            typedef reg_t<0x4002201c, 0x00000001, 1, ro_t> LEVEL1_PROT;
            /*
                Level 2 protection status
             */
            typedef reg_t<0x4002201c, 0x00000001, 2, ro_t> LEVEL2_PROT;
            /*
                WDG_SW
             */
            typedef reg_t<0x4002201c, 0x00000001, 8, ro_t> WDG_SW;
            /*
                nRST_STOP
             */
            typedef reg_t<0x4002201c, 0x00000001, 9, ro_t> nRST_STOP;
            /*
                nRST_STDBY
             */
            typedef reg_t<0x4002201c, 0x00000001, 10, ro_t> nRST_STDBY;
            /*
                BOOT1
             */
            typedef reg_t<0x4002201c, 0x00000001, 12, ro_t> BOOT1;
            /*
                VDDA_MONITOR
             */
            typedef reg_t<0x4002201c, 0x00000001, 13, ro_t> VDDA_MONITOR;
            /*
                SRAM_PARITY_CHECK
             */
            typedef reg_t<0x4002201c, 0x00000001, 14, ro_t> SRAM_PARITY_CHECK;
            /*
                Data0
             */
            typedef reg_t<0x4002201c, 0x000000ff, 16, ro_t> Data0;
            /*
                Data1
             */
            typedef reg_t<0x4002201c, 0x000000ff, 24, ro_t> Data1;
        };
        /*
            Write protection register
         */
        namespace WRPR {

            static constexpr uint32_t RESETVALUE = 0xffffffff;
            typedef reg_t<0x40022020, 0xffffffff, 0, ro_t> WRPR_REG;
            /*
                Write protect
             */
            typedef reg_t<0x40022020, 0xffffffff, 0, ro_t> WRP;
        };
    };
    /*
        Reset and clock control
     */
    namespace RCC {
        /*
            Clock control register
         */
        namespace CR {

            static constexpr uint32_t RESETVALUE = 0x00000083;
            /*
                Internal High Speed clock
              enable
             */
            typedef reg_t<0x40021000, 0x00000001, 0, rw_t> HSION;
            /*
                Internal High Speed clock ready
              flag
             */
            typedef reg_t<0x40021000, 0x00000001, 1, ro_t> HSIRDY;
            /*
                Internal High Speed clock
              trimming
             */
            typedef reg_t<0x40021000, 0x0000001f, 3, rw_t> HSITRIM;
            /*
                Internal High Speed clock
              Calibration
             */
            typedef reg_t<0x40021000, 0x000000ff, 8, ro_t> HSICAL;
            /*
                External High Speed clock
              enable
             */
            typedef reg_t<0x40021000, 0x00000001, 16, rw_t> HSEON;
            /*
                External High Speed clock ready
              flag
             */
            typedef reg_t<0x40021000, 0x00000001, 17, ro_t> HSERDY;
            /*
                External High Speed clock
              Bypass
             */
            typedef reg_t<0x40021000, 0x00000001, 18, rw_t> HSEBYP;
            /*
                Clock Security System
              enable
             */
            typedef reg_t<0x40021000, 0x00000001, 19, rw_t> CSSON;
            /*
                PLL enable
             */
            typedef reg_t<0x40021000, 0x00000001, 24, rw_t> PLLON;
            /*
                PLL clock ready flag
             */
            typedef reg_t<0x40021000, 0x00000001, 25, ro_t> PLLRDY;
        };
        /*
            Clock configuration register
          (RCC_CFGR)
         */
        namespace CFGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                System clock Switch
             */
            typedef reg_t<0x40021004, 0x00000003, 0, rw_t> SW;
            /*
                System Clock Switch Status
             */
            typedef reg_t<0x40021004, 0x00000003, 2, ro_t> SWS;
            /*
                AHB prescaler
             */
            typedef reg_t<0x40021004, 0x0000000f, 4, rw_t> HPRE;
            /*
                APB Low speed prescaler
              (APB1)
             */
            typedef reg_t<0x40021004, 0x00000007, 8, rw_t> PPRE1;
            /*
                APB high speed prescaler
              (APB2)
             */
            typedef reg_t<0x40021004, 0x00000007, 11, rw_t> PPRE2;
            /*
                PLL entry clock source
             */
            typedef reg_t<0x40021004, 0x00000003, 15, rw_t> PLLSRC;
            /*
                HSE divider for PLL entry
             */
            typedef reg_t<0x40021004, 0x00000001, 17, rw_t> PLLXTPRE;
            /*
                PLL Multiplication Factor
             */
            typedef reg_t<0x40021004, 0x0000000f, 18, rw_t> PLLMUL;
            /*
                USB prescaler
             */
            typedef reg_t<0x40021004, 0x00000001, 22, rw_t> USBPRES;
            /*
                Microcontroller clock
              output
             */
            typedef reg_t<0x40021004, 0x00000007, 24, rw_t> MCO;
            /*
                Microcontroller Clock Output
              Flag
             */
            typedef reg_t<0x40021004, 0x00000001, 28, ro_t> MCOF;
            /*
                I2S external clock source
              selection
             */
            typedef reg_t<0x40021004, 0x00000001, 23, rw_t> I2SSRC;
        };
        /*
            Clock interrupt register
          (RCC_CIR)
         */
        namespace CIR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                LSI Ready Interrupt flag
             */
            typedef reg_t<0x40021008, 0x00000001, 0, ro_t> LSIRDYF;
            /*
                LSE Ready Interrupt flag
             */
            typedef reg_t<0x40021008, 0x00000001, 1, ro_t> LSERDYF;
            /*
                HSI Ready Interrupt flag
             */
            typedef reg_t<0x40021008, 0x00000001, 2, ro_t> HSIRDYF;
            /*
                HSE Ready Interrupt flag
             */
            typedef reg_t<0x40021008, 0x00000001, 3, ro_t> HSERDYF;
            /*
                PLL Ready Interrupt flag
             */
            typedef reg_t<0x40021008, 0x00000001, 4, ro_t> PLLRDYF;
            /*
                Clock Security System Interrupt
              flag
             */
            typedef reg_t<0x40021008, 0x00000001, 7, ro_t> CSSF;
            /*
                LSI Ready Interrupt Enable
             */
            typedef reg_t<0x40021008, 0x00000001, 8, rw_t> LSIRDYIE;
            /*
                LSE Ready Interrupt Enable
             */
            typedef reg_t<0x40021008, 0x00000001, 9, rw_t> LSERDYIE;
            /*
                HSI Ready Interrupt Enable
             */
            typedef reg_t<0x40021008, 0x00000001, 10, rw_t> HSIRDYIE;
            /*
                HSE Ready Interrupt Enable
             */
            typedef reg_t<0x40021008, 0x00000001, 11, rw_t> HSERDYIE;
            /*
                PLL Ready Interrupt Enable
             */
            typedef reg_t<0x40021008, 0x00000001, 12, rw_t> PLLRDYIE;
            /*
                LSI Ready Interrupt Clear
             */
            typedef reg_t<0x40021008, 0x00000001, 16, wo_t> LSIRDYC;
            /*
                LSE Ready Interrupt Clear
             */
            typedef reg_t<0x40021008, 0x00000001, 17, wo_t> LSERDYC;
            /*
                HSI Ready Interrupt Clear
             */
            typedef reg_t<0x40021008, 0x00000001, 18, wo_t> HSIRDYC;
            /*
                HSE Ready Interrupt Clear
             */
            typedef reg_t<0x40021008, 0x00000001, 19, wo_t> HSERDYC;
            /*
                PLL Ready Interrupt Clear
             */
            typedef reg_t<0x40021008, 0x00000001, 20, wo_t> PLLRDYC;
            /*
                Clock security system interrupt
              clear
             */
            typedef reg_t<0x40021008, 0x00000001, 23, wo_t> CSSC;
        };
        /*
            APB2 peripheral reset register
          (RCC_APB2RSTR)
         */
        namespace APB2RSTR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4002100c, 0xffffffff, 0, rw_t> APB2RSTR_REG;
            /*
                SYSCFG and COMP reset
             */
            typedef reg_t<0x4002100c, 0x00000001, 0, rw_t> SYSCFGRST;
            /*
                TIM1 timer reset
             */
            typedef reg_t<0x4002100c, 0x00000001, 11, rw_t> TIM1RST;
            /*
                SPI 1 reset
             */
            typedef reg_t<0x4002100c, 0x00000001, 12, rw_t> SPI1RST;
            /*
                TIM8 timer reset
             */
            typedef reg_t<0x4002100c, 0x00000001, 13, rw_t> TIM8RST;
            /*
                USART1 reset
             */
            typedef reg_t<0x4002100c, 0x00000001, 14, rw_t> USART1RST;
            /*
                TIM15 timer reset
             */
            typedef reg_t<0x4002100c, 0x00000001, 16, rw_t> TIM15RST;
            /*
                TIM16 timer reset
             */
            typedef reg_t<0x4002100c, 0x00000001, 17, rw_t> TIM16RST;
            /*
                TIM17 timer reset
             */
            typedef reg_t<0x4002100c, 0x00000001, 18, rw_t> TIM17RST;
        };
        /*
            APB1 peripheral reset register
          (RCC_APB1RSTR)
         */
        namespace APB1RSTR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40021010, 0xffffffff, 0, rw_t> APB1RSTR_REG;
            /*
                Timer 2 reset
             */
            typedef reg_t<0x40021010, 0x00000001, 0, rw_t> TIM2RST;
            /*
                Timer 3 reset
             */
            typedef reg_t<0x40021010, 0x00000001, 1, rw_t> TIM3RST;
            /*
                Timer 14 reset
             */
            typedef reg_t<0x40021010, 0x00000001, 2, rw_t> TIM4RST;
            /*
                Timer 6 reset
             */
            typedef reg_t<0x40021010, 0x00000001, 4, rw_t> TIM6RST;
            /*
                Timer 7 reset
             */
            typedef reg_t<0x40021010, 0x00000001, 5, rw_t> TIM7RST;
            /*
                Window watchdog reset
             */
            typedef reg_t<0x40021010, 0x00000001, 11, rw_t> WWDGRST;
            /*
                SPI2 reset
             */
            typedef reg_t<0x40021010, 0x00000001, 14, rw_t> SPI2RST;
            /*
                SPI3 reset
             */
            typedef reg_t<0x40021010, 0x00000001, 15, rw_t> SPI3RST;
            /*
                USART 2 reset
             */
            typedef reg_t<0x40021010, 0x00000001, 17, rw_t> USART2RST;
            /*
                USART3 reset
             */
            typedef reg_t<0x40021010, 0x00000001, 18, rw_t> USART3RST;
            /*
                UART 4 reset
             */
            typedef reg_t<0x40021010, 0x00000001, 19, rw_t> UART4RST;
            /*
                UART 5 reset
             */
            typedef reg_t<0x40021010, 0x00000001, 20, rw_t> UART5RST;
            /*
                I2C1 reset
             */
            typedef reg_t<0x40021010, 0x00000001, 21, rw_t> I2C1RST;
            /*
                I2C2 reset
             */
            typedef reg_t<0x40021010, 0x00000001, 22, rw_t> I2C2RST;
            /*
                USB reset
             */
            typedef reg_t<0x40021010, 0x00000001, 23, rw_t> USBRST;
            /*
                CAN reset
             */
            typedef reg_t<0x40021010, 0x00000001, 25, rw_t> CANRST;
            /*
                Power interface reset
             */
            typedef reg_t<0x40021010, 0x00000001, 28, rw_t> PWRRST;
            /*
                DAC interface reset
             */
            typedef reg_t<0x40021010, 0x00000001, 29, rw_t> DACRST;
            /*
                I2C3 reset
             */
            typedef reg_t<0x40021010, 0x00000001, 30, rw_t> I2C3RST;
        };
        /*
            AHB Peripheral Clock enable register
          (RCC_AHBENR)
         */
        namespace AHBENR {

            static constexpr uint32_t RESETVALUE = 0x00000014;
            typedef reg_t<0x40021014, 0xffffffff, 0, rw_t> AHBENR_REG;
            /*
                DMA1 clock enable
             */
            typedef reg_t<0x40021014, 0x00000001, 0, rw_t> DMAEN;
            /*
                DMA2 clock enable
             */
            typedef reg_t<0x40021014, 0x00000001, 1, rw_t> DMA2EN;
            /*
                SRAM interface clock
              enable
             */
            typedef reg_t<0x40021014, 0x00000001, 2, rw_t> SRAMEN;
            /*
                FLITF clock enable
             */
            typedef reg_t<0x40021014, 0x00000001, 4, rw_t> FLITFEN;
            /*
                FMC clock enable
             */
            typedef reg_t<0x40021014, 0x00000001, 5, rw_t> FMCEN;
            /*
                CRC clock enable
             */
            typedef reg_t<0x40021014, 0x00000001, 6, rw_t> CRCEN;
            /*
                IO port H clock enable
             */
            typedef reg_t<0x40021014, 0x00000001, 16, rw_t> IOPHEN;
            /*
                I/O port A clock enable
             */
            typedef reg_t<0x40021014, 0x00000001, 17, rw_t> IOPAEN;
            /*
                I/O port B clock enable
             */
            typedef reg_t<0x40021014, 0x00000001, 18, rw_t> IOPBEN;
            /*
                I/O port C clock enable
             */
            typedef reg_t<0x40021014, 0x00000001, 19, rw_t> IOPCEN;
            /*
                I/O port D clock enable
             */
            typedef reg_t<0x40021014, 0x00000001, 20, rw_t> IOPDEN;
            /*
                I/O port E clock enable
             */
            typedef reg_t<0x40021014, 0x00000001, 21, rw_t> IOPEEN;
            /*
                I/O port F clock enable
             */
            typedef reg_t<0x40021014, 0x00000001, 22, rw_t> IOPFEN;
            /*
                I/O port G clock enable
             */
            typedef reg_t<0x40021014, 0x00000001, 23, rw_t> IOPGEN;
            /*
                Touch sensing controller clock
              enable
             */
            typedef reg_t<0x40021014, 0x00000001, 24, rw_t> TSCEN;
            /*
                ADC1 and ADC2 clock enable
             */
            typedef reg_t<0x40021014, 0x00000001, 28, rw_t> ADC12EN;
            /*
                ADC3 and ADC4 clock enable
             */
            typedef reg_t<0x40021014, 0x00000001, 29, rw_t> ADC34EN;
        };
        /*
            APB2 peripheral clock enable register
          (RCC_APB2ENR)
         */
        namespace APB2ENR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40021018, 0xffffffff, 0, rw_t> APB2ENR_REG;
            /*
                SYSCFG clock enable
             */
            typedef reg_t<0x40021018, 0x00000001, 0, rw_t> SYSCFGEN;
            /*
                TIM1 Timer clock enable
             */
            typedef reg_t<0x40021018, 0x00000001, 11, rw_t> TIM1EN;
            /*
                SPI 1 clock enable
             */
            typedef reg_t<0x40021018, 0x00000001, 12, rw_t> SPI1EN;
            /*
                TIM8 Timer clock enable
             */
            typedef reg_t<0x40021018, 0x00000001, 13, rw_t> TIM8EN;
            /*
                USART1 clock enable
             */
            typedef reg_t<0x40021018, 0x00000001, 14, rw_t> USART1EN;
            /*
                TIM15 timer clock enable
             */
            typedef reg_t<0x40021018, 0x00000001, 16, rw_t> TIM15EN;
            /*
                TIM16 timer clock enable
             */
            typedef reg_t<0x40021018, 0x00000001, 17, rw_t> TIM16EN;
            /*
                TIM17 timer clock enable
             */
            typedef reg_t<0x40021018, 0x00000001, 18, rw_t> TIM17EN;
        };
        /*
            APB1 peripheral clock enable register
          (RCC_APB1ENR)
         */
        namespace APB1ENR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4002101c, 0xffffffff, 0, rw_t> APB1ENR_REG;
            /*
                Timer 2 clock enable
             */
            typedef reg_t<0x4002101c, 0x00000001, 0, rw_t> TIM2EN;
            /*
                Timer 3 clock enable
             */
            typedef reg_t<0x4002101c, 0x00000001, 1, rw_t> TIM3EN;
            /*
                Timer 4 clock enable
             */
            typedef reg_t<0x4002101c, 0x00000001, 2, rw_t> TIM4EN;
            /*
                Timer 6 clock enable
             */
            typedef reg_t<0x4002101c, 0x00000001, 4, rw_t> TIM6EN;
            /*
                Timer 7 clock enable
             */
            typedef reg_t<0x4002101c, 0x00000001, 5, rw_t> TIM7EN;
            /*
                Window watchdog clock
              enable
             */
            typedef reg_t<0x4002101c, 0x00000001, 11, rw_t> WWDGEN;
            /*
                SPI 2 clock enable
             */
            typedef reg_t<0x4002101c, 0x00000001, 14, rw_t> SPI2EN;
            /*
                SPI 3 clock enable
             */
            typedef reg_t<0x4002101c, 0x00000001, 15, rw_t> SPI3EN;
            /*
                USART 2 clock enable
             */
            typedef reg_t<0x4002101c, 0x00000001, 17, rw_t> USART2EN;
            /*
                USART 3 clock enable
             */
            typedef reg_t<0x4002101c, 0x00000001, 18, rw_t> USART3EN;
            /*
                USART 4 clock enable
             */
            typedef reg_t<0x4002101c, 0x00000001, 19, rw_t> USART4EN;
            /*
                USART 5 clock enable
             */
            typedef reg_t<0x4002101c, 0x00000001, 20, rw_t> USART5EN;
            /*
                I2C 1 clock enable
             */
            typedef reg_t<0x4002101c, 0x00000001, 21, rw_t> I2C1EN;
            /*
                I2C 2 clock enable
             */
            typedef reg_t<0x4002101c, 0x00000001, 22, rw_t> I2C2EN;
            /*
                USB clock enable
             */
            typedef reg_t<0x4002101c, 0x00000001, 23, rw_t> USBEN;
            /*
                CAN clock enable
             */
            typedef reg_t<0x4002101c, 0x00000001, 25, rw_t> CANEN;
            /*
                DAC2 interface clock
              enable
             */
            typedef reg_t<0x4002101c, 0x00000001, 26, rw_t> DAC2EN;
            /*
                Power interface clock
              enable
             */
            typedef reg_t<0x4002101c, 0x00000001, 28, rw_t> PWREN;
            /*
                DAC interface clock enable
             */
            typedef reg_t<0x4002101c, 0x00000001, 29, rw_t> DACEN;
            /*
                I2C3 clock enable
             */
            typedef reg_t<0x4002101c, 0x00000001, 30, rw_t> I2C3EN;
        };
        /*
            Backup domain control register
          (RCC_BDCR)
         */
        namespace BDCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                External Low Speed oscillator
              enable
             */
            typedef reg_t<0x40021020, 0x00000001, 0, rw_t> LSEON;
            /*
                External Low Speed oscillator
              ready
             */
            typedef reg_t<0x40021020, 0x00000001, 1, ro_t> LSERDY;
            /*
                External Low Speed oscillator
              bypass
             */
            typedef reg_t<0x40021020, 0x00000001, 2, rw_t> LSEBYP;
            /*
                LSE oscillator drive
              capability
             */
            typedef reg_t<0x40021020, 0x00000003, 3, rw_t> LSEDRV;
            /*
                RTC clock source selection
             */
            typedef reg_t<0x40021020, 0x00000003, 8, rw_t> RTCSEL;
            /*
                RTC clock enable
             */
            typedef reg_t<0x40021020, 0x00000001, 15, rw_t> RTCEN;
            /*
                Backup domain software
              reset
             */
            typedef reg_t<0x40021020, 0x00000001, 16, rw_t> BDRST;
        };
        /*
            Control/status register
          (RCC_CSR)
         */
        namespace CSR {

            static constexpr uint32_t RESETVALUE = 0x0c000000;
            /*
                Internal low speed oscillator
              enable
             */
            typedef reg_t<0x40021024, 0x00000001, 0, rw_t> LSION;
            /*
                Internal low speed oscillator
              ready
             */
            typedef reg_t<0x40021024, 0x00000001, 1, ro_t> LSIRDY;
            /*
                Remove reset flag
             */
            typedef reg_t<0x40021024, 0x00000001, 24, rw_t> RMVF;
            /*
                Option byte loader reset
              flag
             */
            typedef reg_t<0x40021024, 0x00000001, 25, rw_t> OBLRSTF;
            /*
                PIN reset flag
             */
            typedef reg_t<0x40021024, 0x00000001, 26, rw_t> PINRSTF;
            /*
                POR/PDR reset flag
             */
            typedef reg_t<0x40021024, 0x00000001, 27, rw_t> PORRSTF;
            /*
                Software reset flag
             */
            typedef reg_t<0x40021024, 0x00000001, 28, rw_t> SFTRSTF;
            /*
                Independent watchdog reset
              flag
             */
            typedef reg_t<0x40021024, 0x00000001, 29, rw_t> IWDGRSTF;
            /*
                Window watchdog reset flag
             */
            typedef reg_t<0x40021024, 0x00000001, 30, rw_t> WWDGRSTF;
            /*
                Low-power reset flag
             */
            typedef reg_t<0x40021024, 0x00000001, 31, rw_t> LPWRRSTF;
        };
        /*
            AHB peripheral reset register
         */
        namespace AHBRSTR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40021028, 0xffffffff, 0, rw_t> AHBRSTR_REG;
            /*
                FMC reset
             */
            typedef reg_t<0x40021028, 0x00000001, 5, rw_t> FMCRST;
            /*
                I/O port H reset
             */
            typedef reg_t<0x40021028, 0x00000001, 16, rw_t> IOPHRST;
            /*
                I/O port A reset
             */
            typedef reg_t<0x40021028, 0x00000001, 17, rw_t> IOPARST;
            /*
                I/O port B reset
             */
            typedef reg_t<0x40021028, 0x00000001, 18, rw_t> IOPBRST;
            /*
                I/O port C reset
             */
            typedef reg_t<0x40021028, 0x00000001, 19, rw_t> IOPCRST;
            /*
                I/O port D reset
             */
            typedef reg_t<0x40021028, 0x00000001, 20, rw_t> IOPDRST;
            /*
                I/O port E reset
             */
            typedef reg_t<0x40021028, 0x00000001, 21, rw_t> IOPERST;
            /*
                I/O port F reset
             */
            typedef reg_t<0x40021028, 0x00000001, 22, rw_t> IOPFRST;
            /*
                Touch sensing controller
              reset
             */
            typedef reg_t<0x40021028, 0x00000001, 23, rw_t> IOPGRST;
            /*
                Touch sensing controller
              reset
             */
            typedef reg_t<0x40021028, 0x00000001, 24, rw_t> TSCRST;
            /*
                ADC1 and ADC2 reset
             */
            typedef reg_t<0x40021028, 0x00000001, 28, rw_t> ADC12RST;
            /*
                ADC3 and ADC4 reset
             */
            typedef reg_t<0x40021028, 0x00000001, 29, rw_t> ADC34RST;
        };
        /*
            Clock configuration register 2
         */
        namespace CFGR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4002102c, 0xffffffff, 0, rw_t> CFGR2_REG;
            /*
                PREDIV division factor
             */
            typedef reg_t<0x4002102c, 0x0000000f, 0, rw_t> PREDIV;
            /*
                ADC1 and ADC2 prescaler
             */
            typedef reg_t<0x4002102c, 0x0000001f, 4, rw_t> ADC12PRES;
            /*
                ADC3 and ADC4 prescaler
             */
            typedef reg_t<0x4002102c, 0x0000001f, 9, rw_t> ADC34PRES;
        };
        /*
            Clock configuration register 3
         */
        namespace CFGR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40021030, 0xffffffff, 0, rw_t> CFGR3_REG;
            /*
                USART1 clock source
              selection
             */
            typedef reg_t<0x40021030, 0x00000003, 0, rw_t> USART1SW;
            /*
                I2C1 clock source
              selection
             */
            typedef reg_t<0x40021030, 0x00000001, 4, rw_t> I2C1SW;
            /*
                I2C2 clock source
              selection
             */
            typedef reg_t<0x40021030, 0x00000001, 5, rw_t> I2C2SW;
            /*
                I2C3 clock source
              selection
             */
            typedef reg_t<0x40021030, 0x00000001, 6, rw_t> I2C3SW;
            /*
                USART2 clock source
              selection
             */
            typedef reg_t<0x40021030, 0x00000003, 16, rw_t> USART2SW;
            /*
                USART3 clock source
              selection
             */
            typedef reg_t<0x40021030, 0x00000003, 18, rw_t> USART3SW;
            /*
                Timer1 clock source
              selection
             */
            typedef reg_t<0x40021030, 0x00000001, 8, rw_t> TIM1SW;
            /*
                Timer8 clock source
              selection
             */
            typedef reg_t<0x40021030, 0x00000001, 9, rw_t> TIM8SW;
            /*
                UART4 clock source
              selection
             */
            typedef reg_t<0x40021030, 0x00000003, 20, rw_t> UART4SW;
            /*
                UART5 clock source
              selection
             */
            typedef reg_t<0x40021030, 0x00000003, 22, rw_t> UART5SW;
        };
    };
    /*
        DMA controller 1
     */
    namespace DMA1 {
        /*
            DMA interrupt status register
          (DMA_ISR)
         */
        namespace ISR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020000, 0xffffffff, 0, ro_t> ISR_REG;
            /*
                Channel 1 Global interrupt
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 0, ro_t> GIF1;
            /*
                Channel 1 Transfer Complete
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 1, ro_t> TCIF1;
            /*
                Channel 1 Half Transfer Complete
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 2, ro_t> HTIF1;
            /*
                Channel 1 Transfer Error
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 3, ro_t> TEIF1;
            /*
                Channel 2 Global interrupt
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 4, ro_t> GIF2;
            /*
                Channel 2 Transfer Complete
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 5, ro_t> TCIF2;
            /*
                Channel 2 Half Transfer Complete
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 6, ro_t> HTIF2;
            /*
                Channel 2 Transfer Error
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 7, ro_t> TEIF2;
            /*
                Channel 3 Global interrupt
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 8, ro_t> GIF3;
            /*
                Channel 3 Transfer Complete
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 9, ro_t> TCIF3;
            /*
                Channel 3 Half Transfer Complete
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 10, ro_t> HTIF3;
            /*
                Channel 3 Transfer Error
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 11, ro_t> TEIF3;
            /*
                Channel 4 Global interrupt
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 12, ro_t> GIF4;
            /*
                Channel 4 Transfer Complete
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 13, ro_t> TCIF4;
            /*
                Channel 4 Half Transfer Complete
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 14, ro_t> HTIF4;
            /*
                Channel 4 Transfer Error
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 15, ro_t> TEIF4;
            /*
                Channel 5 Global interrupt
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 16, ro_t> GIF5;
            /*
                Channel 5 Transfer Complete
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 17, ro_t> TCIF5;
            /*
                Channel 5 Half Transfer Complete
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 18, ro_t> HTIF5;
            /*
                Channel 5 Transfer Error
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 19, ro_t> TEIF5;
            /*
                Channel 6 Global interrupt
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 20, ro_t> GIF6;
            /*
                Channel 6 Transfer Complete
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 21, ro_t> TCIF6;
            /*
                Channel 6 Half Transfer Complete
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 22, ro_t> HTIF6;
            /*
                Channel 6 Transfer Error
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 23, ro_t> TEIF6;
            /*
                Channel 7 Global interrupt
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 24, ro_t> GIF7;
            /*
                Channel 7 Transfer Complete
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 25, ro_t> TCIF7;
            /*
                Channel 7 Half Transfer Complete
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 26, ro_t> HTIF7;
            /*
                Channel 7 Transfer Error
              flag
             */
            typedef reg_t<0x40020000, 0x00000001, 27, ro_t> TEIF7;
        };
        /*
            DMA interrupt flag clear register
          (DMA_IFCR)
         */
        namespace IFCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020004, 0xffffffff, 0, wo_t> IFCR_REG;
            /*
                Channel 1 Global interrupt
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 0, wo_t> CGIF1;
            /*
                Channel 1 Transfer Complete
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 1, wo_t> CTCIF1;
            /*
                Channel 1 Half Transfer
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 2, wo_t> CHTIF1;
            /*
                Channel 1 Transfer Error
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 3, wo_t> CTEIF1;
            /*
                Channel 2 Global interrupt
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 4, wo_t> CGIF2;
            /*
                Channel 2 Transfer Complete
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 5, wo_t> CTCIF2;
            /*
                Channel 2 Half Transfer
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 6, wo_t> CHTIF2;
            /*
                Channel 2 Transfer Error
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 7, wo_t> CTEIF2;
            /*
                Channel 3 Global interrupt
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 8, wo_t> CGIF3;
            /*
                Channel 3 Transfer Complete
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 9, wo_t> CTCIF3;
            /*
                Channel 3 Half Transfer
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 10, wo_t> CHTIF3;
            /*
                Channel 3 Transfer Error
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 11, wo_t> CTEIF3;
            /*
                Channel 4 Global interrupt
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 12, wo_t> CGIF4;
            /*
                Channel 4 Transfer Complete
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 13, wo_t> CTCIF4;
            /*
                Channel 4 Half Transfer
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 14, wo_t> CHTIF4;
            /*
                Channel 4 Transfer Error
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 15, wo_t> CTEIF4;
            /*
                Channel 5 Global interrupt
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 16, wo_t> CGIF5;
            /*
                Channel 5 Transfer Complete
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 17, wo_t> CTCIF5;
            /*
                Channel 5 Half Transfer
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 18, wo_t> CHTIF5;
            /*
                Channel 5 Transfer Error
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 19, wo_t> CTEIF5;
            /*
                Channel 6 Global interrupt
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 20, wo_t> CGIF6;
            /*
                Channel 6 Transfer Complete
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 21, wo_t> CTCIF6;
            /*
                Channel 6 Half Transfer
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 22, wo_t> CHTIF6;
            /*
                Channel 6 Transfer Error
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 23, wo_t> CTEIF6;
            /*
                Channel 7 Global interrupt
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 24, wo_t> CGIF7;
            /*
                Channel 7 Transfer Complete
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 25, wo_t> CTCIF7;
            /*
                Channel 7 Half Transfer
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 26, wo_t> CHTIF7;
            /*
                Channel 7 Transfer Error
              clear
             */
            typedef reg_t<0x40020004, 0x00000001, 27, wo_t> CTEIF7;
        };
        /*
            DMA channel configuration register
          (DMA_CCR)
         */
        namespace CCR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020008, 0xffffffff, 0, rw_t> CCR1_REG;
            /*
                Channel enable
             */
            typedef reg_t<0x40020008, 0x00000001, 0, rw_t> EN;
            /*
                Transfer complete interrupt
              enable
             */
            typedef reg_t<0x40020008, 0x00000001, 1, rw_t> TCIE;
            /*
                Half Transfer interrupt
              enable
             */
            typedef reg_t<0x40020008, 0x00000001, 2, rw_t> HTIE;
            /*
                Transfer error interrupt
              enable
             */
            typedef reg_t<0x40020008, 0x00000001, 3, rw_t> TEIE;
            /*
                Data transfer direction
             */
            typedef reg_t<0x40020008, 0x00000001, 4, rw_t> DIR;
            /*
                Circular mode
             */
            typedef reg_t<0x40020008, 0x00000001, 5, rw_t> CIRC;
            /*
                Peripheral increment mode
             */
            typedef reg_t<0x40020008, 0x00000001, 6, rw_t> PINC;
            /*
                Memory increment mode
             */
            typedef reg_t<0x40020008, 0x00000001, 7, rw_t> MINC;
            /*
                Peripheral size
             */
            typedef reg_t<0x40020008, 0x00000003, 8, rw_t> PSIZE;
            /*
                Memory size
             */
            typedef reg_t<0x40020008, 0x00000003, 10, rw_t> MSIZE;
            /*
                Channel Priority level
             */
            typedef reg_t<0x40020008, 0x00000003, 12, rw_t> PL;
            /*
                Memory to memory mode
             */
            typedef reg_t<0x40020008, 0x00000001, 14, rw_t> MEM2MEM;
        };
        /*
            DMA channel 1 number of data
          register
         */
        namespace CNDTR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4002000c, 0xffffffff, 0, rw_t> CNDTR1_REG;
            /*
                Number of data to transfer
             */
            typedef reg_t<0x4002000c, 0x0000ffff, 0, rw_t> NDT;
        };
        /*
            DMA channel 1 peripheral address
          register
         */
        namespace CPAR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020010, 0xffffffff, 0, rw_t> CPAR1_REG;
            /*
                Peripheral address
             */
            typedef reg_t<0x40020010, 0xffffffff, 0, rw_t> PA;
        };
        /*
            DMA channel 1 memory address
          register
         */
        namespace CMAR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020014, 0xffffffff, 0, rw_t> CMAR1_REG;
            /*
                Memory address
             */
            typedef reg_t<0x40020014, 0xffffffff, 0, rw_t> MA;
        };
        /*
            DMA channel configuration register
          (DMA_CCR)
         */
        namespace CCR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4002001c, 0xffffffff, 0, rw_t> CCR2_REG;
            /*
                Channel enable
             */
            typedef reg_t<0x4002001c, 0x00000001, 0, rw_t> EN;
            /*
                Transfer complete interrupt
              enable
             */
            typedef reg_t<0x4002001c, 0x00000001, 1, rw_t> TCIE;
            /*
                Half Transfer interrupt
              enable
             */
            typedef reg_t<0x4002001c, 0x00000001, 2, rw_t> HTIE;
            /*
                Transfer error interrupt
              enable
             */
            typedef reg_t<0x4002001c, 0x00000001, 3, rw_t> TEIE;
            /*
                Data transfer direction
             */
            typedef reg_t<0x4002001c, 0x00000001, 4, rw_t> DIR;
            /*
                Circular mode
             */
            typedef reg_t<0x4002001c, 0x00000001, 5, rw_t> CIRC;
            /*
                Peripheral increment mode
             */
            typedef reg_t<0x4002001c, 0x00000001, 6, rw_t> PINC;
            /*
                Memory increment mode
             */
            typedef reg_t<0x4002001c, 0x00000001, 7, rw_t> MINC;
            /*
                Peripheral size
             */
            typedef reg_t<0x4002001c, 0x00000003, 8, rw_t> PSIZE;
            /*
                Memory size
             */
            typedef reg_t<0x4002001c, 0x00000003, 10, rw_t> MSIZE;
            /*
                Channel Priority level
             */
            typedef reg_t<0x4002001c, 0x00000003, 12, rw_t> PL;
            /*
                Memory to memory mode
             */
            typedef reg_t<0x4002001c, 0x00000001, 14, rw_t> MEM2MEM;
        };
        /*
            DMA channel 2 number of data
          register
         */
        namespace CNDTR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020020, 0xffffffff, 0, rw_t> CNDTR2_REG;
            /*
                Number of data to transfer
             */
            typedef reg_t<0x40020020, 0x0000ffff, 0, rw_t> NDT;
        };
        /*
            DMA channel 2 peripheral address
          register
         */
        namespace CPAR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020024, 0xffffffff, 0, rw_t> CPAR2_REG;
            /*
                Peripheral address
             */
            typedef reg_t<0x40020024, 0xffffffff, 0, rw_t> PA;
        };
        /*
            DMA channel 2 memory address
          register
         */
        namespace CMAR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020028, 0xffffffff, 0, rw_t> CMAR2_REG;
            /*
                Memory address
             */
            typedef reg_t<0x40020028, 0xffffffff, 0, rw_t> MA;
        };
        /*
            DMA channel configuration register
          (DMA_CCR)
         */
        namespace CCR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020030, 0xffffffff, 0, rw_t> CCR3_REG;
            /*
                Channel enable
             */
            typedef reg_t<0x40020030, 0x00000001, 0, rw_t> EN;
            /*
                Transfer complete interrupt
              enable
             */
            typedef reg_t<0x40020030, 0x00000001, 1, rw_t> TCIE;
            /*
                Half Transfer interrupt
              enable
             */
            typedef reg_t<0x40020030, 0x00000001, 2, rw_t> HTIE;
            /*
                Transfer error interrupt
              enable
             */
            typedef reg_t<0x40020030, 0x00000001, 3, rw_t> TEIE;
            /*
                Data transfer direction
             */
            typedef reg_t<0x40020030, 0x00000001, 4, rw_t> DIR;
            /*
                Circular mode
             */
            typedef reg_t<0x40020030, 0x00000001, 5, rw_t> CIRC;
            /*
                Peripheral increment mode
             */
            typedef reg_t<0x40020030, 0x00000001, 6, rw_t> PINC;
            /*
                Memory increment mode
             */
            typedef reg_t<0x40020030, 0x00000001, 7, rw_t> MINC;
            /*
                Peripheral size
             */
            typedef reg_t<0x40020030, 0x00000003, 8, rw_t> PSIZE;
            /*
                Memory size
             */
            typedef reg_t<0x40020030, 0x00000003, 10, rw_t> MSIZE;
            /*
                Channel Priority level
             */
            typedef reg_t<0x40020030, 0x00000003, 12, rw_t> PL;
            /*
                Memory to memory mode
             */
            typedef reg_t<0x40020030, 0x00000001, 14, rw_t> MEM2MEM;
        };
        /*
            DMA channel 3 number of data
          register
         */
        namespace CNDTR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020034, 0xffffffff, 0, rw_t> CNDTR3_REG;
            /*
                Number of data to transfer
             */
            typedef reg_t<0x40020034, 0x0000ffff, 0, rw_t> NDT;
        };
        /*
            DMA channel 3 peripheral address
          register
         */
        namespace CPAR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020038, 0xffffffff, 0, rw_t> CPAR3_REG;
            /*
                Peripheral address
             */
            typedef reg_t<0x40020038, 0xffffffff, 0, rw_t> PA;
        };
        /*
            DMA channel 3 memory address
          register
         */
        namespace CMAR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4002003c, 0xffffffff, 0, rw_t> CMAR3_REG;
            /*
                Memory address
             */
            typedef reg_t<0x4002003c, 0xffffffff, 0, rw_t> MA;
        };
        /*
            DMA channel configuration register
          (DMA_CCR)
         */
        namespace CCR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020044, 0xffffffff, 0, rw_t> CCR4_REG;
            /*
                Channel enable
             */
            typedef reg_t<0x40020044, 0x00000001, 0, rw_t> EN;
            /*
                Transfer complete interrupt
              enable
             */
            typedef reg_t<0x40020044, 0x00000001, 1, rw_t> TCIE;
            /*
                Half Transfer interrupt
              enable
             */
            typedef reg_t<0x40020044, 0x00000001, 2, rw_t> HTIE;
            /*
                Transfer error interrupt
              enable
             */
            typedef reg_t<0x40020044, 0x00000001, 3, rw_t> TEIE;
            /*
                Data transfer direction
             */
            typedef reg_t<0x40020044, 0x00000001, 4, rw_t> DIR;
            /*
                Circular mode
             */
            typedef reg_t<0x40020044, 0x00000001, 5, rw_t> CIRC;
            /*
                Peripheral increment mode
             */
            typedef reg_t<0x40020044, 0x00000001, 6, rw_t> PINC;
            /*
                Memory increment mode
             */
            typedef reg_t<0x40020044, 0x00000001, 7, rw_t> MINC;
            /*
                Peripheral size
             */
            typedef reg_t<0x40020044, 0x00000003, 8, rw_t> PSIZE;
            /*
                Memory size
             */
            typedef reg_t<0x40020044, 0x00000003, 10, rw_t> MSIZE;
            /*
                Channel Priority level
             */
            typedef reg_t<0x40020044, 0x00000003, 12, rw_t> PL;
            /*
                Memory to memory mode
             */
            typedef reg_t<0x40020044, 0x00000001, 14, rw_t> MEM2MEM;
        };
        /*
            DMA channel 4 number of data
          register
         */
        namespace CNDTR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020048, 0xffffffff, 0, rw_t> CNDTR4_REG;
            /*
                Number of data to transfer
             */
            typedef reg_t<0x40020048, 0x0000ffff, 0, rw_t> NDT;
        };
        /*
            DMA channel 4 peripheral address
          register
         */
        namespace CPAR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4002004c, 0xffffffff, 0, rw_t> CPAR4_REG;
            /*
                Peripheral address
             */
            typedef reg_t<0x4002004c, 0xffffffff, 0, rw_t> PA;
        };
        /*
            DMA channel 4 memory address
          register
         */
        namespace CMAR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020050, 0xffffffff, 0, rw_t> CMAR4_REG;
            /*
                Memory address
             */
            typedef reg_t<0x40020050, 0xffffffff, 0, rw_t> MA;
        };
        /*
            DMA channel configuration register
          (DMA_CCR)
         */
        namespace CCR5 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020058, 0xffffffff, 0, rw_t> CCR5_REG;
            /*
                Channel enable
             */
            typedef reg_t<0x40020058, 0x00000001, 0, rw_t> EN;
            /*
                Transfer complete interrupt
              enable
             */
            typedef reg_t<0x40020058, 0x00000001, 1, rw_t> TCIE;
            /*
                Half Transfer interrupt
              enable
             */
            typedef reg_t<0x40020058, 0x00000001, 2, rw_t> HTIE;
            /*
                Transfer error interrupt
              enable
             */
            typedef reg_t<0x40020058, 0x00000001, 3, rw_t> TEIE;
            /*
                Data transfer direction
             */
            typedef reg_t<0x40020058, 0x00000001, 4, rw_t> DIR;
            /*
                Circular mode
             */
            typedef reg_t<0x40020058, 0x00000001, 5, rw_t> CIRC;
            /*
                Peripheral increment mode
             */
            typedef reg_t<0x40020058, 0x00000001, 6, rw_t> PINC;
            /*
                Memory increment mode
             */
            typedef reg_t<0x40020058, 0x00000001, 7, rw_t> MINC;
            /*
                Peripheral size
             */
            typedef reg_t<0x40020058, 0x00000003, 8, rw_t> PSIZE;
            /*
                Memory size
             */
            typedef reg_t<0x40020058, 0x00000003, 10, rw_t> MSIZE;
            /*
                Channel Priority level
             */
            typedef reg_t<0x40020058, 0x00000003, 12, rw_t> PL;
            /*
                Memory to memory mode
             */
            typedef reg_t<0x40020058, 0x00000001, 14, rw_t> MEM2MEM;
        };
        /*
            DMA channel 5 number of data
          register
         */
        namespace CNDTR5 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4002005c, 0xffffffff, 0, rw_t> CNDTR5_REG;
            /*
                Number of data to transfer
             */
            typedef reg_t<0x4002005c, 0x0000ffff, 0, rw_t> NDT;
        };
        /*
            DMA channel 5 peripheral address
          register
         */
        namespace CPAR5 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020060, 0xffffffff, 0, rw_t> CPAR5_REG;
            /*
                Peripheral address
             */
            typedef reg_t<0x40020060, 0xffffffff, 0, rw_t> PA;
        };
        /*
            DMA channel 5 memory address
          register
         */
        namespace CMAR5 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020064, 0xffffffff, 0, rw_t> CMAR5_REG;
            /*
                Memory address
             */
            typedef reg_t<0x40020064, 0xffffffff, 0, rw_t> MA;
        };
        /*
            DMA channel configuration register
          (DMA_CCR)
         */
        namespace CCR6 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4002006c, 0xffffffff, 0, rw_t> CCR6_REG;
            /*
                Channel enable
             */
            typedef reg_t<0x4002006c, 0x00000001, 0, rw_t> EN;
            /*
                Transfer complete interrupt
              enable
             */
            typedef reg_t<0x4002006c, 0x00000001, 1, rw_t> TCIE;
            /*
                Half Transfer interrupt
              enable
             */
            typedef reg_t<0x4002006c, 0x00000001, 2, rw_t> HTIE;
            /*
                Transfer error interrupt
              enable
             */
            typedef reg_t<0x4002006c, 0x00000001, 3, rw_t> TEIE;
            /*
                Data transfer direction
             */
            typedef reg_t<0x4002006c, 0x00000001, 4, rw_t> DIR;
            /*
                Circular mode
             */
            typedef reg_t<0x4002006c, 0x00000001, 5, rw_t> CIRC;
            /*
                Peripheral increment mode
             */
            typedef reg_t<0x4002006c, 0x00000001, 6, rw_t> PINC;
            /*
                Memory increment mode
             */
            typedef reg_t<0x4002006c, 0x00000001, 7, rw_t> MINC;
            /*
                Peripheral size
             */
            typedef reg_t<0x4002006c, 0x00000003, 8, rw_t> PSIZE;
            /*
                Memory size
             */
            typedef reg_t<0x4002006c, 0x00000003, 10, rw_t> MSIZE;
            /*
                Channel Priority level
             */
            typedef reg_t<0x4002006c, 0x00000003, 12, rw_t> PL;
            /*
                Memory to memory mode
             */
            typedef reg_t<0x4002006c, 0x00000001, 14, rw_t> MEM2MEM;
        };
        /*
            DMA channel 6 number of data
          register
         */
        namespace CNDTR6 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020070, 0xffffffff, 0, rw_t> CNDTR6_REG;
            /*
                Number of data to transfer
             */
            typedef reg_t<0x40020070, 0x0000ffff, 0, rw_t> NDT;
        };
        /*
            DMA channel 6 peripheral address
          register
         */
        namespace CPAR6 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020074, 0xffffffff, 0, rw_t> CPAR6_REG;
            /*
                Peripheral address
             */
            typedef reg_t<0x40020074, 0xffffffff, 0, rw_t> PA;
        };
        /*
            DMA channel 6 memory address
          register
         */
        namespace CMAR6 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020078, 0xffffffff, 0, rw_t> CMAR6_REG;
            /*
                Memory address
             */
            typedef reg_t<0x40020078, 0xffffffff, 0, rw_t> MA;
        };
        /*
            DMA channel configuration register
          (DMA_CCR)
         */
        namespace CCR7 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020080, 0xffffffff, 0, rw_t> CCR7_REG;
            /*
                Channel enable
             */
            typedef reg_t<0x40020080, 0x00000001, 0, rw_t> EN;
            /*
                Transfer complete interrupt
              enable
             */
            typedef reg_t<0x40020080, 0x00000001, 1, rw_t> TCIE;
            /*
                Half Transfer interrupt
              enable
             */
            typedef reg_t<0x40020080, 0x00000001, 2, rw_t> HTIE;
            /*
                Transfer error interrupt
              enable
             */
            typedef reg_t<0x40020080, 0x00000001, 3, rw_t> TEIE;
            /*
                Data transfer direction
             */
            typedef reg_t<0x40020080, 0x00000001, 4, rw_t> DIR;
            /*
                Circular mode
             */
            typedef reg_t<0x40020080, 0x00000001, 5, rw_t> CIRC;
            /*
                Peripheral increment mode
             */
            typedef reg_t<0x40020080, 0x00000001, 6, rw_t> PINC;
            /*
                Memory increment mode
             */
            typedef reg_t<0x40020080, 0x00000001, 7, rw_t> MINC;
            /*
                Peripheral size
             */
            typedef reg_t<0x40020080, 0x00000003, 8, rw_t> PSIZE;
            /*
                Memory size
             */
            typedef reg_t<0x40020080, 0x00000003, 10, rw_t> MSIZE;
            /*
                Channel Priority level
             */
            typedef reg_t<0x40020080, 0x00000003, 12, rw_t> PL;
            /*
                Memory to memory mode
             */
            typedef reg_t<0x40020080, 0x00000001, 14, rw_t> MEM2MEM;
        };
        /*
            DMA channel 7 number of data
          register
         */
        namespace CNDTR7 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020084, 0xffffffff, 0, rw_t> CNDTR7_REG;
            /*
                Number of data to transfer
             */
            typedef reg_t<0x40020084, 0x0000ffff, 0, rw_t> NDT;
        };
        /*
            DMA channel 7 peripheral address
          register
         */
        namespace CPAR7 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020088, 0xffffffff, 0, rw_t> CPAR7_REG;
            /*
                Peripheral address
             */
            typedef reg_t<0x40020088, 0xffffffff, 0, rw_t> PA;
        };
        /*
            DMA channel 7 memory address
          register
         */
        namespace CMAR7 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4002008c, 0xffffffff, 0, rw_t> CMAR7_REG;
            /*
                Memory address
             */
            typedef reg_t<0x4002008c, 0xffffffff, 0, rw_t> MA;
        };
    };
    /*
        DMA controller 1
     */
    namespace DMA2 {
        /*
            DMA interrupt status register
          (DMA_ISR)
         */
        namespace ISR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020400, 0xffffffff, 0, ro_t> ISR_REG;
            /*
                Channel 1 Global interrupt
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 0, ro_t> GIF1;
            /*
                Channel 1 Transfer Complete
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 1, ro_t> TCIF1;
            /*
                Channel 1 Half Transfer Complete
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 2, ro_t> HTIF1;
            /*
                Channel 1 Transfer Error
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 3, ro_t> TEIF1;
            /*
                Channel 2 Global interrupt
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 4, ro_t> GIF2;
            /*
                Channel 2 Transfer Complete
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 5, ro_t> TCIF2;
            /*
                Channel 2 Half Transfer Complete
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 6, ro_t> HTIF2;
            /*
                Channel 2 Transfer Error
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 7, ro_t> TEIF2;
            /*
                Channel 3 Global interrupt
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 8, ro_t> GIF3;
            /*
                Channel 3 Transfer Complete
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 9, ro_t> TCIF3;
            /*
                Channel 3 Half Transfer Complete
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 10, ro_t> HTIF3;
            /*
                Channel 3 Transfer Error
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 11, ro_t> TEIF3;
            /*
                Channel 4 Global interrupt
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 12, ro_t> GIF4;
            /*
                Channel 4 Transfer Complete
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 13, ro_t> TCIF4;
            /*
                Channel 4 Half Transfer Complete
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 14, ro_t> HTIF4;
            /*
                Channel 4 Transfer Error
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 15, ro_t> TEIF4;
            /*
                Channel 5 Global interrupt
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 16, ro_t> GIF5;
            /*
                Channel 5 Transfer Complete
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 17, ro_t> TCIF5;
            /*
                Channel 5 Half Transfer Complete
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 18, ro_t> HTIF5;
            /*
                Channel 5 Transfer Error
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 19, ro_t> TEIF5;
            /*
                Channel 6 Global interrupt
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 20, ro_t> GIF6;
            /*
                Channel 6 Transfer Complete
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 21, ro_t> TCIF6;
            /*
                Channel 6 Half Transfer Complete
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 22, ro_t> HTIF6;
            /*
                Channel 6 Transfer Error
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 23, ro_t> TEIF6;
            /*
                Channel 7 Global interrupt
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 24, ro_t> GIF7;
            /*
                Channel 7 Transfer Complete
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 25, ro_t> TCIF7;
            /*
                Channel 7 Half Transfer Complete
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 26, ro_t> HTIF7;
            /*
                Channel 7 Transfer Error
              flag
             */
            typedef reg_t<0x40020400, 0x00000001, 27, ro_t> TEIF7;
        };
        /*
            DMA interrupt flag clear register
          (DMA_IFCR)
         */
        namespace IFCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020404, 0xffffffff, 0, wo_t> IFCR_REG;
            /*
                Channel 1 Global interrupt
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 0, wo_t> CGIF1;
            /*
                Channel 1 Transfer Complete
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 1, wo_t> CTCIF1;
            /*
                Channel 1 Half Transfer
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 2, wo_t> CHTIF1;
            /*
                Channel 1 Transfer Error
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 3, wo_t> CTEIF1;
            /*
                Channel 2 Global interrupt
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 4, wo_t> CGIF2;
            /*
                Channel 2 Transfer Complete
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 5, wo_t> CTCIF2;
            /*
                Channel 2 Half Transfer
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 6, wo_t> CHTIF2;
            /*
                Channel 2 Transfer Error
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 7, wo_t> CTEIF2;
            /*
                Channel 3 Global interrupt
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 8, wo_t> CGIF3;
            /*
                Channel 3 Transfer Complete
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 9, wo_t> CTCIF3;
            /*
                Channel 3 Half Transfer
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 10, wo_t> CHTIF3;
            /*
                Channel 3 Transfer Error
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 11, wo_t> CTEIF3;
            /*
                Channel 4 Global interrupt
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 12, wo_t> CGIF4;
            /*
                Channel 4 Transfer Complete
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 13, wo_t> CTCIF4;
            /*
                Channel 4 Half Transfer
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 14, wo_t> CHTIF4;
            /*
                Channel 4 Transfer Error
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 15, wo_t> CTEIF4;
            /*
                Channel 5 Global interrupt
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 16, wo_t> CGIF5;
            /*
                Channel 5 Transfer Complete
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 17, wo_t> CTCIF5;
            /*
                Channel 5 Half Transfer
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 18, wo_t> CHTIF5;
            /*
                Channel 5 Transfer Error
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 19, wo_t> CTEIF5;
            /*
                Channel 6 Global interrupt
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 20, wo_t> CGIF6;
            /*
                Channel 6 Transfer Complete
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 21, wo_t> CTCIF6;
            /*
                Channel 6 Half Transfer
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 22, wo_t> CHTIF6;
            /*
                Channel 6 Transfer Error
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 23, wo_t> CTEIF6;
            /*
                Channel 7 Global interrupt
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 24, wo_t> CGIF7;
            /*
                Channel 7 Transfer Complete
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 25, wo_t> CTCIF7;
            /*
                Channel 7 Half Transfer
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 26, wo_t> CHTIF7;
            /*
                Channel 7 Transfer Error
              clear
             */
            typedef reg_t<0x40020404, 0x00000001, 27, wo_t> CTEIF7;
        };
        /*
            DMA channel configuration register
          (DMA_CCR)
         */
        namespace CCR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020408, 0xffffffff, 0, rw_t> CCR1_REG;
            /*
                Channel enable
             */
            typedef reg_t<0x40020408, 0x00000001, 0, rw_t> EN;
            /*
                Transfer complete interrupt
              enable
             */
            typedef reg_t<0x40020408, 0x00000001, 1, rw_t> TCIE;
            /*
                Half Transfer interrupt
              enable
             */
            typedef reg_t<0x40020408, 0x00000001, 2, rw_t> HTIE;
            /*
                Transfer error interrupt
              enable
             */
            typedef reg_t<0x40020408, 0x00000001, 3, rw_t> TEIE;
            /*
                Data transfer direction
             */
            typedef reg_t<0x40020408, 0x00000001, 4, rw_t> DIR;
            /*
                Circular mode
             */
            typedef reg_t<0x40020408, 0x00000001, 5, rw_t> CIRC;
            /*
                Peripheral increment mode
             */
            typedef reg_t<0x40020408, 0x00000001, 6, rw_t> PINC;
            /*
                Memory increment mode
             */
            typedef reg_t<0x40020408, 0x00000001, 7, rw_t> MINC;
            /*
                Peripheral size
             */
            typedef reg_t<0x40020408, 0x00000003, 8, rw_t> PSIZE;
            /*
                Memory size
             */
            typedef reg_t<0x40020408, 0x00000003, 10, rw_t> MSIZE;
            /*
                Channel Priority level
             */
            typedef reg_t<0x40020408, 0x00000003, 12, rw_t> PL;
            /*
                Memory to memory mode
             */
            typedef reg_t<0x40020408, 0x00000001, 14, rw_t> MEM2MEM;
        };
        /*
            DMA channel 1 number of data
          register
         */
        namespace CNDTR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4002040c, 0xffffffff, 0, rw_t> CNDTR1_REG;
            /*
                Number of data to transfer
             */
            typedef reg_t<0x4002040c, 0x0000ffff, 0, rw_t> NDT;
        };
        /*
            DMA channel 1 peripheral address
          register
         */
        namespace CPAR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020410, 0xffffffff, 0, rw_t> CPAR1_REG;
            /*
                Peripheral address
             */
            typedef reg_t<0x40020410, 0xffffffff, 0, rw_t> PA;
        };
        /*
            DMA channel 1 memory address
          register
         */
        namespace CMAR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020414, 0xffffffff, 0, rw_t> CMAR1_REG;
            /*
                Memory address
             */
            typedef reg_t<0x40020414, 0xffffffff, 0, rw_t> MA;
        };
        /*
            DMA channel configuration register
          (DMA_CCR)
         */
        namespace CCR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4002041c, 0xffffffff, 0, rw_t> CCR2_REG;
            /*
                Channel enable
             */
            typedef reg_t<0x4002041c, 0x00000001, 0, rw_t> EN;
            /*
                Transfer complete interrupt
              enable
             */
            typedef reg_t<0x4002041c, 0x00000001, 1, rw_t> TCIE;
            /*
                Half Transfer interrupt
              enable
             */
            typedef reg_t<0x4002041c, 0x00000001, 2, rw_t> HTIE;
            /*
                Transfer error interrupt
              enable
             */
            typedef reg_t<0x4002041c, 0x00000001, 3, rw_t> TEIE;
            /*
                Data transfer direction
             */
            typedef reg_t<0x4002041c, 0x00000001, 4, rw_t> DIR;
            /*
                Circular mode
             */
            typedef reg_t<0x4002041c, 0x00000001, 5, rw_t> CIRC;
            /*
                Peripheral increment mode
             */
            typedef reg_t<0x4002041c, 0x00000001, 6, rw_t> PINC;
            /*
                Memory increment mode
             */
            typedef reg_t<0x4002041c, 0x00000001, 7, rw_t> MINC;
            /*
                Peripheral size
             */
            typedef reg_t<0x4002041c, 0x00000003, 8, rw_t> PSIZE;
            /*
                Memory size
             */
            typedef reg_t<0x4002041c, 0x00000003, 10, rw_t> MSIZE;
            /*
                Channel Priority level
             */
            typedef reg_t<0x4002041c, 0x00000003, 12, rw_t> PL;
            /*
                Memory to memory mode
             */
            typedef reg_t<0x4002041c, 0x00000001, 14, rw_t> MEM2MEM;
        };
        /*
            DMA channel 2 number of data
          register
         */
        namespace CNDTR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020420, 0xffffffff, 0, rw_t> CNDTR2_REG;
            /*
                Number of data to transfer
             */
            typedef reg_t<0x40020420, 0x0000ffff, 0, rw_t> NDT;
        };
        /*
            DMA channel 2 peripheral address
          register
         */
        namespace CPAR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020424, 0xffffffff, 0, rw_t> CPAR2_REG;
            /*
                Peripheral address
             */
            typedef reg_t<0x40020424, 0xffffffff, 0, rw_t> PA;
        };
        /*
            DMA channel 2 memory address
          register
         */
        namespace CMAR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020428, 0xffffffff, 0, rw_t> CMAR2_REG;
            /*
                Memory address
             */
            typedef reg_t<0x40020428, 0xffffffff, 0, rw_t> MA;
        };
        /*
            DMA channel configuration register
          (DMA_CCR)
         */
        namespace CCR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020430, 0xffffffff, 0, rw_t> CCR3_REG;
            /*
                Channel enable
             */
            typedef reg_t<0x40020430, 0x00000001, 0, rw_t> EN;
            /*
                Transfer complete interrupt
              enable
             */
            typedef reg_t<0x40020430, 0x00000001, 1, rw_t> TCIE;
            /*
                Half Transfer interrupt
              enable
             */
            typedef reg_t<0x40020430, 0x00000001, 2, rw_t> HTIE;
            /*
                Transfer error interrupt
              enable
             */
            typedef reg_t<0x40020430, 0x00000001, 3, rw_t> TEIE;
            /*
                Data transfer direction
             */
            typedef reg_t<0x40020430, 0x00000001, 4, rw_t> DIR;
            /*
                Circular mode
             */
            typedef reg_t<0x40020430, 0x00000001, 5, rw_t> CIRC;
            /*
                Peripheral increment mode
             */
            typedef reg_t<0x40020430, 0x00000001, 6, rw_t> PINC;
            /*
                Memory increment mode
             */
            typedef reg_t<0x40020430, 0x00000001, 7, rw_t> MINC;
            /*
                Peripheral size
             */
            typedef reg_t<0x40020430, 0x00000003, 8, rw_t> PSIZE;
            /*
                Memory size
             */
            typedef reg_t<0x40020430, 0x00000003, 10, rw_t> MSIZE;
            /*
                Channel Priority level
             */
            typedef reg_t<0x40020430, 0x00000003, 12, rw_t> PL;
            /*
                Memory to memory mode
             */
            typedef reg_t<0x40020430, 0x00000001, 14, rw_t> MEM2MEM;
        };
        /*
            DMA channel 3 number of data
          register
         */
        namespace CNDTR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020434, 0xffffffff, 0, rw_t> CNDTR3_REG;
            /*
                Number of data to transfer
             */
            typedef reg_t<0x40020434, 0x0000ffff, 0, rw_t> NDT;
        };
        /*
            DMA channel 3 peripheral address
          register
         */
        namespace CPAR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020438, 0xffffffff, 0, rw_t> CPAR3_REG;
            /*
                Peripheral address
             */
            typedef reg_t<0x40020438, 0xffffffff, 0, rw_t> PA;
        };
        /*
            DMA channel 3 memory address
          register
         */
        namespace CMAR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4002043c, 0xffffffff, 0, rw_t> CMAR3_REG;
            /*
                Memory address
             */
            typedef reg_t<0x4002043c, 0xffffffff, 0, rw_t> MA;
        };
        /*
            DMA channel configuration register
          (DMA_CCR)
         */
        namespace CCR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020444, 0xffffffff, 0, rw_t> CCR4_REG;
            /*
                Channel enable
             */
            typedef reg_t<0x40020444, 0x00000001, 0, rw_t> EN;
            /*
                Transfer complete interrupt
              enable
             */
            typedef reg_t<0x40020444, 0x00000001, 1, rw_t> TCIE;
            /*
                Half Transfer interrupt
              enable
             */
            typedef reg_t<0x40020444, 0x00000001, 2, rw_t> HTIE;
            /*
                Transfer error interrupt
              enable
             */
            typedef reg_t<0x40020444, 0x00000001, 3, rw_t> TEIE;
            /*
                Data transfer direction
             */
            typedef reg_t<0x40020444, 0x00000001, 4, rw_t> DIR;
            /*
                Circular mode
             */
            typedef reg_t<0x40020444, 0x00000001, 5, rw_t> CIRC;
            /*
                Peripheral increment mode
             */
            typedef reg_t<0x40020444, 0x00000001, 6, rw_t> PINC;
            /*
                Memory increment mode
             */
            typedef reg_t<0x40020444, 0x00000001, 7, rw_t> MINC;
            /*
                Peripheral size
             */
            typedef reg_t<0x40020444, 0x00000003, 8, rw_t> PSIZE;
            /*
                Memory size
             */
            typedef reg_t<0x40020444, 0x00000003, 10, rw_t> MSIZE;
            /*
                Channel Priority level
             */
            typedef reg_t<0x40020444, 0x00000003, 12, rw_t> PL;
            /*
                Memory to memory mode
             */
            typedef reg_t<0x40020444, 0x00000001, 14, rw_t> MEM2MEM;
        };
        /*
            DMA channel 4 number of data
          register
         */
        namespace CNDTR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020448, 0xffffffff, 0, rw_t> CNDTR4_REG;
            /*
                Number of data to transfer
             */
            typedef reg_t<0x40020448, 0x0000ffff, 0, rw_t> NDT;
        };
        /*
            DMA channel 4 peripheral address
          register
         */
        namespace CPAR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4002044c, 0xffffffff, 0, rw_t> CPAR4_REG;
            /*
                Peripheral address
             */
            typedef reg_t<0x4002044c, 0xffffffff, 0, rw_t> PA;
        };
        /*
            DMA channel 4 memory address
          register
         */
        namespace CMAR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020450, 0xffffffff, 0, rw_t> CMAR4_REG;
            /*
                Memory address
             */
            typedef reg_t<0x40020450, 0xffffffff, 0, rw_t> MA;
        };
        /*
            DMA channel configuration register
          (DMA_CCR)
         */
        namespace CCR5 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020458, 0xffffffff, 0, rw_t> CCR5_REG;
            /*
                Channel enable
             */
            typedef reg_t<0x40020458, 0x00000001, 0, rw_t> EN;
            /*
                Transfer complete interrupt
              enable
             */
            typedef reg_t<0x40020458, 0x00000001, 1, rw_t> TCIE;
            /*
                Half Transfer interrupt
              enable
             */
            typedef reg_t<0x40020458, 0x00000001, 2, rw_t> HTIE;
            /*
                Transfer error interrupt
              enable
             */
            typedef reg_t<0x40020458, 0x00000001, 3, rw_t> TEIE;
            /*
                Data transfer direction
             */
            typedef reg_t<0x40020458, 0x00000001, 4, rw_t> DIR;
            /*
                Circular mode
             */
            typedef reg_t<0x40020458, 0x00000001, 5, rw_t> CIRC;
            /*
                Peripheral increment mode
             */
            typedef reg_t<0x40020458, 0x00000001, 6, rw_t> PINC;
            /*
                Memory increment mode
             */
            typedef reg_t<0x40020458, 0x00000001, 7, rw_t> MINC;
            /*
                Peripheral size
             */
            typedef reg_t<0x40020458, 0x00000003, 8, rw_t> PSIZE;
            /*
                Memory size
             */
            typedef reg_t<0x40020458, 0x00000003, 10, rw_t> MSIZE;
            /*
                Channel Priority level
             */
            typedef reg_t<0x40020458, 0x00000003, 12, rw_t> PL;
            /*
                Memory to memory mode
             */
            typedef reg_t<0x40020458, 0x00000001, 14, rw_t> MEM2MEM;
        };
        /*
            DMA channel 5 number of data
          register
         */
        namespace CNDTR5 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4002045c, 0xffffffff, 0, rw_t> CNDTR5_REG;
            /*
                Number of data to transfer
             */
            typedef reg_t<0x4002045c, 0x0000ffff, 0, rw_t> NDT;
        };
        /*
            DMA channel 5 peripheral address
          register
         */
        namespace CPAR5 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020460, 0xffffffff, 0, rw_t> CPAR5_REG;
            /*
                Peripheral address
             */
            typedef reg_t<0x40020460, 0xffffffff, 0, rw_t> PA;
        };
        /*
            DMA channel 5 memory address
          register
         */
        namespace CMAR5 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020464, 0xffffffff, 0, rw_t> CMAR5_REG;
            /*
                Memory address
             */
            typedef reg_t<0x40020464, 0xffffffff, 0, rw_t> MA;
        };
        /*
            DMA channel configuration register
          (DMA_CCR)
         */
        namespace CCR6 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4002046c, 0xffffffff, 0, rw_t> CCR6_REG;
            /*
                Channel enable
             */
            typedef reg_t<0x4002046c, 0x00000001, 0, rw_t> EN;
            /*
                Transfer complete interrupt
              enable
             */
            typedef reg_t<0x4002046c, 0x00000001, 1, rw_t> TCIE;
            /*
                Half Transfer interrupt
              enable
             */
            typedef reg_t<0x4002046c, 0x00000001, 2, rw_t> HTIE;
            /*
                Transfer error interrupt
              enable
             */
            typedef reg_t<0x4002046c, 0x00000001, 3, rw_t> TEIE;
            /*
                Data transfer direction
             */
            typedef reg_t<0x4002046c, 0x00000001, 4, rw_t> DIR;
            /*
                Circular mode
             */
            typedef reg_t<0x4002046c, 0x00000001, 5, rw_t> CIRC;
            /*
                Peripheral increment mode
             */
            typedef reg_t<0x4002046c, 0x00000001, 6, rw_t> PINC;
            /*
                Memory increment mode
             */
            typedef reg_t<0x4002046c, 0x00000001, 7, rw_t> MINC;
            /*
                Peripheral size
             */
            typedef reg_t<0x4002046c, 0x00000003, 8, rw_t> PSIZE;
            /*
                Memory size
             */
            typedef reg_t<0x4002046c, 0x00000003, 10, rw_t> MSIZE;
            /*
                Channel Priority level
             */
            typedef reg_t<0x4002046c, 0x00000003, 12, rw_t> PL;
            /*
                Memory to memory mode
             */
            typedef reg_t<0x4002046c, 0x00000001, 14, rw_t> MEM2MEM;
        };
        /*
            DMA channel 6 number of data
          register
         */
        namespace CNDTR6 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020470, 0xffffffff, 0, rw_t> CNDTR6_REG;
            /*
                Number of data to transfer
             */
            typedef reg_t<0x40020470, 0x0000ffff, 0, rw_t> NDT;
        };
        /*
            DMA channel 6 peripheral address
          register
         */
        namespace CPAR6 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020474, 0xffffffff, 0, rw_t> CPAR6_REG;
            /*
                Peripheral address
             */
            typedef reg_t<0x40020474, 0xffffffff, 0, rw_t> PA;
        };
        /*
            DMA channel 6 memory address
          register
         */
        namespace CMAR6 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020478, 0xffffffff, 0, rw_t> CMAR6_REG;
            /*
                Memory address
             */
            typedef reg_t<0x40020478, 0xffffffff, 0, rw_t> MA;
        };
        /*
            DMA channel configuration register
          (DMA_CCR)
         */
        namespace CCR7 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020480, 0xffffffff, 0, rw_t> CCR7_REG;
            /*
                Channel enable
             */
            typedef reg_t<0x40020480, 0x00000001, 0, rw_t> EN;
            /*
                Transfer complete interrupt
              enable
             */
            typedef reg_t<0x40020480, 0x00000001, 1, rw_t> TCIE;
            /*
                Half Transfer interrupt
              enable
             */
            typedef reg_t<0x40020480, 0x00000001, 2, rw_t> HTIE;
            /*
                Transfer error interrupt
              enable
             */
            typedef reg_t<0x40020480, 0x00000001, 3, rw_t> TEIE;
            /*
                Data transfer direction
             */
            typedef reg_t<0x40020480, 0x00000001, 4, rw_t> DIR;
            /*
                Circular mode
             */
            typedef reg_t<0x40020480, 0x00000001, 5, rw_t> CIRC;
            /*
                Peripheral increment mode
             */
            typedef reg_t<0x40020480, 0x00000001, 6, rw_t> PINC;
            /*
                Memory increment mode
             */
            typedef reg_t<0x40020480, 0x00000001, 7, rw_t> MINC;
            /*
                Peripheral size
             */
            typedef reg_t<0x40020480, 0x00000003, 8, rw_t> PSIZE;
            /*
                Memory size
             */
            typedef reg_t<0x40020480, 0x00000003, 10, rw_t> MSIZE;
            /*
                Channel Priority level
             */
            typedef reg_t<0x40020480, 0x00000003, 12, rw_t> PL;
            /*
                Memory to memory mode
             */
            typedef reg_t<0x40020480, 0x00000001, 14, rw_t> MEM2MEM;
        };
        /*
            DMA channel 7 number of data
          register
         */
        namespace CNDTR7 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020484, 0xffffffff, 0, rw_t> CNDTR7_REG;
            /*
                Number of data to transfer
             */
            typedef reg_t<0x40020484, 0x0000ffff, 0, rw_t> NDT;
        };
        /*
            DMA channel 7 peripheral address
          register
         */
        namespace CPAR7 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40020488, 0xffffffff, 0, rw_t> CPAR7_REG;
            /*
                Peripheral address
             */
            typedef reg_t<0x40020488, 0xffffffff, 0, rw_t> PA;
        };
        /*
            DMA channel 7 memory address
          register
         */
        namespace CMAR7 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4002048c, 0xffffffff, 0, rw_t> CMAR7_REG;
            /*
                Memory address
             */
            typedef reg_t<0x4002048c, 0xffffffff, 0, rw_t> MA;
        };
    };
    /*
        General purpose timer
     */
    namespace TIM2 {
        /*
            control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000000, 0xffffffff, 0, rw_t> CR1_REG;
            /*
                Counter enable
             */
            typedef reg_t<0x40000000, 0x00000001, 0, rw_t> CEN;
            /*
                Update disable
             */
            typedef reg_t<0x40000000, 0x00000001, 1, rw_t> UDIS;
            /*
                Update request source
             */
            typedef reg_t<0x40000000, 0x00000001, 2, rw_t> URS;
            /*
                One-pulse mode
             */
            typedef reg_t<0x40000000, 0x00000001, 3, rw_t> OPM;
            /*
                Direction
             */
            typedef reg_t<0x40000000, 0x00000001, 4, rw_t> DIR;
            /*
                Center-aligned mode
              selection
             */
            typedef reg_t<0x40000000, 0x00000003, 5, rw_t> CMS;
            /*
                Auto-reload preload enable
             */
            typedef reg_t<0x40000000, 0x00000001, 7, rw_t> ARPE;
            /*
                Clock division
             */
            typedef reg_t<0x40000000, 0x00000003, 8, rw_t> CKD;
            /*
                UIF status bit remapping
             */
            typedef reg_t<0x40000000, 0x00000001, 11, rw_t> UIFREMAP;
        };
        /*
            control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000004, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                TI1 selection
             */
            typedef reg_t<0x40000004, 0x00000001, 7, rw_t> TI1S;
            /*
                Master mode selection
             */
            typedef reg_t<0x40000004, 0x00000007, 4, rw_t> MMS;
            /*
                Capture/compare DMA
              selection
             */
            typedef reg_t<0x40000004, 0x00000001, 3, rw_t> CCDS;
        };
        /*
            slave mode control register
         */
        namespace SMCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000008, 0xffffffff, 0, rw_t> SMCR_REG;
            /*
                Slave mode selection
             */
            typedef reg_t<0x40000008, 0x00000007, 0, rw_t> SMS;
            /*
                OCREF clear selection
             */
            typedef reg_t<0x40000008, 0x00000001, 3, rw_t> OCCS;
            /*
                Trigger selection
             */
            typedef reg_t<0x40000008, 0x00000007, 4, rw_t> TS;
            /*
                Master/Slave mode
             */
            typedef reg_t<0x40000008, 0x00000001, 7, rw_t> MSM;
            /*
                External trigger filter
             */
            typedef reg_t<0x40000008, 0x0000000f, 8, rw_t> ETF;
            /*
                External trigger prescaler
             */
            typedef reg_t<0x40000008, 0x00000003, 12, rw_t> ETPS;
            /*
                External clock enable
             */
            typedef reg_t<0x40000008, 0x00000001, 14, rw_t> ECE;
            /*
                External trigger polarity
             */
            typedef reg_t<0x40000008, 0x00000001, 15, rw_t> ETP;
            /*
                Slave mode selection bit3
             */
            typedef reg_t<0x40000008, 0x00000001, 16, rw_t> SMS_3;
        };
        /*
            DMA/Interrupt enable register
         */
        namespace DIER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000000c, 0xffffffff, 0, rw_t> DIER_REG;
            /*
                Trigger DMA request enable
             */
            typedef reg_t<0x4000000c, 0x00000001, 14, rw_t> TDE;
            /*
                Capture/Compare 4 DMA request
              enable
             */
            typedef reg_t<0x4000000c, 0x00000001, 12, rw_t> CC4DE;
            /*
                Capture/Compare 3 DMA request
              enable
             */
            typedef reg_t<0x4000000c, 0x00000001, 11, rw_t> CC3DE;
            /*
                Capture/Compare 2 DMA request
              enable
             */
            typedef reg_t<0x4000000c, 0x00000001, 10, rw_t> CC2DE;
            /*
                Capture/Compare 1 DMA request
              enable
             */
            typedef reg_t<0x4000000c, 0x00000001, 9, rw_t> CC1DE;
            /*
                Update DMA request enable
             */
            typedef reg_t<0x4000000c, 0x00000001, 8, rw_t> UDE;
            /*
                Trigger interrupt enable
             */
            typedef reg_t<0x4000000c, 0x00000001, 6, rw_t> TIE;
            /*
                Capture/Compare 4 interrupt
              enable
             */
            typedef reg_t<0x4000000c, 0x00000001, 4, rw_t> CC4IE;
            /*
                Capture/Compare 3 interrupt
              enable
             */
            typedef reg_t<0x4000000c, 0x00000001, 3, rw_t> CC3IE;
            /*
                Capture/Compare 2 interrupt
              enable
             */
            typedef reg_t<0x4000000c, 0x00000001, 2, rw_t> CC2IE;
            /*
                Capture/Compare 1 interrupt
              enable
             */
            typedef reg_t<0x4000000c, 0x00000001, 1, rw_t> CC1IE;
            /*
                Update interrupt enable
             */
            typedef reg_t<0x4000000c, 0x00000001, 0, rw_t> UIE;
        };
        /*
            status register
         */
        namespace SR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000010, 0xffffffff, 0, rw_t> SR_REG;
            /*
                Capture/Compare 4 overcapture
              flag
             */
            typedef reg_t<0x40000010, 0x00000001, 12, rw_t> CC4OF;
            /*
                Capture/Compare 3 overcapture
              flag
             */
            typedef reg_t<0x40000010, 0x00000001, 11, rw_t> CC3OF;
            /*
                Capture/compare 2 overcapture
              flag
             */
            typedef reg_t<0x40000010, 0x00000001, 10, rw_t> CC2OF;
            /*
                Capture/Compare 1 overcapture
              flag
             */
            typedef reg_t<0x40000010, 0x00000001, 9, rw_t> CC1OF;
            /*
                Trigger interrupt flag
             */
            typedef reg_t<0x40000010, 0x00000001, 6, rw_t> TIF;
            /*
                Capture/Compare 4 interrupt
              flag
             */
            typedef reg_t<0x40000010, 0x00000001, 4, rw_t> CC4IF;
            /*
                Capture/Compare 3 interrupt
              flag
             */
            typedef reg_t<0x40000010, 0x00000001, 3, rw_t> CC3IF;
            /*
                Capture/Compare 2 interrupt
              flag
             */
            typedef reg_t<0x40000010, 0x00000001, 2, rw_t> CC2IF;
            /*
                Capture/compare 1 interrupt
              flag
             */
            typedef reg_t<0x40000010, 0x00000001, 1, rw_t> CC1IF;
            /*
                Update interrupt flag
             */
            typedef reg_t<0x40000010, 0x00000001, 0, rw_t> UIF;
        };
        /*
            event generation register
         */
        namespace EGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000014, 0xffffffff, 0, wo_t> EGR_REG;
            /*
                Trigger generation
             */
            typedef reg_t<0x40000014, 0x00000001, 6, wo_t> TG;
            /*
                Capture/compare 4
              generation
             */
            typedef reg_t<0x40000014, 0x00000001, 4, wo_t> CC4G;
            /*
                Capture/compare 3
              generation
             */
            typedef reg_t<0x40000014, 0x00000001, 3, wo_t> CC3G;
            /*
                Capture/compare 2
              generation
             */
            typedef reg_t<0x40000014, 0x00000001, 2, wo_t> CC2G;
            /*
                Capture/compare 1
              generation
             */
            typedef reg_t<0x40000014, 0x00000001, 1, wo_t> CC1G;
            /*
                Update generation
             */
            typedef reg_t<0x40000014, 0x00000001, 0, wo_t> UG;
        };
        /*
            capture/compare mode register 1 (output
          mode)
         */
        namespace CCMR1_Output {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000018, 0xffffffff, 0, rw_t> CCMR1_Output_REG;
            /*
                Capture/Compare 1
              selection
             */
            typedef reg_t<0x40000018, 0x00000003, 0, rw_t> CC1S;
            /*
                Output compare 1 fast
              enable
             */
            typedef reg_t<0x40000018, 0x00000001, 2, rw_t> OC1FE;
            /*
                Output compare 1 preload
              enable
             */
            typedef reg_t<0x40000018, 0x00000001, 3, rw_t> OC1PE;
            /*
                Output compare 1 mode
             */
            typedef reg_t<0x40000018, 0x00000007, 4, rw_t> OC1M;
            /*
                Output compare 1 clear
              enable
             */
            typedef reg_t<0x40000018, 0x00000001, 7, rw_t> OC1CE;
            /*
                Capture/Compare 2
              selection
             */
            typedef reg_t<0x40000018, 0x00000003, 8, rw_t> CC2S;
            /*
                Output compare 2 fast
              enable
             */
            typedef reg_t<0x40000018, 0x00000001, 10, rw_t> OC2FE;
            /*
                Output compare 2 preload
              enable
             */
            typedef reg_t<0x40000018, 0x00000001, 11, rw_t> OC2PE;
            /*
                Output compare 2 mode
             */
            typedef reg_t<0x40000018, 0x00000007, 12, rw_t> OC2M;
            /*
                Output compare 2 clear
              enable
             */
            typedef reg_t<0x40000018, 0x00000001, 15, rw_t> OC2CE;
            /*
                Output compare 1 mode bit
              3
             */
            typedef reg_t<0x40000018, 0x00000001, 16, rw_t> OC1M_3;
            /*
                Output compare 2 mode bit
              3
             */
            typedef reg_t<0x40000018, 0x00000001, 24, rw_t> OC2M_3;
        };
        /*
            capture/compare mode register 1 (input
          mode)
         */
        namespace CCMR1_Input {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000018, 0xffffffff, 0, rw_t> CCMR1_Input_REG;
            /*
                Input capture 2 filter
             */
            typedef reg_t<0x40000018, 0x0000000f, 12, rw_t> IC2F;
            /*
                Input capture 2 prescaler
             */
            typedef reg_t<0x40000018, 0x00000003, 10, rw_t> IC2PSC;
            /*
                Capture/compare 2
              selection
             */
            typedef reg_t<0x40000018, 0x00000003, 8, rw_t> CC2S;
            /*
                Input capture 1 filter
             */
            typedef reg_t<0x40000018, 0x0000000f, 4, rw_t> IC1F;
            /*
                Input capture 1 prescaler
             */
            typedef reg_t<0x40000018, 0x00000003, 2, rw_t> IC1PSC;
            /*
                Capture/Compare 1
              selection
             */
            typedef reg_t<0x40000018, 0x00000003, 0, rw_t> CC1S;
        };
        /*
            capture/compare mode register 2 (output
          mode)
         */
        namespace CCMR2_Output {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000001c, 0xffffffff, 0, rw_t> CCMR2_Output_REG;
            /*
                Capture/Compare 3
              selection
             */
            typedef reg_t<0x4000001c, 0x00000003, 0, rw_t> CC3S;
            /*
                Output compare 3 fast
              enable
             */
            typedef reg_t<0x4000001c, 0x00000001, 2, rw_t> OC3FE;
            /*
                Output compare 3 preload
              enable
             */
            typedef reg_t<0x4000001c, 0x00000001, 3, rw_t> OC3PE;
            /*
                Output compare 3 mode
             */
            typedef reg_t<0x4000001c, 0x00000007, 4, rw_t> OC3M;
            /*
                Output compare 3 clear
              enable
             */
            typedef reg_t<0x4000001c, 0x00000001, 7, rw_t> OC3CE;
            /*
                Capture/Compare 4
              selection
             */
            typedef reg_t<0x4000001c, 0x00000003, 8, rw_t> CC4S;
            /*
                Output compare 4 fast
              enable
             */
            typedef reg_t<0x4000001c, 0x00000001, 10, rw_t> OC4FE;
            /*
                Output compare 4 preload
              enable
             */
            typedef reg_t<0x4000001c, 0x00000001, 11, rw_t> OC4PE;
            /*
                Output compare 4 mode
             */
            typedef reg_t<0x4000001c, 0x00000007, 12, rw_t> OC4M;
            /*
                Output compare 4 clear
              enable
             */
            typedef reg_t<0x4000001c, 0x00000001, 15, rw_t> O24CE;
            /*
                Output compare 3 mode bit3
             */
            typedef reg_t<0x4000001c, 0x00000001, 16, rw_t> OC3M_3;
            /*
                Output compare 4 mode bit3
             */
            typedef reg_t<0x4000001c, 0x00000001, 24, rw_t> OC4M_3;
        };
        /*
            capture/compare mode register 2 (input
          mode)
         */
        namespace CCMR2_Input {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000001c, 0xffffffff, 0, rw_t> CCMR2_Input_REG;
            /*
                Input capture 4 filter
             */
            typedef reg_t<0x4000001c, 0x0000000f, 12, rw_t> IC4F;
            /*
                Input capture 4 prescaler
             */
            typedef reg_t<0x4000001c, 0x00000003, 10, rw_t> IC4PSC;
            /*
                Capture/Compare 4
              selection
             */
            typedef reg_t<0x4000001c, 0x00000003, 8, rw_t> CC4S;
            /*
                Input capture 3 filter
             */
            typedef reg_t<0x4000001c, 0x0000000f, 4, rw_t> IC3F;
            /*
                Input capture 3 prescaler
             */
            typedef reg_t<0x4000001c, 0x00000003, 2, rw_t> IC3PSC;
            /*
                Capture/Compare 3
              selection
             */
            typedef reg_t<0x4000001c, 0x00000003, 0, rw_t> CC3S;
        };
        /*
            capture/compare enable
          register
         */
        namespace CCER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000020, 0xffffffff, 0, rw_t> CCER_REG;
            /*
                Capture/Compare 1 output
              enable
             */
            typedef reg_t<0x40000020, 0x00000001, 0, rw_t> CC1E;
            /*
                Capture/Compare 1 output
              Polarity
             */
            typedef reg_t<0x40000020, 0x00000001, 1, rw_t> CC1P;
            /*
                Capture/Compare 1 output
              Polarity
             */
            typedef reg_t<0x40000020, 0x00000001, 3, rw_t> CC1NP;
            /*
                Capture/Compare 2 output
              enable
             */
            typedef reg_t<0x40000020, 0x00000001, 4, rw_t> CC2E;
            /*
                Capture/Compare 2 output
              Polarity
             */
            typedef reg_t<0x40000020, 0x00000001, 5, rw_t> CC2P;
            /*
                Capture/Compare 2 output
              Polarity
             */
            typedef reg_t<0x40000020, 0x00000001, 7, rw_t> CC2NP;
            /*
                Capture/Compare 3 output
              enable
             */
            typedef reg_t<0x40000020, 0x00000001, 8, rw_t> CC3E;
            /*
                Capture/Compare 3 output
              Polarity
             */
            typedef reg_t<0x40000020, 0x00000001, 9, rw_t> CC3P;
            /*
                Capture/Compare 3 output
              Polarity
             */
            typedef reg_t<0x40000020, 0x00000001, 11, rw_t> CC3NP;
            /*
                Capture/Compare 4 output
              enable
             */
            typedef reg_t<0x40000020, 0x00000001, 12, rw_t> CC4E;
            /*
                Capture/Compare 3 output
              Polarity
             */
            typedef reg_t<0x40000020, 0x00000001, 13, rw_t> CC4P;
            /*
                Capture/Compare 3 output
              Polarity
             */
            typedef reg_t<0x40000020, 0x00000001, 15, rw_t> CC4NP;
        };
        /*
            counter
         */
        namespace CNT {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000024, 0xffffffff, 0, rw_t> CNT_REG;
            /*
                Low counter value
             */
            typedef reg_t<0x40000024, 0x0000ffff, 0, rw_t> CNTL;
            /*
                High counter value
             */
            typedef reg_t<0x40000024, 0x00007fff, 16, rw_t> CNTH;
            /*
                if IUFREMAP=0 than CNT with read write
              access else UIFCPY with read only
              access
             */
            typedef reg_t<0x40000024, 0x00000001, 31, rw_t> CNT_or_UIFCPY;
        };
        /*
            prescaler
         */
        namespace PSC {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000028, 0xffffffff, 0, rw_t> PSC_REG;
            /*
                Prescaler value
             */
            typedef reg_t<0x40000028, 0x0000ffff, 0, rw_t> PSC;
        };
        /*
            auto-reload register
         */
        namespace ARR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000002c, 0xffffffff, 0, rw_t> ARR_REG;
            /*
                Low Auto-reload value
             */
            typedef reg_t<0x4000002c, 0x0000ffff, 0, rw_t> ARRL;
            /*
                High Auto-reload value
             */
            typedef reg_t<0x4000002c, 0x0000ffff, 16, rw_t> ARRH;
        };
        /*
            capture/compare register 1
         */
        namespace CCR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000034, 0xffffffff, 0, rw_t> CCR1_REG;
            /*
                Low Capture/Compare 1
              value
             */
            typedef reg_t<0x40000034, 0x0000ffff, 0, rw_t> CCR1L;
            /*
                High Capture/Compare 1 value (on
              TIM2)
             */
            typedef reg_t<0x40000034, 0x0000ffff, 16, rw_t> CCR1H;
        };
        /*
            capture/compare register 2
         */
        namespace CCR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000038, 0xffffffff, 0, rw_t> CCR2_REG;
            /*
                Low Capture/Compare 2
              value
             */
            typedef reg_t<0x40000038, 0x0000ffff, 0, rw_t> CCR2L;
            /*
                High Capture/Compare 2 value (on
              TIM2)
             */
            typedef reg_t<0x40000038, 0x0000ffff, 16, rw_t> CCR2H;
        };
        /*
            capture/compare register 3
         */
        namespace CCR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000003c, 0xffffffff, 0, rw_t> CCR3_REG;
            /*
                Low Capture/Compare value
             */
            typedef reg_t<0x4000003c, 0x0000ffff, 0, rw_t> CCR3L;
            /*
                High Capture/Compare value (on
              TIM2)
             */
            typedef reg_t<0x4000003c, 0x0000ffff, 16, rw_t> CCR3H;
        };
        /*
            capture/compare register 4
         */
        namespace CCR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000040, 0xffffffff, 0, rw_t> CCR4_REG;
            /*
                Low Capture/Compare value
             */
            typedef reg_t<0x40000040, 0x0000ffff, 0, rw_t> CCR4L;
            /*
                High Capture/Compare value (on
              TIM2)
             */
            typedef reg_t<0x40000040, 0x0000ffff, 16, rw_t> CCR4H;
        };
        /*
            DMA control register
         */
        namespace DCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000048, 0xffffffff, 0, rw_t> DCR_REG;
            /*
                DMA burst length
             */
            typedef reg_t<0x40000048, 0x0000001f, 8, rw_t> DBL;
            /*
                DMA base address
             */
            typedef reg_t<0x40000048, 0x0000001f, 0, rw_t> DBA;
        };
        /*
            DMA address for full transfer
         */
        namespace DMAR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000004c, 0xffffffff, 0, rw_t> DMAR_REG;
            /*
                DMA register for burst
              accesses
             */
            typedef reg_t<0x4000004c, 0x0000ffff, 0, rw_t> DMAB;
        };
    };
    /*
        General purpose timer
     */
    namespace TIM3 {
        /*
            control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000400, 0xffffffff, 0, rw_t> CR1_REG;
            /*
                Counter enable
             */
            typedef reg_t<0x40000400, 0x00000001, 0, rw_t> CEN;
            /*
                Update disable
             */
            typedef reg_t<0x40000400, 0x00000001, 1, rw_t> UDIS;
            /*
                Update request source
             */
            typedef reg_t<0x40000400, 0x00000001, 2, rw_t> URS;
            /*
                One-pulse mode
             */
            typedef reg_t<0x40000400, 0x00000001, 3, rw_t> OPM;
            /*
                Direction
             */
            typedef reg_t<0x40000400, 0x00000001, 4, rw_t> DIR;
            /*
                Center-aligned mode
              selection
             */
            typedef reg_t<0x40000400, 0x00000003, 5, rw_t> CMS;
            /*
                Auto-reload preload enable
             */
            typedef reg_t<0x40000400, 0x00000001, 7, rw_t> ARPE;
            /*
                Clock division
             */
            typedef reg_t<0x40000400, 0x00000003, 8, rw_t> CKD;
            /*
                UIF status bit remapping
             */
            typedef reg_t<0x40000400, 0x00000001, 11, rw_t> UIFREMAP;
        };
        /*
            control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000404, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                TI1 selection
             */
            typedef reg_t<0x40000404, 0x00000001, 7, rw_t> TI1S;
            /*
                Master mode selection
             */
            typedef reg_t<0x40000404, 0x00000007, 4, rw_t> MMS;
            /*
                Capture/compare DMA
              selection
             */
            typedef reg_t<0x40000404, 0x00000001, 3, rw_t> CCDS;
        };
        /*
            slave mode control register
         */
        namespace SMCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000408, 0xffffffff, 0, rw_t> SMCR_REG;
            /*
                Slave mode selection
             */
            typedef reg_t<0x40000408, 0x00000007, 0, rw_t> SMS;
            /*
                OCREF clear selection
             */
            typedef reg_t<0x40000408, 0x00000001, 3, rw_t> OCCS;
            /*
                Trigger selection
             */
            typedef reg_t<0x40000408, 0x00000007, 4, rw_t> TS;
            /*
                Master/Slave mode
             */
            typedef reg_t<0x40000408, 0x00000001, 7, rw_t> MSM;
            /*
                External trigger filter
             */
            typedef reg_t<0x40000408, 0x0000000f, 8, rw_t> ETF;
            /*
                External trigger prescaler
             */
            typedef reg_t<0x40000408, 0x00000003, 12, rw_t> ETPS;
            /*
                External clock enable
             */
            typedef reg_t<0x40000408, 0x00000001, 14, rw_t> ECE;
            /*
                External trigger polarity
             */
            typedef reg_t<0x40000408, 0x00000001, 15, rw_t> ETP;
            /*
                Slave mode selection bit3
             */
            typedef reg_t<0x40000408, 0x00000001, 16, rw_t> SMS_3;
        };
        /*
            DMA/Interrupt enable register
         */
        namespace DIER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000040c, 0xffffffff, 0, rw_t> DIER_REG;
            /*
                Trigger DMA request enable
             */
            typedef reg_t<0x4000040c, 0x00000001, 14, rw_t> TDE;
            /*
                Capture/Compare 4 DMA request
              enable
             */
            typedef reg_t<0x4000040c, 0x00000001, 12, rw_t> CC4DE;
            /*
                Capture/Compare 3 DMA request
              enable
             */
            typedef reg_t<0x4000040c, 0x00000001, 11, rw_t> CC3DE;
            /*
                Capture/Compare 2 DMA request
              enable
             */
            typedef reg_t<0x4000040c, 0x00000001, 10, rw_t> CC2DE;
            /*
                Capture/Compare 1 DMA request
              enable
             */
            typedef reg_t<0x4000040c, 0x00000001, 9, rw_t> CC1DE;
            /*
                Update DMA request enable
             */
            typedef reg_t<0x4000040c, 0x00000001, 8, rw_t> UDE;
            /*
                Trigger interrupt enable
             */
            typedef reg_t<0x4000040c, 0x00000001, 6, rw_t> TIE;
            /*
                Capture/Compare 4 interrupt
              enable
             */
            typedef reg_t<0x4000040c, 0x00000001, 4, rw_t> CC4IE;
            /*
                Capture/Compare 3 interrupt
              enable
             */
            typedef reg_t<0x4000040c, 0x00000001, 3, rw_t> CC3IE;
            /*
                Capture/Compare 2 interrupt
              enable
             */
            typedef reg_t<0x4000040c, 0x00000001, 2, rw_t> CC2IE;
            /*
                Capture/Compare 1 interrupt
              enable
             */
            typedef reg_t<0x4000040c, 0x00000001, 1, rw_t> CC1IE;
            /*
                Update interrupt enable
             */
            typedef reg_t<0x4000040c, 0x00000001, 0, rw_t> UIE;
        };
        /*
            status register
         */
        namespace SR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000410, 0xffffffff, 0, rw_t> SR_REG;
            /*
                Capture/Compare 4 overcapture
              flag
             */
            typedef reg_t<0x40000410, 0x00000001, 12, rw_t> CC4OF;
            /*
                Capture/Compare 3 overcapture
              flag
             */
            typedef reg_t<0x40000410, 0x00000001, 11, rw_t> CC3OF;
            /*
                Capture/compare 2 overcapture
              flag
             */
            typedef reg_t<0x40000410, 0x00000001, 10, rw_t> CC2OF;
            /*
                Capture/Compare 1 overcapture
              flag
             */
            typedef reg_t<0x40000410, 0x00000001, 9, rw_t> CC1OF;
            /*
                Trigger interrupt flag
             */
            typedef reg_t<0x40000410, 0x00000001, 6, rw_t> TIF;
            /*
                Capture/Compare 4 interrupt
              flag
             */
            typedef reg_t<0x40000410, 0x00000001, 4, rw_t> CC4IF;
            /*
                Capture/Compare 3 interrupt
              flag
             */
            typedef reg_t<0x40000410, 0x00000001, 3, rw_t> CC3IF;
            /*
                Capture/Compare 2 interrupt
              flag
             */
            typedef reg_t<0x40000410, 0x00000001, 2, rw_t> CC2IF;
            /*
                Capture/compare 1 interrupt
              flag
             */
            typedef reg_t<0x40000410, 0x00000001, 1, rw_t> CC1IF;
            /*
                Update interrupt flag
             */
            typedef reg_t<0x40000410, 0x00000001, 0, rw_t> UIF;
        };
        /*
            event generation register
         */
        namespace EGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000414, 0xffffffff, 0, wo_t> EGR_REG;
            /*
                Trigger generation
             */
            typedef reg_t<0x40000414, 0x00000001, 6, wo_t> TG;
            /*
                Capture/compare 4
              generation
             */
            typedef reg_t<0x40000414, 0x00000001, 4, wo_t> CC4G;
            /*
                Capture/compare 3
              generation
             */
            typedef reg_t<0x40000414, 0x00000001, 3, wo_t> CC3G;
            /*
                Capture/compare 2
              generation
             */
            typedef reg_t<0x40000414, 0x00000001, 2, wo_t> CC2G;
            /*
                Capture/compare 1
              generation
             */
            typedef reg_t<0x40000414, 0x00000001, 1, wo_t> CC1G;
            /*
                Update generation
             */
            typedef reg_t<0x40000414, 0x00000001, 0, wo_t> UG;
        };
        /*
            capture/compare mode register 1 (output
          mode)
         */
        namespace CCMR1_Output {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000418, 0xffffffff, 0, rw_t> CCMR1_Output_REG;
            /*
                Capture/Compare 1
              selection
             */
            typedef reg_t<0x40000418, 0x00000003, 0, rw_t> CC1S;
            /*
                Output compare 1 fast
              enable
             */
            typedef reg_t<0x40000418, 0x00000001, 2, rw_t> OC1FE;
            /*
                Output compare 1 preload
              enable
             */
            typedef reg_t<0x40000418, 0x00000001, 3, rw_t> OC1PE;
            /*
                Output compare 1 mode
             */
            typedef reg_t<0x40000418, 0x00000007, 4, rw_t> OC1M;
            /*
                Output compare 1 clear
              enable
             */
            typedef reg_t<0x40000418, 0x00000001, 7, rw_t> OC1CE;
            /*
                Capture/Compare 2
              selection
             */
            typedef reg_t<0x40000418, 0x00000003, 8, rw_t> CC2S;
            /*
                Output compare 2 fast
              enable
             */
            typedef reg_t<0x40000418, 0x00000001, 10, rw_t> OC2FE;
            /*
                Output compare 2 preload
              enable
             */
            typedef reg_t<0x40000418, 0x00000001, 11, rw_t> OC2PE;
            /*
                Output compare 2 mode
             */
            typedef reg_t<0x40000418, 0x00000007, 12, rw_t> OC2M;
            /*
                Output compare 2 clear
              enable
             */
            typedef reg_t<0x40000418, 0x00000001, 15, rw_t> OC2CE;
            /*
                Output compare 1 mode bit
              3
             */
            typedef reg_t<0x40000418, 0x00000001, 16, rw_t> OC1M_3;
            /*
                Output compare 2 mode bit
              3
             */
            typedef reg_t<0x40000418, 0x00000001, 24, rw_t> OC2M_3;
        };
        /*
            capture/compare mode register 1 (input
          mode)
         */
        namespace CCMR1_Input {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000418, 0xffffffff, 0, rw_t> CCMR1_Input_REG;
            /*
                Input capture 2 filter
             */
            typedef reg_t<0x40000418, 0x0000000f, 12, rw_t> IC2F;
            /*
                Input capture 2 prescaler
             */
            typedef reg_t<0x40000418, 0x00000003, 10, rw_t> IC2PSC;
            /*
                Capture/compare 2
              selection
             */
            typedef reg_t<0x40000418, 0x00000003, 8, rw_t> CC2S;
            /*
                Input capture 1 filter
             */
            typedef reg_t<0x40000418, 0x0000000f, 4, rw_t> IC1F;
            /*
                Input capture 1 prescaler
             */
            typedef reg_t<0x40000418, 0x00000003, 2, rw_t> IC1PSC;
            /*
                Capture/Compare 1
              selection
             */
            typedef reg_t<0x40000418, 0x00000003, 0, rw_t> CC1S;
        };
        /*
            capture/compare mode register 2 (output
          mode)
         */
        namespace CCMR2_Output {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000041c, 0xffffffff, 0, rw_t> CCMR2_Output_REG;
            /*
                Capture/Compare 3
              selection
             */
            typedef reg_t<0x4000041c, 0x00000003, 0, rw_t> CC3S;
            /*
                Output compare 3 fast
              enable
             */
            typedef reg_t<0x4000041c, 0x00000001, 2, rw_t> OC3FE;
            /*
                Output compare 3 preload
              enable
             */
            typedef reg_t<0x4000041c, 0x00000001, 3, rw_t> OC3PE;
            /*
                Output compare 3 mode
             */
            typedef reg_t<0x4000041c, 0x00000007, 4, rw_t> OC3M;
            /*
                Output compare 3 clear
              enable
             */
            typedef reg_t<0x4000041c, 0x00000001, 7, rw_t> OC3CE;
            /*
                Capture/Compare 4
              selection
             */
            typedef reg_t<0x4000041c, 0x00000003, 8, rw_t> CC4S;
            /*
                Output compare 4 fast
              enable
             */
            typedef reg_t<0x4000041c, 0x00000001, 10, rw_t> OC4FE;
            /*
                Output compare 4 preload
              enable
             */
            typedef reg_t<0x4000041c, 0x00000001, 11, rw_t> OC4PE;
            /*
                Output compare 4 mode
             */
            typedef reg_t<0x4000041c, 0x00000007, 12, rw_t> OC4M;
            /*
                Output compare 4 clear
              enable
             */
            typedef reg_t<0x4000041c, 0x00000001, 15, rw_t> O24CE;
            /*
                Output compare 3 mode bit3
             */
            typedef reg_t<0x4000041c, 0x00000001, 16, rw_t> OC3M_3;
            /*
                Output compare 4 mode bit3
             */
            typedef reg_t<0x4000041c, 0x00000001, 24, rw_t> OC4M_3;
        };
        /*
            capture/compare mode register 2 (input
          mode)
         */
        namespace CCMR2_Input {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000041c, 0xffffffff, 0, rw_t> CCMR2_Input_REG;
            /*
                Input capture 4 filter
             */
            typedef reg_t<0x4000041c, 0x0000000f, 12, rw_t> IC4F;
            /*
                Input capture 4 prescaler
             */
            typedef reg_t<0x4000041c, 0x00000003, 10, rw_t> IC4PSC;
            /*
                Capture/Compare 4
              selection
             */
            typedef reg_t<0x4000041c, 0x00000003, 8, rw_t> CC4S;
            /*
                Input capture 3 filter
             */
            typedef reg_t<0x4000041c, 0x0000000f, 4, rw_t> IC3F;
            /*
                Input capture 3 prescaler
             */
            typedef reg_t<0x4000041c, 0x00000003, 2, rw_t> IC3PSC;
            /*
                Capture/Compare 3
              selection
             */
            typedef reg_t<0x4000041c, 0x00000003, 0, rw_t> CC3S;
        };
        /*
            capture/compare enable
          register
         */
        namespace CCER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000420, 0xffffffff, 0, rw_t> CCER_REG;
            /*
                Capture/Compare 1 output
              enable
             */
            typedef reg_t<0x40000420, 0x00000001, 0, rw_t> CC1E;
            /*
                Capture/Compare 1 output
              Polarity
             */
            typedef reg_t<0x40000420, 0x00000001, 1, rw_t> CC1P;
            /*
                Capture/Compare 1 output
              Polarity
             */
            typedef reg_t<0x40000420, 0x00000001, 3, rw_t> CC1NP;
            /*
                Capture/Compare 2 output
              enable
             */
            typedef reg_t<0x40000420, 0x00000001, 4, rw_t> CC2E;
            /*
                Capture/Compare 2 output
              Polarity
             */
            typedef reg_t<0x40000420, 0x00000001, 5, rw_t> CC2P;
            /*
                Capture/Compare 2 output
              Polarity
             */
            typedef reg_t<0x40000420, 0x00000001, 7, rw_t> CC2NP;
            /*
                Capture/Compare 3 output
              enable
             */
            typedef reg_t<0x40000420, 0x00000001, 8, rw_t> CC3E;
            /*
                Capture/Compare 3 output
              Polarity
             */
            typedef reg_t<0x40000420, 0x00000001, 9, rw_t> CC3P;
            /*
                Capture/Compare 3 output
              Polarity
             */
            typedef reg_t<0x40000420, 0x00000001, 11, rw_t> CC3NP;
            /*
                Capture/Compare 4 output
              enable
             */
            typedef reg_t<0x40000420, 0x00000001, 12, rw_t> CC4E;
            /*
                Capture/Compare 3 output
              Polarity
             */
            typedef reg_t<0x40000420, 0x00000001, 13, rw_t> CC4P;
            /*
                Capture/Compare 3 output
              Polarity
             */
            typedef reg_t<0x40000420, 0x00000001, 15, rw_t> CC4NP;
        };
        /*
            counter
         */
        namespace CNT {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000424, 0xffffffff, 0, rw_t> CNT_REG;
            /*
                Low counter value
             */
            typedef reg_t<0x40000424, 0x0000ffff, 0, rw_t> CNTL;
            /*
                High counter value
             */
            typedef reg_t<0x40000424, 0x00007fff, 16, rw_t> CNTH;
            /*
                if IUFREMAP=0 than CNT with read write
              access else UIFCPY with read only
              access
             */
            typedef reg_t<0x40000424, 0x00000001, 31, rw_t> CNT_or_UIFCPY;
        };
        /*
            prescaler
         */
        namespace PSC {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000428, 0xffffffff, 0, rw_t> PSC_REG;
            /*
                Prescaler value
             */
            typedef reg_t<0x40000428, 0x0000ffff, 0, rw_t> PSC;
        };
        /*
            auto-reload register
         */
        namespace ARR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000042c, 0xffffffff, 0, rw_t> ARR_REG;
            /*
                Low Auto-reload value
             */
            typedef reg_t<0x4000042c, 0x0000ffff, 0, rw_t> ARRL;
            /*
                High Auto-reload value
             */
            typedef reg_t<0x4000042c, 0x0000ffff, 16, rw_t> ARRH;
        };
        /*
            capture/compare register 1
         */
        namespace CCR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000434, 0xffffffff, 0, rw_t> CCR1_REG;
            /*
                Low Capture/Compare 1
              value
             */
            typedef reg_t<0x40000434, 0x0000ffff, 0, rw_t> CCR1L;
            /*
                High Capture/Compare 1 value (on
              TIM2)
             */
            typedef reg_t<0x40000434, 0x0000ffff, 16, rw_t> CCR1H;
        };
        /*
            capture/compare register 2
         */
        namespace CCR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000438, 0xffffffff, 0, rw_t> CCR2_REG;
            /*
                Low Capture/Compare 2
              value
             */
            typedef reg_t<0x40000438, 0x0000ffff, 0, rw_t> CCR2L;
            /*
                High Capture/Compare 2 value (on
              TIM2)
             */
            typedef reg_t<0x40000438, 0x0000ffff, 16, rw_t> CCR2H;
        };
        /*
            capture/compare register 3
         */
        namespace CCR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000043c, 0xffffffff, 0, rw_t> CCR3_REG;
            /*
                Low Capture/Compare value
             */
            typedef reg_t<0x4000043c, 0x0000ffff, 0, rw_t> CCR3L;
            /*
                High Capture/Compare value (on
              TIM2)
             */
            typedef reg_t<0x4000043c, 0x0000ffff, 16, rw_t> CCR3H;
        };
        /*
            capture/compare register 4
         */
        namespace CCR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000440, 0xffffffff, 0, rw_t> CCR4_REG;
            /*
                Low Capture/Compare value
             */
            typedef reg_t<0x40000440, 0x0000ffff, 0, rw_t> CCR4L;
            /*
                High Capture/Compare value (on
              TIM2)
             */
            typedef reg_t<0x40000440, 0x0000ffff, 16, rw_t> CCR4H;
        };
        /*
            DMA control register
         */
        namespace DCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000448, 0xffffffff, 0, rw_t> DCR_REG;
            /*
                DMA burst length
             */
            typedef reg_t<0x40000448, 0x0000001f, 8, rw_t> DBL;
            /*
                DMA base address
             */
            typedef reg_t<0x40000448, 0x0000001f, 0, rw_t> DBA;
        };
        /*
            DMA address for full transfer
         */
        namespace DMAR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000044c, 0xffffffff, 0, rw_t> DMAR_REG;
            /*
                DMA register for burst
              accesses
             */
            typedef reg_t<0x4000044c, 0x0000ffff, 0, rw_t> DMAB;
        };
    };
    /*
        General purpose timer
     */
    namespace TIM4 {
        /*
            control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000800, 0xffffffff, 0, rw_t> CR1_REG;
            /*
                Counter enable
             */
            typedef reg_t<0x40000800, 0x00000001, 0, rw_t> CEN;
            /*
                Update disable
             */
            typedef reg_t<0x40000800, 0x00000001, 1, rw_t> UDIS;
            /*
                Update request source
             */
            typedef reg_t<0x40000800, 0x00000001, 2, rw_t> URS;
            /*
                One-pulse mode
             */
            typedef reg_t<0x40000800, 0x00000001, 3, rw_t> OPM;
            /*
                Direction
             */
            typedef reg_t<0x40000800, 0x00000001, 4, rw_t> DIR;
            /*
                Center-aligned mode
              selection
             */
            typedef reg_t<0x40000800, 0x00000003, 5, rw_t> CMS;
            /*
                Auto-reload preload enable
             */
            typedef reg_t<0x40000800, 0x00000001, 7, rw_t> ARPE;
            /*
                Clock division
             */
            typedef reg_t<0x40000800, 0x00000003, 8, rw_t> CKD;
            /*
                UIF status bit remapping
             */
            typedef reg_t<0x40000800, 0x00000001, 11, rw_t> UIFREMAP;
        };
        /*
            control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000804, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                TI1 selection
             */
            typedef reg_t<0x40000804, 0x00000001, 7, rw_t> TI1S;
            /*
                Master mode selection
             */
            typedef reg_t<0x40000804, 0x00000007, 4, rw_t> MMS;
            /*
                Capture/compare DMA
              selection
             */
            typedef reg_t<0x40000804, 0x00000001, 3, rw_t> CCDS;
        };
        /*
            slave mode control register
         */
        namespace SMCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000808, 0xffffffff, 0, rw_t> SMCR_REG;
            /*
                Slave mode selection
             */
            typedef reg_t<0x40000808, 0x00000007, 0, rw_t> SMS;
            /*
                OCREF clear selection
             */
            typedef reg_t<0x40000808, 0x00000001, 3, rw_t> OCCS;
            /*
                Trigger selection
             */
            typedef reg_t<0x40000808, 0x00000007, 4, rw_t> TS;
            /*
                Master/Slave mode
             */
            typedef reg_t<0x40000808, 0x00000001, 7, rw_t> MSM;
            /*
                External trigger filter
             */
            typedef reg_t<0x40000808, 0x0000000f, 8, rw_t> ETF;
            /*
                External trigger prescaler
             */
            typedef reg_t<0x40000808, 0x00000003, 12, rw_t> ETPS;
            /*
                External clock enable
             */
            typedef reg_t<0x40000808, 0x00000001, 14, rw_t> ECE;
            /*
                External trigger polarity
             */
            typedef reg_t<0x40000808, 0x00000001, 15, rw_t> ETP;
            /*
                Slave mode selection bit3
             */
            typedef reg_t<0x40000808, 0x00000001, 16, rw_t> SMS_3;
        };
        /*
            DMA/Interrupt enable register
         */
        namespace DIER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000080c, 0xffffffff, 0, rw_t> DIER_REG;
            /*
                Trigger DMA request enable
             */
            typedef reg_t<0x4000080c, 0x00000001, 14, rw_t> TDE;
            /*
                Capture/Compare 4 DMA request
              enable
             */
            typedef reg_t<0x4000080c, 0x00000001, 12, rw_t> CC4DE;
            /*
                Capture/Compare 3 DMA request
              enable
             */
            typedef reg_t<0x4000080c, 0x00000001, 11, rw_t> CC3DE;
            /*
                Capture/Compare 2 DMA request
              enable
             */
            typedef reg_t<0x4000080c, 0x00000001, 10, rw_t> CC2DE;
            /*
                Capture/Compare 1 DMA request
              enable
             */
            typedef reg_t<0x4000080c, 0x00000001, 9, rw_t> CC1DE;
            /*
                Update DMA request enable
             */
            typedef reg_t<0x4000080c, 0x00000001, 8, rw_t> UDE;
            /*
                Trigger interrupt enable
             */
            typedef reg_t<0x4000080c, 0x00000001, 6, rw_t> TIE;
            /*
                Capture/Compare 4 interrupt
              enable
             */
            typedef reg_t<0x4000080c, 0x00000001, 4, rw_t> CC4IE;
            /*
                Capture/Compare 3 interrupt
              enable
             */
            typedef reg_t<0x4000080c, 0x00000001, 3, rw_t> CC3IE;
            /*
                Capture/Compare 2 interrupt
              enable
             */
            typedef reg_t<0x4000080c, 0x00000001, 2, rw_t> CC2IE;
            /*
                Capture/Compare 1 interrupt
              enable
             */
            typedef reg_t<0x4000080c, 0x00000001, 1, rw_t> CC1IE;
            /*
                Update interrupt enable
             */
            typedef reg_t<0x4000080c, 0x00000001, 0, rw_t> UIE;
        };
        /*
            status register
         */
        namespace SR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000810, 0xffffffff, 0, rw_t> SR_REG;
            /*
                Capture/Compare 4 overcapture
              flag
             */
            typedef reg_t<0x40000810, 0x00000001, 12, rw_t> CC4OF;
            /*
                Capture/Compare 3 overcapture
              flag
             */
            typedef reg_t<0x40000810, 0x00000001, 11, rw_t> CC3OF;
            /*
                Capture/compare 2 overcapture
              flag
             */
            typedef reg_t<0x40000810, 0x00000001, 10, rw_t> CC2OF;
            /*
                Capture/Compare 1 overcapture
              flag
             */
            typedef reg_t<0x40000810, 0x00000001, 9, rw_t> CC1OF;
            /*
                Trigger interrupt flag
             */
            typedef reg_t<0x40000810, 0x00000001, 6, rw_t> TIF;
            /*
                Capture/Compare 4 interrupt
              flag
             */
            typedef reg_t<0x40000810, 0x00000001, 4, rw_t> CC4IF;
            /*
                Capture/Compare 3 interrupt
              flag
             */
            typedef reg_t<0x40000810, 0x00000001, 3, rw_t> CC3IF;
            /*
                Capture/Compare 2 interrupt
              flag
             */
            typedef reg_t<0x40000810, 0x00000001, 2, rw_t> CC2IF;
            /*
                Capture/compare 1 interrupt
              flag
             */
            typedef reg_t<0x40000810, 0x00000001, 1, rw_t> CC1IF;
            /*
                Update interrupt flag
             */
            typedef reg_t<0x40000810, 0x00000001, 0, rw_t> UIF;
        };
        /*
            event generation register
         */
        namespace EGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000814, 0xffffffff, 0, wo_t> EGR_REG;
            /*
                Trigger generation
             */
            typedef reg_t<0x40000814, 0x00000001, 6, wo_t> TG;
            /*
                Capture/compare 4
              generation
             */
            typedef reg_t<0x40000814, 0x00000001, 4, wo_t> CC4G;
            /*
                Capture/compare 3
              generation
             */
            typedef reg_t<0x40000814, 0x00000001, 3, wo_t> CC3G;
            /*
                Capture/compare 2
              generation
             */
            typedef reg_t<0x40000814, 0x00000001, 2, wo_t> CC2G;
            /*
                Capture/compare 1
              generation
             */
            typedef reg_t<0x40000814, 0x00000001, 1, wo_t> CC1G;
            /*
                Update generation
             */
            typedef reg_t<0x40000814, 0x00000001, 0, wo_t> UG;
        };
        /*
            capture/compare mode register 1 (output
          mode)
         */
        namespace CCMR1_Output {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000818, 0xffffffff, 0, rw_t> CCMR1_Output_REG;
            /*
                Capture/Compare 1
              selection
             */
            typedef reg_t<0x40000818, 0x00000003, 0, rw_t> CC1S;
            /*
                Output compare 1 fast
              enable
             */
            typedef reg_t<0x40000818, 0x00000001, 2, rw_t> OC1FE;
            /*
                Output compare 1 preload
              enable
             */
            typedef reg_t<0x40000818, 0x00000001, 3, rw_t> OC1PE;
            /*
                Output compare 1 mode
             */
            typedef reg_t<0x40000818, 0x00000007, 4, rw_t> OC1M;
            /*
                Output compare 1 clear
              enable
             */
            typedef reg_t<0x40000818, 0x00000001, 7, rw_t> OC1CE;
            /*
                Capture/Compare 2
              selection
             */
            typedef reg_t<0x40000818, 0x00000003, 8, rw_t> CC2S;
            /*
                Output compare 2 fast
              enable
             */
            typedef reg_t<0x40000818, 0x00000001, 10, rw_t> OC2FE;
            /*
                Output compare 2 preload
              enable
             */
            typedef reg_t<0x40000818, 0x00000001, 11, rw_t> OC2PE;
            /*
                Output compare 2 mode
             */
            typedef reg_t<0x40000818, 0x00000007, 12, rw_t> OC2M;
            /*
                Output compare 2 clear
              enable
             */
            typedef reg_t<0x40000818, 0x00000001, 15, rw_t> OC2CE;
            /*
                Output compare 1 mode bit
              3
             */
            typedef reg_t<0x40000818, 0x00000001, 16, rw_t> OC1M_3;
            /*
                Output compare 2 mode bit
              3
             */
            typedef reg_t<0x40000818, 0x00000001, 24, rw_t> OC2M_3;
        };
        /*
            capture/compare mode register 1 (input
          mode)
         */
        namespace CCMR1_Input {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000818, 0xffffffff, 0, rw_t> CCMR1_Input_REG;
            /*
                Input capture 2 filter
             */
            typedef reg_t<0x40000818, 0x0000000f, 12, rw_t> IC2F;
            /*
                Input capture 2 prescaler
             */
            typedef reg_t<0x40000818, 0x00000003, 10, rw_t> IC2PSC;
            /*
                Capture/compare 2
              selection
             */
            typedef reg_t<0x40000818, 0x00000003, 8, rw_t> CC2S;
            /*
                Input capture 1 filter
             */
            typedef reg_t<0x40000818, 0x0000000f, 4, rw_t> IC1F;
            /*
                Input capture 1 prescaler
             */
            typedef reg_t<0x40000818, 0x00000003, 2, rw_t> IC1PSC;
            /*
                Capture/Compare 1
              selection
             */
            typedef reg_t<0x40000818, 0x00000003, 0, rw_t> CC1S;
        };
        /*
            capture/compare mode register 2 (output
          mode)
         */
        namespace CCMR2_Output {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000081c, 0xffffffff, 0, rw_t> CCMR2_Output_REG;
            /*
                Capture/Compare 3
              selection
             */
            typedef reg_t<0x4000081c, 0x00000003, 0, rw_t> CC3S;
            /*
                Output compare 3 fast
              enable
             */
            typedef reg_t<0x4000081c, 0x00000001, 2, rw_t> OC3FE;
            /*
                Output compare 3 preload
              enable
             */
            typedef reg_t<0x4000081c, 0x00000001, 3, rw_t> OC3PE;
            /*
                Output compare 3 mode
             */
            typedef reg_t<0x4000081c, 0x00000007, 4, rw_t> OC3M;
            /*
                Output compare 3 clear
              enable
             */
            typedef reg_t<0x4000081c, 0x00000001, 7, rw_t> OC3CE;
            /*
                Capture/Compare 4
              selection
             */
            typedef reg_t<0x4000081c, 0x00000003, 8, rw_t> CC4S;
            /*
                Output compare 4 fast
              enable
             */
            typedef reg_t<0x4000081c, 0x00000001, 10, rw_t> OC4FE;
            /*
                Output compare 4 preload
              enable
             */
            typedef reg_t<0x4000081c, 0x00000001, 11, rw_t> OC4PE;
            /*
                Output compare 4 mode
             */
            typedef reg_t<0x4000081c, 0x00000007, 12, rw_t> OC4M;
            /*
                Output compare 4 clear
              enable
             */
            typedef reg_t<0x4000081c, 0x00000001, 15, rw_t> O24CE;
            /*
                Output compare 3 mode bit3
             */
            typedef reg_t<0x4000081c, 0x00000001, 16, rw_t> OC3M_3;
            /*
                Output compare 4 mode bit3
             */
            typedef reg_t<0x4000081c, 0x00000001, 24, rw_t> OC4M_3;
        };
        /*
            capture/compare mode register 2 (input
          mode)
         */
        namespace CCMR2_Input {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000081c, 0xffffffff, 0, rw_t> CCMR2_Input_REG;
            /*
                Input capture 4 filter
             */
            typedef reg_t<0x4000081c, 0x0000000f, 12, rw_t> IC4F;
            /*
                Input capture 4 prescaler
             */
            typedef reg_t<0x4000081c, 0x00000003, 10, rw_t> IC4PSC;
            /*
                Capture/Compare 4
              selection
             */
            typedef reg_t<0x4000081c, 0x00000003, 8, rw_t> CC4S;
            /*
                Input capture 3 filter
             */
            typedef reg_t<0x4000081c, 0x0000000f, 4, rw_t> IC3F;
            /*
                Input capture 3 prescaler
             */
            typedef reg_t<0x4000081c, 0x00000003, 2, rw_t> IC3PSC;
            /*
                Capture/Compare 3
              selection
             */
            typedef reg_t<0x4000081c, 0x00000003, 0, rw_t> CC3S;
        };
        /*
            capture/compare enable
          register
         */
        namespace CCER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000820, 0xffffffff, 0, rw_t> CCER_REG;
            /*
                Capture/Compare 1 output
              enable
             */
            typedef reg_t<0x40000820, 0x00000001, 0, rw_t> CC1E;
            /*
                Capture/Compare 1 output
              Polarity
             */
            typedef reg_t<0x40000820, 0x00000001, 1, rw_t> CC1P;
            /*
                Capture/Compare 1 output
              Polarity
             */
            typedef reg_t<0x40000820, 0x00000001, 3, rw_t> CC1NP;
            /*
                Capture/Compare 2 output
              enable
             */
            typedef reg_t<0x40000820, 0x00000001, 4, rw_t> CC2E;
            /*
                Capture/Compare 2 output
              Polarity
             */
            typedef reg_t<0x40000820, 0x00000001, 5, rw_t> CC2P;
            /*
                Capture/Compare 2 output
              Polarity
             */
            typedef reg_t<0x40000820, 0x00000001, 7, rw_t> CC2NP;
            /*
                Capture/Compare 3 output
              enable
             */
            typedef reg_t<0x40000820, 0x00000001, 8, rw_t> CC3E;
            /*
                Capture/Compare 3 output
              Polarity
             */
            typedef reg_t<0x40000820, 0x00000001, 9, rw_t> CC3P;
            /*
                Capture/Compare 3 output
              Polarity
             */
            typedef reg_t<0x40000820, 0x00000001, 11, rw_t> CC3NP;
            /*
                Capture/Compare 4 output
              enable
             */
            typedef reg_t<0x40000820, 0x00000001, 12, rw_t> CC4E;
            /*
                Capture/Compare 3 output
              Polarity
             */
            typedef reg_t<0x40000820, 0x00000001, 13, rw_t> CC4P;
            /*
                Capture/Compare 3 output
              Polarity
             */
            typedef reg_t<0x40000820, 0x00000001, 15, rw_t> CC4NP;
        };
        /*
            counter
         */
        namespace CNT {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000824, 0xffffffff, 0, rw_t> CNT_REG;
            /*
                Low counter value
             */
            typedef reg_t<0x40000824, 0x0000ffff, 0, rw_t> CNTL;
            /*
                High counter value
             */
            typedef reg_t<0x40000824, 0x00007fff, 16, rw_t> CNTH;
            /*
                if IUFREMAP=0 than CNT with read write
              access else UIFCPY with read only
              access
             */
            typedef reg_t<0x40000824, 0x00000001, 31, rw_t> CNT_or_UIFCPY;
        };
        /*
            prescaler
         */
        namespace PSC {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000828, 0xffffffff, 0, rw_t> PSC_REG;
            /*
                Prescaler value
             */
            typedef reg_t<0x40000828, 0x0000ffff, 0, rw_t> PSC;
        };
        /*
            auto-reload register
         */
        namespace ARR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000082c, 0xffffffff, 0, rw_t> ARR_REG;
            /*
                Low Auto-reload value
             */
            typedef reg_t<0x4000082c, 0x0000ffff, 0, rw_t> ARRL;
            /*
                High Auto-reload value
             */
            typedef reg_t<0x4000082c, 0x0000ffff, 16, rw_t> ARRH;
        };
        /*
            capture/compare register 1
         */
        namespace CCR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000834, 0xffffffff, 0, rw_t> CCR1_REG;
            /*
                Low Capture/Compare 1
              value
             */
            typedef reg_t<0x40000834, 0x0000ffff, 0, rw_t> CCR1L;
            /*
                High Capture/Compare 1 value (on
              TIM2)
             */
            typedef reg_t<0x40000834, 0x0000ffff, 16, rw_t> CCR1H;
        };
        /*
            capture/compare register 2
         */
        namespace CCR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000838, 0xffffffff, 0, rw_t> CCR2_REG;
            /*
                Low Capture/Compare 2
              value
             */
            typedef reg_t<0x40000838, 0x0000ffff, 0, rw_t> CCR2L;
            /*
                High Capture/Compare 2 value (on
              TIM2)
             */
            typedef reg_t<0x40000838, 0x0000ffff, 16, rw_t> CCR2H;
        };
        /*
            capture/compare register 3
         */
        namespace CCR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000083c, 0xffffffff, 0, rw_t> CCR3_REG;
            /*
                Low Capture/Compare value
             */
            typedef reg_t<0x4000083c, 0x0000ffff, 0, rw_t> CCR3L;
            /*
                High Capture/Compare value (on
              TIM2)
             */
            typedef reg_t<0x4000083c, 0x0000ffff, 16, rw_t> CCR3H;
        };
        /*
            capture/compare register 4
         */
        namespace CCR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000840, 0xffffffff, 0, rw_t> CCR4_REG;
            /*
                Low Capture/Compare value
             */
            typedef reg_t<0x40000840, 0x0000ffff, 0, rw_t> CCR4L;
            /*
                High Capture/Compare value (on
              TIM2)
             */
            typedef reg_t<0x40000840, 0x0000ffff, 16, rw_t> CCR4H;
        };
        /*
            DMA control register
         */
        namespace DCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40000848, 0xffffffff, 0, rw_t> DCR_REG;
            /*
                DMA burst length
             */
            typedef reg_t<0x40000848, 0x0000001f, 8, rw_t> DBL;
            /*
                DMA base address
             */
            typedef reg_t<0x40000848, 0x0000001f, 0, rw_t> DBA;
        };
        /*
            DMA address for full transfer
         */
        namespace DMAR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000084c, 0xffffffff, 0, rw_t> DMAR_REG;
            /*
                DMA register for burst
              accesses
             */
            typedef reg_t<0x4000084c, 0x0000ffff, 0, rw_t> DMAB;
        };
    };
    /*
        General purpose timers
     */
    namespace TIM15 {
        /*
            control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014000, 0xffffffff, 0, rw_t> CR1_REG;
            /*
                Counter enable
             */
            typedef reg_t<0x40014000, 0x00000001, 0, rw_t> CEN;
            /*
                Update disable
             */
            typedef reg_t<0x40014000, 0x00000001, 1, rw_t> UDIS;
            /*
                Update request source
             */
            typedef reg_t<0x40014000, 0x00000001, 2, rw_t> URS;
            /*
                One-pulse mode
             */
            typedef reg_t<0x40014000, 0x00000001, 3, rw_t> OPM;
            /*
                Auto-reload preload enable
             */
            typedef reg_t<0x40014000, 0x00000001, 7, rw_t> ARPE;
            /*
                Clock division
             */
            typedef reg_t<0x40014000, 0x00000003, 8, rw_t> CKD;
            /*
                UIF status bit remapping
             */
            typedef reg_t<0x40014000, 0x00000001, 11, rw_t> UIFREMAP;
        };
        /*
            control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014004, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                Capture/compare preloaded
              control
             */
            typedef reg_t<0x40014004, 0x00000001, 0, rw_t> CCPC;
            /*
                Capture/compare control update
              selection
             */
            typedef reg_t<0x40014004, 0x00000001, 2, rw_t> CCUS;
            /*
                Capture/compare DMA
              selection
             */
            typedef reg_t<0x40014004, 0x00000001, 3, rw_t> CCDS;
            /*
                Master mode selection
             */
            typedef reg_t<0x40014004, 0x00000007, 4, rw_t> MMS;
            /*
                TI1 selection
             */
            typedef reg_t<0x40014004, 0x00000001, 7, rw_t> TI1S;
            /*
                Output Idle state 1
             */
            typedef reg_t<0x40014004, 0x00000001, 8, rw_t> OIS1;
            /*
                Output Idle state 1
             */
            typedef reg_t<0x40014004, 0x00000001, 9, rw_t> OIS1N;
            /*
                Output Idle state 2
             */
            typedef reg_t<0x40014004, 0x00000001, 10, rw_t> OIS2;
        };
        /*
            slave mode control register
         */
        namespace SMCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014008, 0xffffffff, 0, rw_t> SMCR_REG;
            /*
                Slave mode selection
             */
            typedef reg_t<0x40014008, 0x00000007, 0, rw_t> SMS;
            /*
                Trigger selection
             */
            typedef reg_t<0x40014008, 0x00000007, 4, rw_t> TS;
            /*
                Master/Slave mode
             */
            typedef reg_t<0x40014008, 0x00000001, 7, rw_t> MSM;
            /*
                Slave mode selection bit 3
             */
            typedef reg_t<0x40014008, 0x00000001, 16, rw_t> SMS_3;
        };
        /*
            DMA/Interrupt enable register
         */
        namespace DIER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001400c, 0xffffffff, 0, rw_t> DIER_REG;
            /*
                Update interrupt enable
             */
            typedef reg_t<0x4001400c, 0x00000001, 0, rw_t> UIE;
            /*
                Capture/Compare 1 interrupt
              enable
             */
            typedef reg_t<0x4001400c, 0x00000001, 1, rw_t> CC1IE;
            /*
                Capture/Compare 2 interrupt
              enable
             */
            typedef reg_t<0x4001400c, 0x00000001, 2, rw_t> CC2IE;
            /*
                COM interrupt enable
             */
            typedef reg_t<0x4001400c, 0x00000001, 5, rw_t> COMIE;
            /*
                Trigger interrupt enable
             */
            typedef reg_t<0x4001400c, 0x00000001, 6, rw_t> TIE;
            /*
                Break interrupt enable
             */
            typedef reg_t<0x4001400c, 0x00000001, 7, rw_t> BIE;
            /*
                Update DMA request enable
             */
            typedef reg_t<0x4001400c, 0x00000001, 8, rw_t> UDE;
            /*
                Capture/Compare 1 DMA request
              enable
             */
            typedef reg_t<0x4001400c, 0x00000001, 9, rw_t> CC1DE;
            /*
                Capture/Compare 2 DMA request
              enable
             */
            typedef reg_t<0x4001400c, 0x00000001, 10, rw_t> CC2DE;
            /*
                COM DMA request enable
             */
            typedef reg_t<0x4001400c, 0x00000001, 13, rw_t> COMDE;
            /*
                Trigger DMA request enable
             */
            typedef reg_t<0x4001400c, 0x00000001, 14, rw_t> TDE;
        };
        /*
            status register
         */
        namespace SR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014010, 0xffffffff, 0, rw_t> SR_REG;
            /*
                Capture/compare 2 overcapture
              flag
             */
            typedef reg_t<0x40014010, 0x00000001, 10, rw_t> CC2OF;
            /*
                Capture/Compare 1 overcapture
              flag
             */
            typedef reg_t<0x40014010, 0x00000001, 9, rw_t> CC1OF;
            /*
                Break interrupt flag
             */
            typedef reg_t<0x40014010, 0x00000001, 7, rw_t> BIF;
            /*
                Trigger interrupt flag
             */
            typedef reg_t<0x40014010, 0x00000001, 6, rw_t> TIF;
            /*
                COM interrupt flag
             */
            typedef reg_t<0x40014010, 0x00000001, 5, rw_t> COMIF;
            /*
                Capture/Compare 2 interrupt
              flag
             */
            typedef reg_t<0x40014010, 0x00000001, 2, rw_t> CC2IF;
            /*
                Capture/compare 1 interrupt
              flag
             */
            typedef reg_t<0x40014010, 0x00000001, 1, rw_t> CC1IF;
            /*
                Update interrupt flag
             */
            typedef reg_t<0x40014010, 0x00000001, 0, rw_t> UIF;
        };
        /*
            event generation register
         */
        namespace EGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014014, 0xffffffff, 0, wo_t> EGR_REG;
            /*
                Break generation
             */
            typedef reg_t<0x40014014, 0x00000001, 7, wo_t> BG;
            /*
                Trigger generation
             */
            typedef reg_t<0x40014014, 0x00000001, 6, wo_t> TG;
            /*
                Capture/Compare control update
              generation
             */
            typedef reg_t<0x40014014, 0x00000001, 5, wo_t> COMG;
            /*
                Capture/compare 2
              generation
             */
            typedef reg_t<0x40014014, 0x00000001, 2, wo_t> CC2G;
            /*
                Capture/compare 1
              generation
             */
            typedef reg_t<0x40014014, 0x00000001, 1, wo_t> CC1G;
            /*
                Update generation
             */
            typedef reg_t<0x40014014, 0x00000001, 0, wo_t> UG;
        };
        /*
            capture/compare mode register (output
          mode)
         */
        namespace CCMR1_Output {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014018, 0xffffffff, 0, rw_t> CCMR1_Output_REG;
            /*
                Capture/Compare 1
              selection
             */
            typedef reg_t<0x40014018, 0x00000003, 0, rw_t> CC1S;
            /*
                Output Compare 1 fast
              enable
             */
            typedef reg_t<0x40014018, 0x00000001, 2, rw_t> OC1FE;
            /*
                Output Compare 1 preload
              enable
             */
            typedef reg_t<0x40014018, 0x00000001, 3, rw_t> OC1PE;
            /*
                Output Compare 1 mode
             */
            typedef reg_t<0x40014018, 0x00000007, 4, rw_t> OC1M;
            /*
                Capture/Compare 2
              selection
             */
            typedef reg_t<0x40014018, 0x00000003, 8, rw_t> CC2S;
            /*
                Output Compare 2 fast
              enable
             */
            typedef reg_t<0x40014018, 0x00000001, 10, rw_t> OC2FE;
            /*
                Output Compare 2 preload
              enable
             */
            typedef reg_t<0x40014018, 0x00000001, 11, rw_t> OC2PE;
            /*
                Output Compare 2 mode
             */
            typedef reg_t<0x40014018, 0x00000007, 12, rw_t> OC2M;
            /*
                Output Compare 1 mode bit
              3
             */
            typedef reg_t<0x40014018, 0x00000001, 16, rw_t> OC1M_3;
            /*
                Output Compare 2 mode bit
              3
             */
            typedef reg_t<0x40014018, 0x00000001, 24, rw_t> OC2M_3;
        };
        /*
            capture/compare mode register 1 (input
          mode)
         */
        namespace CCMR1_Input {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014018, 0xffffffff, 0, rw_t> CCMR1_Input_REG;
            /*
                Input capture 2 filter
             */
            typedef reg_t<0x40014018, 0x0000000f, 12, rw_t> IC2F;
            /*
                Input capture 2 prescaler
             */
            typedef reg_t<0x40014018, 0x00000003, 10, rw_t> IC2PSC;
            /*
                Capture/Compare 2
              selection
             */
            typedef reg_t<0x40014018, 0x00000003, 8, rw_t> CC2S;
            /*
                Input capture 1 filter
             */
            typedef reg_t<0x40014018, 0x0000000f, 4, rw_t> IC1F;
            /*
                Input capture 1 prescaler
             */
            typedef reg_t<0x40014018, 0x00000003, 2, rw_t> IC1PSC;
            /*
                Capture/Compare 1
              selection
             */
            typedef reg_t<0x40014018, 0x00000003, 0, rw_t> CC1S;
        };
        /*
            capture/compare enable
          register
         */
        namespace CCER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014020, 0xffffffff, 0, rw_t> CCER_REG;
            /*
                Capture/Compare 2 output
              Polarity
             */
            typedef reg_t<0x40014020, 0x00000001, 7, rw_t> CC2NP;
            /*
                Capture/Compare 2 output
              Polarity
             */
            typedef reg_t<0x40014020, 0x00000001, 5, rw_t> CC2P;
            /*
                Capture/Compare 2 output
              enable
             */
            typedef reg_t<0x40014020, 0x00000001, 4, rw_t> CC2E;
            /*
                Capture/Compare 1 output
              Polarity
             */
            typedef reg_t<0x40014020, 0x00000001, 3, rw_t> CC1NP;
            /*
                Capture/Compare 1 complementary output
              enable
             */
            typedef reg_t<0x40014020, 0x00000001, 2, rw_t> CC1NE;
            /*
                Capture/Compare 1 output
              Polarity
             */
            typedef reg_t<0x40014020, 0x00000001, 1, rw_t> CC1P;
            /*
                Capture/Compare 1 output
              enable
             */
            typedef reg_t<0x40014020, 0x00000001, 0, rw_t> CC1E;
        };
        /*
            counter
         */
        namespace CNT {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                counter value
             */
            typedef reg_t<0x40014024, 0x0000ffff, 0, rw_t> CNT;
            /*
                UIF copy
             */
            typedef reg_t<0x40014024, 0x00000001, 31, ro_t> UIFCPY;
        };
        /*
            prescaler
         */
        namespace PSC {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014028, 0xffffffff, 0, rw_t> PSC_REG;
            /*
                Prescaler value
             */
            typedef reg_t<0x40014028, 0x0000ffff, 0, rw_t> PSC;
        };
        /*
            auto-reload register
         */
        namespace ARR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001402c, 0xffffffff, 0, rw_t> ARR_REG;
            /*
                Auto-reload value
             */
            typedef reg_t<0x4001402c, 0x0000ffff, 0, rw_t> ARR;
        };
        /*
            repetition counter register
         */
        namespace RCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014030, 0xffffffff, 0, rw_t> RCR_REG;
            /*
                Repetition counter value
             */
            typedef reg_t<0x40014030, 0x000000ff, 0, rw_t> REP;
        };
        /*
            capture/compare register 1
         */
        namespace CCR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014034, 0xffffffff, 0, rw_t> CCR1_REG;
            /*
                Capture/Compare 1 value
             */
            typedef reg_t<0x40014034, 0x0000ffff, 0, rw_t> CCR1;
        };
        /*
            capture/compare register 2
         */
        namespace CCR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014038, 0xffffffff, 0, rw_t> CCR2_REG;
            /*
                Capture/Compare 2 value
             */
            typedef reg_t<0x40014038, 0x0000ffff, 0, rw_t> CCR2;
        };
        /*
            break and dead-time register
         */
        namespace BDTR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014044, 0xffffffff, 0, rw_t> BDTR_REG;
            /*
                Main output enable
             */
            typedef reg_t<0x40014044, 0x00000001, 15, rw_t> MOE;
            /*
                Automatic output enable
             */
            typedef reg_t<0x40014044, 0x00000001, 14, rw_t> AOE;
            /*
                Break polarity
             */
            typedef reg_t<0x40014044, 0x00000001, 13, rw_t> BKP;
            /*
                Break enable
             */
            typedef reg_t<0x40014044, 0x00000001, 12, rw_t> BKE;
            /*
                Off-state selection for Run
              mode
             */
            typedef reg_t<0x40014044, 0x00000001, 11, rw_t> OSSR;
            /*
                Off-state selection for Idle
              mode
             */
            typedef reg_t<0x40014044, 0x00000001, 10, rw_t> OSSI;
            /*
                Lock configuration
             */
            typedef reg_t<0x40014044, 0x00000003, 8, rw_t> LOCK;
            /*
                Dead-time generator setup
             */
            typedef reg_t<0x40014044, 0x000000ff, 0, rw_t> DTG;
            /*
                Break filter
             */
            typedef reg_t<0x40014044, 0x0000000f, 16, rw_t> BKF;
        };
        /*
            DMA control register
         */
        namespace DCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014048, 0xffffffff, 0, rw_t> DCR_REG;
            /*
                DMA burst length
             */
            typedef reg_t<0x40014048, 0x0000001f, 8, rw_t> DBL;
            /*
                DMA base address
             */
            typedef reg_t<0x40014048, 0x0000001f, 0, rw_t> DBA;
        };
        /*
            DMA address for full transfer
         */
        namespace DMAR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001404c, 0xffffffff, 0, rw_t> DMAR_REG;
            /*
                DMA register for burst
              accesses
             */
            typedef reg_t<0x4001404c, 0x0000ffff, 0, rw_t> DMAB;
        };
    };
    /*
        General-purpose-timers
     */
    namespace TIM16 {
        /*
            control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014400, 0xffffffff, 0, rw_t> CR1_REG;
            /*
                Counter enable
             */
            typedef reg_t<0x40014400, 0x00000001, 0, rw_t> CEN;
            /*
                Update disable
             */
            typedef reg_t<0x40014400, 0x00000001, 1, rw_t> UDIS;
            /*
                Update request source
             */
            typedef reg_t<0x40014400, 0x00000001, 2, rw_t> URS;
            /*
                One-pulse mode
             */
            typedef reg_t<0x40014400, 0x00000001, 3, rw_t> OPM;
            /*
                Auto-reload preload enable
             */
            typedef reg_t<0x40014400, 0x00000001, 7, rw_t> ARPE;
            /*
                Clock division
             */
            typedef reg_t<0x40014400, 0x00000003, 8, rw_t> CKD;
            /*
                UIF status bit remapping
             */
            typedef reg_t<0x40014400, 0x00000001, 11, rw_t> UIFREMAP;
        };
        /*
            control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014404, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                Output Idle state 1
             */
            typedef reg_t<0x40014404, 0x00000001, 9, rw_t> OIS1N;
            /*
                Output Idle state 1
             */
            typedef reg_t<0x40014404, 0x00000001, 8, rw_t> OIS1;
            /*
                Capture/compare DMA
              selection
             */
            typedef reg_t<0x40014404, 0x00000001, 3, rw_t> CCDS;
            /*
                Capture/compare control update
              selection
             */
            typedef reg_t<0x40014404, 0x00000001, 2, rw_t> CCUS;
            /*
                Capture/compare preloaded
              control
             */
            typedef reg_t<0x40014404, 0x00000001, 0, rw_t> CCPC;
        };
        /*
            DMA/Interrupt enable register
         */
        namespace DIER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001440c, 0xffffffff, 0, rw_t> DIER_REG;
            /*
                Update interrupt enable
             */
            typedef reg_t<0x4001440c, 0x00000001, 0, rw_t> UIE;
            /*
                Capture/Compare 1 interrupt
              enable
             */
            typedef reg_t<0x4001440c, 0x00000001, 1, rw_t> CC1IE;
            /*
                COM interrupt enable
             */
            typedef reg_t<0x4001440c, 0x00000001, 5, rw_t> COMIE;
            /*
                Trigger interrupt enable
             */
            typedef reg_t<0x4001440c, 0x00000001, 6, rw_t> TIE;
            /*
                Break interrupt enable
             */
            typedef reg_t<0x4001440c, 0x00000001, 7, rw_t> BIE;
            /*
                Update DMA request enable
             */
            typedef reg_t<0x4001440c, 0x00000001, 8, rw_t> UDE;
            /*
                Capture/Compare 1 DMA request
              enable
             */
            typedef reg_t<0x4001440c, 0x00000001, 9, rw_t> CC1DE;
            /*
                COM DMA request enable
             */
            typedef reg_t<0x4001440c, 0x00000001, 13, rw_t> COMDE;
            /*
                Trigger DMA request enable
             */
            typedef reg_t<0x4001440c, 0x00000001, 14, rw_t> TDE;
        };
        /*
            status register
         */
        namespace SR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014410, 0xffffffff, 0, rw_t> SR_REG;
            /*
                Capture/Compare 1 overcapture
              flag
             */
            typedef reg_t<0x40014410, 0x00000001, 9, rw_t> CC1OF;
            /*
                Break interrupt flag
             */
            typedef reg_t<0x40014410, 0x00000001, 7, rw_t> BIF;
            /*
                Trigger interrupt flag
             */
            typedef reg_t<0x40014410, 0x00000001, 6, rw_t> TIF;
            /*
                COM interrupt flag
             */
            typedef reg_t<0x40014410, 0x00000001, 5, rw_t> COMIF;
            /*
                Capture/compare 1 interrupt
              flag
             */
            typedef reg_t<0x40014410, 0x00000001, 1, rw_t> CC1IF;
            /*
                Update interrupt flag
             */
            typedef reg_t<0x40014410, 0x00000001, 0, rw_t> UIF;
        };
        /*
            event generation register
         */
        namespace EGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014414, 0xffffffff, 0, wo_t> EGR_REG;
            /*
                Break generation
             */
            typedef reg_t<0x40014414, 0x00000001, 7, wo_t> BG;
            /*
                Trigger generation
             */
            typedef reg_t<0x40014414, 0x00000001, 6, wo_t> TG;
            /*
                Capture/Compare control update
              generation
             */
            typedef reg_t<0x40014414, 0x00000001, 5, wo_t> COMG;
            /*
                Capture/compare 1
              generation
             */
            typedef reg_t<0x40014414, 0x00000001, 1, wo_t> CC1G;
            /*
                Update generation
             */
            typedef reg_t<0x40014414, 0x00000001, 0, wo_t> UG;
        };
        /*
            capture/compare mode register (output
          mode)
         */
        namespace CCMR1_Output {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014418, 0xffffffff, 0, rw_t> CCMR1_Output_REG;
            /*
                Capture/Compare 1
              selection
             */
            typedef reg_t<0x40014418, 0x00000003, 0, rw_t> CC1S;
            /*
                Output Compare 1 fast
              enable
             */
            typedef reg_t<0x40014418, 0x00000001, 2, rw_t> OC1FE;
            /*
                Output Compare 1 preload
              enable
             */
            typedef reg_t<0x40014418, 0x00000001, 3, rw_t> OC1PE;
            /*
                Output Compare 1 mode
             */
            typedef reg_t<0x40014418, 0x00000007, 4, rw_t> OC1M;
            /*
                Output Compare 1 mode
             */
            typedef reg_t<0x40014418, 0x00000001, 16, rw_t> OC1M_3;
        };
        /*
            capture/compare mode register 1 (input
          mode)
         */
        namespace CCMR1_Input {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014418, 0xffffffff, 0, rw_t> CCMR1_Input_REG;
            /*
                Input capture 1 filter
             */
            typedef reg_t<0x40014418, 0x0000000f, 4, rw_t> IC1F;
            /*
                Input capture 1 prescaler
             */
            typedef reg_t<0x40014418, 0x00000003, 2, rw_t> IC1PSC;
            /*
                Capture/Compare 1
              selection
             */
            typedef reg_t<0x40014418, 0x00000003, 0, rw_t> CC1S;
        };
        /*
            capture/compare enable
          register
         */
        namespace CCER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014420, 0xffffffff, 0, rw_t> CCER_REG;
            /*
                Capture/Compare 1 output
              Polarity
             */
            typedef reg_t<0x40014420, 0x00000001, 3, rw_t> CC1NP;
            /*
                Capture/Compare 1 complementary output
              enable
             */
            typedef reg_t<0x40014420, 0x00000001, 2, rw_t> CC1NE;
            /*
                Capture/Compare 1 output
              Polarity
             */
            typedef reg_t<0x40014420, 0x00000001, 1, rw_t> CC1P;
            /*
                Capture/Compare 1 output
              enable
             */
            typedef reg_t<0x40014420, 0x00000001, 0, rw_t> CC1E;
        };
        /*
            counter
         */
        namespace CNT {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                counter value
             */
            typedef reg_t<0x40014424, 0x0000ffff, 0, rw_t> CNT;
            /*
                UIF Copy
             */
            typedef reg_t<0x40014424, 0x00000001, 31, ro_t> UIFCPY;
        };
        /*
            prescaler
         */
        namespace PSC {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014428, 0xffffffff, 0, rw_t> PSC_REG;
            /*
                Prescaler value
             */
            typedef reg_t<0x40014428, 0x0000ffff, 0, rw_t> PSC;
        };
        /*
            auto-reload register
         */
        namespace ARR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001442c, 0xffffffff, 0, rw_t> ARR_REG;
            /*
                Auto-reload value
             */
            typedef reg_t<0x4001442c, 0x0000ffff, 0, rw_t> ARR;
        };
        /*
            repetition counter register
         */
        namespace RCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014430, 0xffffffff, 0, rw_t> RCR_REG;
            /*
                Repetition counter value
             */
            typedef reg_t<0x40014430, 0x000000ff, 0, rw_t> REP;
        };
        /*
            capture/compare register 1
         */
        namespace CCR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014434, 0xffffffff, 0, rw_t> CCR1_REG;
            /*
                Capture/Compare 1 value
             */
            typedef reg_t<0x40014434, 0x0000ffff, 0, rw_t> CCR1;
        };
        /*
            break and dead-time register
         */
        namespace BDTR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014444, 0xffffffff, 0, rw_t> BDTR_REG;
            /*
                Dead-time generator setup
             */
            typedef reg_t<0x40014444, 0x000000ff, 0, rw_t> DTG;
            /*
                Lock configuration
             */
            typedef reg_t<0x40014444, 0x00000003, 8, rw_t> LOCK;
            /*
                Off-state selection for Idle
              mode
             */
            typedef reg_t<0x40014444, 0x00000001, 10, rw_t> OSSI;
            /*
                Off-state selection for Run
              mode
             */
            typedef reg_t<0x40014444, 0x00000001, 11, rw_t> OSSR;
            /*
                Break enable
             */
            typedef reg_t<0x40014444, 0x00000001, 12, rw_t> BKE;
            /*
                Break polarity
             */
            typedef reg_t<0x40014444, 0x00000001, 13, rw_t> BKP;
            /*
                Automatic output enable
             */
            typedef reg_t<0x40014444, 0x00000001, 14, rw_t> AOE;
            /*
                Main output enable
             */
            typedef reg_t<0x40014444, 0x00000001, 15, rw_t> MOE;
            /*
                Break filter
             */
            typedef reg_t<0x40014444, 0x0000000f, 16, rw_t> BKF;
        };
        /*
            DMA control register
         */
        namespace DCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014448, 0xffffffff, 0, rw_t> DCR_REG;
            /*
                DMA burst length
             */
            typedef reg_t<0x40014448, 0x0000001f, 8, rw_t> DBL;
            /*
                DMA base address
             */
            typedef reg_t<0x40014448, 0x0000001f, 0, rw_t> DBA;
        };
        /*
            DMA address for full transfer
         */
        namespace DMAR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001444c, 0xffffffff, 0, rw_t> DMAR_REG;
            /*
                DMA register for burst
              accesses
             */
            typedef reg_t<0x4001444c, 0x0000ffff, 0, rw_t> DMAB;
        };
        typedef reg_t<0x40014450, 0xffffffff, 0, rw_t> OR;
    };
    /*
        General purpose timer
     */
    namespace TIM17 {
        /*
            control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014800, 0xffffffff, 0, rw_t> CR1_REG;
            /*
                Counter enable
             */
            typedef reg_t<0x40014800, 0x00000001, 0, rw_t> CEN;
            /*
                Update disable
             */
            typedef reg_t<0x40014800, 0x00000001, 1, rw_t> UDIS;
            /*
                Update request source
             */
            typedef reg_t<0x40014800, 0x00000001, 2, rw_t> URS;
            /*
                One-pulse mode
             */
            typedef reg_t<0x40014800, 0x00000001, 3, rw_t> OPM;
            /*
                Auto-reload preload enable
             */
            typedef reg_t<0x40014800, 0x00000001, 7, rw_t> ARPE;
            /*
                Clock division
             */
            typedef reg_t<0x40014800, 0x00000003, 8, rw_t> CKD;
            /*
                UIF status bit remapping
             */
            typedef reg_t<0x40014800, 0x00000001, 11, rw_t> UIFREMAP;
        };
        /*
            control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014804, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                Output Idle state 1
             */
            typedef reg_t<0x40014804, 0x00000001, 9, rw_t> OIS1N;
            /*
                Output Idle state 1
             */
            typedef reg_t<0x40014804, 0x00000001, 8, rw_t> OIS1;
            /*
                Capture/compare DMA
              selection
             */
            typedef reg_t<0x40014804, 0x00000001, 3, rw_t> CCDS;
            /*
                Capture/compare control update
              selection
             */
            typedef reg_t<0x40014804, 0x00000001, 2, rw_t> CCUS;
            /*
                Capture/compare preloaded
              control
             */
            typedef reg_t<0x40014804, 0x00000001, 0, rw_t> CCPC;
        };
        /*
            DMA/Interrupt enable register
         */
        namespace DIER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001480c, 0xffffffff, 0, rw_t> DIER_REG;
            /*
                Update interrupt enable
             */
            typedef reg_t<0x4001480c, 0x00000001, 0, rw_t> UIE;
            /*
                Capture/Compare 1 interrupt
              enable
             */
            typedef reg_t<0x4001480c, 0x00000001, 1, rw_t> CC1IE;
            /*
                COM interrupt enable
             */
            typedef reg_t<0x4001480c, 0x00000001, 5, rw_t> COMIE;
            /*
                Trigger interrupt enable
             */
            typedef reg_t<0x4001480c, 0x00000001, 6, rw_t> TIE;
            /*
                Break interrupt enable
             */
            typedef reg_t<0x4001480c, 0x00000001, 7, rw_t> BIE;
            /*
                Update DMA request enable
             */
            typedef reg_t<0x4001480c, 0x00000001, 8, rw_t> UDE;
            /*
                Capture/Compare 1 DMA request
              enable
             */
            typedef reg_t<0x4001480c, 0x00000001, 9, rw_t> CC1DE;
            /*
                COM DMA request enable
             */
            typedef reg_t<0x4001480c, 0x00000001, 13, rw_t> COMDE;
            /*
                Trigger DMA request enable
             */
            typedef reg_t<0x4001480c, 0x00000001, 14, rw_t> TDE;
        };
        /*
            status register
         */
        namespace SR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014810, 0xffffffff, 0, rw_t> SR_REG;
            /*
                Capture/Compare 1 overcapture
              flag
             */
            typedef reg_t<0x40014810, 0x00000001, 9, rw_t> CC1OF;
            /*
                Break interrupt flag
             */
            typedef reg_t<0x40014810, 0x00000001, 7, rw_t> BIF;
            /*
                Trigger interrupt flag
             */
            typedef reg_t<0x40014810, 0x00000001, 6, rw_t> TIF;
            /*
                COM interrupt flag
             */
            typedef reg_t<0x40014810, 0x00000001, 5, rw_t> COMIF;
            /*
                Capture/compare 1 interrupt
              flag
             */
            typedef reg_t<0x40014810, 0x00000001, 1, rw_t> CC1IF;
            /*
                Update interrupt flag
             */
            typedef reg_t<0x40014810, 0x00000001, 0, rw_t> UIF;
        };
        /*
            event generation register
         */
        namespace EGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014814, 0xffffffff, 0, wo_t> EGR_REG;
            /*
                Break generation
             */
            typedef reg_t<0x40014814, 0x00000001, 7, wo_t> BG;
            /*
                Trigger generation
             */
            typedef reg_t<0x40014814, 0x00000001, 6, wo_t> TG;
            /*
                Capture/Compare control update
              generation
             */
            typedef reg_t<0x40014814, 0x00000001, 5, wo_t> COMG;
            /*
                Capture/compare 1
              generation
             */
            typedef reg_t<0x40014814, 0x00000001, 1, wo_t> CC1G;
            /*
                Update generation
             */
            typedef reg_t<0x40014814, 0x00000001, 0, wo_t> UG;
        };
        /*
            capture/compare mode register (output
          mode)
         */
        namespace CCMR1_Output {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014818, 0xffffffff, 0, rw_t> CCMR1_Output_REG;
            /*
                Capture/Compare 1
              selection
             */
            typedef reg_t<0x40014818, 0x00000003, 0, rw_t> CC1S;
            /*
                Output Compare 1 fast
              enable
             */
            typedef reg_t<0x40014818, 0x00000001, 2, rw_t> OC1FE;
            /*
                Output Compare 1 preload
              enable
             */
            typedef reg_t<0x40014818, 0x00000001, 3, rw_t> OC1PE;
            /*
                Output Compare 1 mode
             */
            typedef reg_t<0x40014818, 0x00000007, 4, rw_t> OC1M;
            /*
                Output Compare 1 mode
             */
            typedef reg_t<0x40014818, 0x00000001, 16, rw_t> OC1M_3;
        };
        /*
            capture/compare mode register 1 (input
          mode)
         */
        namespace CCMR1_Input {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014818, 0xffffffff, 0, rw_t> CCMR1_Input_REG;
            /*
                Input capture 1 filter
             */
            typedef reg_t<0x40014818, 0x0000000f, 4, rw_t> IC1F;
            /*
                Input capture 1 prescaler
             */
            typedef reg_t<0x40014818, 0x00000003, 2, rw_t> IC1PSC;
            /*
                Capture/Compare 1
              selection
             */
            typedef reg_t<0x40014818, 0x00000003, 0, rw_t> CC1S;
        };
        /*
            capture/compare enable
          register
         */
        namespace CCER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014820, 0xffffffff, 0, rw_t> CCER_REG;
            /*
                Capture/Compare 1 output
              Polarity
             */
            typedef reg_t<0x40014820, 0x00000001, 3, rw_t> CC1NP;
            /*
                Capture/Compare 1 complementary output
              enable
             */
            typedef reg_t<0x40014820, 0x00000001, 2, rw_t> CC1NE;
            /*
                Capture/Compare 1 output
              Polarity
             */
            typedef reg_t<0x40014820, 0x00000001, 1, rw_t> CC1P;
            /*
                Capture/Compare 1 output
              enable
             */
            typedef reg_t<0x40014820, 0x00000001, 0, rw_t> CC1E;
        };
        /*
            counter
         */
        namespace CNT {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                counter value
             */
            typedef reg_t<0x40014824, 0x0000ffff, 0, rw_t> CNT;
            /*
                UIF Copy
             */
            typedef reg_t<0x40014824, 0x00000001, 31, ro_t> UIFCPY;
        };
        /*
            prescaler
         */
        namespace PSC {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014828, 0xffffffff, 0, rw_t> PSC_REG;
            /*
                Prescaler value
             */
            typedef reg_t<0x40014828, 0x0000ffff, 0, rw_t> PSC;
        };
        /*
            auto-reload register
         */
        namespace ARR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001482c, 0xffffffff, 0, rw_t> ARR_REG;
            /*
                Auto-reload value
             */
            typedef reg_t<0x4001482c, 0x0000ffff, 0, rw_t> ARR;
        };
        /*
            repetition counter register
         */
        namespace RCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014830, 0xffffffff, 0, rw_t> RCR_REG;
            /*
                Repetition counter value
             */
            typedef reg_t<0x40014830, 0x000000ff, 0, rw_t> REP;
        };
        /*
            capture/compare register 1
         */
        namespace CCR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014834, 0xffffffff, 0, rw_t> CCR1_REG;
            /*
                Capture/Compare 1 value
             */
            typedef reg_t<0x40014834, 0x0000ffff, 0, rw_t> CCR1;
        };
        /*
            break and dead-time register
         */
        namespace BDTR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014844, 0xffffffff, 0, rw_t> BDTR_REG;
            /*
                Dead-time generator setup
             */
            typedef reg_t<0x40014844, 0x000000ff, 0, rw_t> DTG;
            /*
                Lock configuration
             */
            typedef reg_t<0x40014844, 0x00000003, 8, rw_t> LOCK;
            /*
                Off-state selection for Idle
              mode
             */
            typedef reg_t<0x40014844, 0x00000001, 10, rw_t> OSSI;
            /*
                Off-state selection for Run
              mode
             */
            typedef reg_t<0x40014844, 0x00000001, 11, rw_t> OSSR;
            /*
                Break enable
             */
            typedef reg_t<0x40014844, 0x00000001, 12, rw_t> BKE;
            /*
                Break polarity
             */
            typedef reg_t<0x40014844, 0x00000001, 13, rw_t> BKP;
            /*
                Automatic output enable
             */
            typedef reg_t<0x40014844, 0x00000001, 14, rw_t> AOE;
            /*
                Main output enable
             */
            typedef reg_t<0x40014844, 0x00000001, 15, rw_t> MOE;
            /*
                Break filter
             */
            typedef reg_t<0x40014844, 0x0000000f, 16, rw_t> BKF;
        };
        /*
            DMA control register
         */
        namespace DCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40014848, 0xffffffff, 0, rw_t> DCR_REG;
            /*
                DMA burst length
             */
            typedef reg_t<0x40014848, 0x0000001f, 8, rw_t> DBL;
            /*
                DMA base address
             */
            typedef reg_t<0x40014848, 0x0000001f, 0, rw_t> DBA;
        };
        /*
            DMA address for full transfer
         */
        namespace DMAR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001484c, 0xffffffff, 0, rw_t> DMAR_REG;
            /*
                DMA register for burst
              accesses
             */
            typedef reg_t<0x4001484c, 0x0000ffff, 0, rw_t> DMAB;
        };
    };
    /*
        Universal synchronous asynchronous receiver
      transmitter
     */
    namespace USART1 {
        /*
            Control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013800, 0xffffffff, 0, rw_t> CR1_REG;
            /*
                End of Block interrupt
              enable
             */
            typedef reg_t<0x40013800, 0x00000001, 27, rw_t> EOBIE;
            /*
                Receiver timeout interrupt
              enable
             */
            typedef reg_t<0x40013800, 0x00000001, 26, rw_t> RTOIE;
            /*
                Driver Enable assertion
              time
             */
            typedef reg_t<0x40013800, 0x0000001f, 21, rw_t> DEAT;
            /*
                Driver Enable deassertion
              time
             */
            typedef reg_t<0x40013800, 0x0000001f, 16, rw_t> DEDT;
            /*
                Oversampling mode
             */
            typedef reg_t<0x40013800, 0x00000001, 15, rw_t> OVER8;
            /*
                Character match interrupt
              enable
             */
            typedef reg_t<0x40013800, 0x00000001, 14, rw_t> CMIE;
            /*
                Mute mode enable
             */
            typedef reg_t<0x40013800, 0x00000001, 13, rw_t> MME;
            /*
                Word length
             */
            typedef reg_t<0x40013800, 0x00000001, 12, rw_t> M;
            /*
                Receiver wakeup method
             */
            typedef reg_t<0x40013800, 0x00000001, 11, rw_t> WAKE;
            /*
                Parity control enable
             */
            typedef reg_t<0x40013800, 0x00000001, 10, rw_t> PCE;
            /*
                Parity selection
             */
            typedef reg_t<0x40013800, 0x00000001, 9, rw_t> PS;
            /*
                PE interrupt enable
             */
            typedef reg_t<0x40013800, 0x00000001, 8, rw_t> PEIE;
            /*
                interrupt enable
             */
            typedef reg_t<0x40013800, 0x00000001, 7, rw_t> TXEIE;
            /*
                Transmission complete interrupt
              enable
             */
            typedef reg_t<0x40013800, 0x00000001, 6, rw_t> TCIE;
            /*
                RXNE interrupt enable
             */
            typedef reg_t<0x40013800, 0x00000001, 5, rw_t> RXNEIE;
            /*
                IDLE interrupt enable
             */
            typedef reg_t<0x40013800, 0x00000001, 4, rw_t> IDLEIE;
            /*
                Transmitter enable
             */
            typedef reg_t<0x40013800, 0x00000001, 3, rw_t> TE;
            /*
                Receiver enable
             */
            typedef reg_t<0x40013800, 0x00000001, 2, rw_t> RE;
            /*
                USART enable in Stop mode
             */
            typedef reg_t<0x40013800, 0x00000001, 1, rw_t> UESM;
            /*
                USART enable
             */
            typedef reg_t<0x40013800, 0x00000001, 0, rw_t> UE;
        };
        /*
            Control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013804, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                Address of the USART node
             */
            typedef reg_t<0x40013804, 0x0000000f, 28, rw_t> ADD4;
            /*
                Address of the USART node
             */
            typedef reg_t<0x40013804, 0x0000000f, 24, rw_t> ADD0;
            /*
                Receiver timeout enable
             */
            typedef reg_t<0x40013804, 0x00000001, 23, rw_t> RTOEN;
            /*
                Auto baud rate mode
             */
            typedef reg_t<0x40013804, 0x00000003, 21, rw_t> ABRMOD;
            /*
                Auto baud rate enable
             */
            typedef reg_t<0x40013804, 0x00000001, 20, rw_t> ABREN;
            /*
                Most significant bit first
             */
            typedef reg_t<0x40013804, 0x00000001, 19, rw_t> MSBFIRST;
            /*
                Binary data inversion
             */
            typedef reg_t<0x40013804, 0x00000001, 18, rw_t> DATAINV;
            /*
                TX pin active level
              inversion
             */
            typedef reg_t<0x40013804, 0x00000001, 17, rw_t> TXINV;
            /*
                RX pin active level
              inversion
             */
            typedef reg_t<0x40013804, 0x00000001, 16, rw_t> RXINV;
            /*
                Swap TX/RX pins
             */
            typedef reg_t<0x40013804, 0x00000001, 15, rw_t> SWAP;
            /*
                LIN mode enable
             */
            typedef reg_t<0x40013804, 0x00000001, 14, rw_t> LINEN;
            /*
                STOP bits
             */
            typedef reg_t<0x40013804, 0x00000003, 12, rw_t> STOP;
            /*
                Clock enable
             */
            typedef reg_t<0x40013804, 0x00000001, 11, rw_t> CLKEN;
            /*
                Clock polarity
             */
            typedef reg_t<0x40013804, 0x00000001, 10, rw_t> CPOL;
            /*
                Clock phase
             */
            typedef reg_t<0x40013804, 0x00000001, 9, rw_t> CPHA;
            /*
                Last bit clock pulse
             */
            typedef reg_t<0x40013804, 0x00000001, 8, rw_t> LBCL;
            /*
                LIN break detection interrupt
              enable
             */
            typedef reg_t<0x40013804, 0x00000001, 6, rw_t> LBDIE;
            /*
                LIN break detection length
             */
            typedef reg_t<0x40013804, 0x00000001, 5, rw_t> LBDL;
            /*
                7-bit Address Detection/4-bit Address
              Detection
             */
            typedef reg_t<0x40013804, 0x00000001, 4, rw_t> ADDM7;
        };
        /*
            Control register 3
         */
        namespace CR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013808, 0xffffffff, 0, rw_t> CR3_REG;
            /*
                Wakeup from Stop mode interrupt
              enable
             */
            typedef reg_t<0x40013808, 0x00000001, 22, rw_t> WUFIE;
            /*
                Wakeup from Stop mode interrupt flag
              selection
             */
            typedef reg_t<0x40013808, 0x00000003, 20, rw_t> WUS;
            /*
                Smartcard auto-retry count
             */
            typedef reg_t<0x40013808, 0x00000007, 17, rw_t> SCARCNT;
            /*
                Driver enable polarity
              selection
             */
            typedef reg_t<0x40013808, 0x00000001, 15, rw_t> DEP;
            /*
                Driver enable mode
             */
            typedef reg_t<0x40013808, 0x00000001, 14, rw_t> DEM;
            /*
                DMA Disable on Reception
              Error
             */
            typedef reg_t<0x40013808, 0x00000001, 13, rw_t> DDRE;
            /*
                Overrun Disable
             */
            typedef reg_t<0x40013808, 0x00000001, 12, rw_t> OVRDIS;
            /*
                One sample bit method
              enable
             */
            typedef reg_t<0x40013808, 0x00000001, 11, rw_t> ONEBIT;
            /*
                CTS interrupt enable
             */
            typedef reg_t<0x40013808, 0x00000001, 10, rw_t> CTSIE;
            /*
                CTS enable
             */
            typedef reg_t<0x40013808, 0x00000001, 9, rw_t> CTSE;
            /*
                RTS enable
             */
            typedef reg_t<0x40013808, 0x00000001, 8, rw_t> RTSE;
            /*
                DMA enable transmitter
             */
            typedef reg_t<0x40013808, 0x00000001, 7, rw_t> DMAT;
            /*
                DMA enable receiver
             */
            typedef reg_t<0x40013808, 0x00000001, 6, rw_t> DMAR;
            /*
                Smartcard mode enable
             */
            typedef reg_t<0x40013808, 0x00000001, 5, rw_t> SCEN;
            /*
                Smartcard NACK enable
             */
            typedef reg_t<0x40013808, 0x00000001, 4, rw_t> NACK;
            /*
                Half-duplex selection
             */
            typedef reg_t<0x40013808, 0x00000001, 3, rw_t> HDSEL;
            /*
                IrDA low-power
             */
            typedef reg_t<0x40013808, 0x00000001, 2, rw_t> IRLP;
            /*
                IrDA mode enable
             */
            typedef reg_t<0x40013808, 0x00000001, 1, rw_t> IREN;
            /*
                Error interrupt enable
             */
            typedef reg_t<0x40013808, 0x00000001, 0, rw_t> EIE;
        };
        /*
            Baud rate register
         */
        namespace BRR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001380c, 0xffffffff, 0, rw_t> BRR_REG;
            /*
                mantissa of USARTDIV
             */
            typedef reg_t<0x4001380c, 0x00000fff, 4, rw_t> DIV_Mantissa;
            /*
                fraction of USARTDIV
             */
            typedef reg_t<0x4001380c, 0x0000000f, 0, rw_t> DIV_Fraction;
        };
        /*
            Guard time and prescaler
          register
         */
        namespace GTPR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013810, 0xffffffff, 0, rw_t> GTPR_REG;
            /*
                Guard time value
             */
            typedef reg_t<0x40013810, 0x000000ff, 8, rw_t> GT;
            /*
                Prescaler value
             */
            typedef reg_t<0x40013810, 0x000000ff, 0, rw_t> PSC;
        };
        /*
            Receiver timeout register
         */
        namespace RTOR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013814, 0xffffffff, 0, rw_t> RTOR_REG;
            /*
                Block Length
             */
            typedef reg_t<0x40013814, 0x000000ff, 24, rw_t> BLEN;
            /*
                Receiver timeout value
             */
            typedef reg_t<0x40013814, 0x00ffffff, 0, rw_t> RTO;
        };
        /*
            Request register
         */
        namespace RQR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013818, 0xffffffff, 0, rw_t> RQR_REG;
            /*
                Transmit data flush
              request
             */
            typedef reg_t<0x40013818, 0x00000001, 4, rw_t> TXFRQ;
            /*
                Receive data flush request
             */
            typedef reg_t<0x40013818, 0x00000001, 3, rw_t> RXFRQ;
            /*
                Mute mode request
             */
            typedef reg_t<0x40013818, 0x00000001, 2, rw_t> MMRQ;
            /*
                Send break request
             */
            typedef reg_t<0x40013818, 0x00000001, 1, rw_t> SBKRQ;
            /*
                Auto baud rate request
             */
            typedef reg_t<0x40013818, 0x00000001, 0, rw_t> ABRRQ;
        };
        /*
            Interrupt & status
          register
         */
        namespace ISR {

            static constexpr uint32_t RESETVALUE = 0x000000c0;
            typedef reg_t<0x4001381c, 0xffffffff, 0, ro_t> ISR_REG;
            /*
                Receive enable acknowledge
              flag
             */
            typedef reg_t<0x4001381c, 0x00000001, 22, ro_t> REACK;
            /*
                Transmit enable acknowledge
              flag
             */
            typedef reg_t<0x4001381c, 0x00000001, 21, ro_t> TEACK;
            /*
                Wakeup from Stop mode flag
             */
            typedef reg_t<0x4001381c, 0x00000001, 20, ro_t> WUF;
            /*
                Receiver wakeup from Mute
              mode
             */
            typedef reg_t<0x4001381c, 0x00000001, 19, ro_t> RWU;
            /*
                Send break flag
             */
            typedef reg_t<0x4001381c, 0x00000001, 18, ro_t> SBKF;
            /*
                character match flag
             */
            typedef reg_t<0x4001381c, 0x00000001, 17, ro_t> CMF;
            /*
                Busy flag
             */
            typedef reg_t<0x4001381c, 0x00000001, 16, ro_t> BUSY;
            /*
                Auto baud rate flag
             */
            typedef reg_t<0x4001381c, 0x00000001, 15, ro_t> ABRF;
            /*
                Auto baud rate error
             */
            typedef reg_t<0x4001381c, 0x00000001, 14, ro_t> ABRE;
            /*
                End of block flag
             */
            typedef reg_t<0x4001381c, 0x00000001, 12, ro_t> EOBF;
            /*
                Receiver timeout
             */
            typedef reg_t<0x4001381c, 0x00000001, 11, ro_t> RTOF;
            /*
                CTS flag
             */
            typedef reg_t<0x4001381c, 0x00000001, 10, ro_t> CTS;
            /*
                CTS interrupt flag
             */
            typedef reg_t<0x4001381c, 0x00000001, 9, ro_t> CTSIF;
            /*
                LIN break detection flag
             */
            typedef reg_t<0x4001381c, 0x00000001, 8, ro_t> LBDF;
            /*
                Transmit data register
              empty
             */
            typedef reg_t<0x4001381c, 0x00000001, 7, ro_t> TXE;
            /*
                Transmission complete
             */
            typedef reg_t<0x4001381c, 0x00000001, 6, ro_t> TC;
            /*
                Read data register not
              empty
             */
            typedef reg_t<0x4001381c, 0x00000001, 5, ro_t> RXNE;
            /*
                Idle line detected
             */
            typedef reg_t<0x4001381c, 0x00000001, 4, ro_t> IDLE;
            /*
                Overrun error
             */
            typedef reg_t<0x4001381c, 0x00000001, 3, ro_t> ORE;
            /*
                Noise detected flag
             */
            typedef reg_t<0x4001381c, 0x00000001, 2, ro_t> NF;
            /*
                Framing error
             */
            typedef reg_t<0x4001381c, 0x00000001, 1, ro_t> FE;
            /*
                Parity error
             */
            typedef reg_t<0x4001381c, 0x00000001, 0, ro_t> PE;
        };
        /*
            Interrupt flag clear register
         */
        namespace ICR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013820, 0xffffffff, 0, rw_t> ICR_REG;
            /*
                Wakeup from Stop mode clear
              flag
             */
            typedef reg_t<0x40013820, 0x00000001, 20, rw_t> WUCF;
            /*
                Character match clear flag
             */
            typedef reg_t<0x40013820, 0x00000001, 17, rw_t> CMCF;
            /*
                End of timeout clear flag
             */
            typedef reg_t<0x40013820, 0x00000001, 12, rw_t> EOBCF;
            /*
                Receiver timeout clear
              flag
             */
            typedef reg_t<0x40013820, 0x00000001, 11, rw_t> RTOCF;
            /*
                CTS clear flag
             */
            typedef reg_t<0x40013820, 0x00000001, 9, rw_t> CTSCF;
            /*
                LIN break detection clear
              flag
             */
            typedef reg_t<0x40013820, 0x00000001, 8, rw_t> LBDCF;
            /*
                Transmission complete clear
              flag
             */
            typedef reg_t<0x40013820, 0x00000001, 6, rw_t> TCCF;
            /*
                Idle line detected clear
              flag
             */
            typedef reg_t<0x40013820, 0x00000001, 4, rw_t> IDLECF;
            /*
                Overrun error clear flag
             */
            typedef reg_t<0x40013820, 0x00000001, 3, rw_t> ORECF;
            /*
                Noise detected clear flag
             */
            typedef reg_t<0x40013820, 0x00000001, 2, rw_t> NCF;
            /*
                Framing error clear flag
             */
            typedef reg_t<0x40013820, 0x00000001, 1, rw_t> FECF;
            /*
                Parity error clear flag
             */
            typedef reg_t<0x40013820, 0x00000001, 0, rw_t> PECF;
        };
        /*
            Receive data register
         */
        namespace RDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013824, 0xffffffff, 0, ro_t> RDR_REG;
            /*
                Receive data value
             */
            typedef reg_t<0x40013824, 0x000001ff, 0, ro_t> RDR;
        };
        /*
            Transmit data register
         */
        namespace TDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013828, 0xffffffff, 0, rw_t> TDR_REG;
            /*
                Transmit data value
             */
            typedef reg_t<0x40013828, 0x000001ff, 0, rw_t> TDR;
        };
    };
    /*
        Universal synchronous asynchronous receiver
      transmitter
     */
    namespace USART2 {
        /*
            Control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004400, 0xffffffff, 0, rw_t> CR1_REG;
            /*
                End of Block interrupt
              enable
             */
            typedef reg_t<0x40004400, 0x00000001, 27, rw_t> EOBIE;
            /*
                Receiver timeout interrupt
              enable
             */
            typedef reg_t<0x40004400, 0x00000001, 26, rw_t> RTOIE;
            /*
                Driver Enable assertion
              time
             */
            typedef reg_t<0x40004400, 0x0000001f, 21, rw_t> DEAT;
            /*
                Driver Enable deassertion
              time
             */
            typedef reg_t<0x40004400, 0x0000001f, 16, rw_t> DEDT;
            /*
                Oversampling mode
             */
            typedef reg_t<0x40004400, 0x00000001, 15, rw_t> OVER8;
            /*
                Character match interrupt
              enable
             */
            typedef reg_t<0x40004400, 0x00000001, 14, rw_t> CMIE;
            /*
                Mute mode enable
             */
            typedef reg_t<0x40004400, 0x00000001, 13, rw_t> MME;
            /*
                Word length
             */
            typedef reg_t<0x40004400, 0x00000001, 12, rw_t> M;
            /*
                Receiver wakeup method
             */
            typedef reg_t<0x40004400, 0x00000001, 11, rw_t> WAKE;
            /*
                Parity control enable
             */
            typedef reg_t<0x40004400, 0x00000001, 10, rw_t> PCE;
            /*
                Parity selection
             */
            typedef reg_t<0x40004400, 0x00000001, 9, rw_t> PS;
            /*
                PE interrupt enable
             */
            typedef reg_t<0x40004400, 0x00000001, 8, rw_t> PEIE;
            /*
                interrupt enable
             */
            typedef reg_t<0x40004400, 0x00000001, 7, rw_t> TXEIE;
            /*
                Transmission complete interrupt
              enable
             */
            typedef reg_t<0x40004400, 0x00000001, 6, rw_t> TCIE;
            /*
                RXNE interrupt enable
             */
            typedef reg_t<0x40004400, 0x00000001, 5, rw_t> RXNEIE;
            /*
                IDLE interrupt enable
             */
            typedef reg_t<0x40004400, 0x00000001, 4, rw_t> IDLEIE;
            /*
                Transmitter enable
             */
            typedef reg_t<0x40004400, 0x00000001, 3, rw_t> TE;
            /*
                Receiver enable
             */
            typedef reg_t<0x40004400, 0x00000001, 2, rw_t> RE;
            /*
                USART enable in Stop mode
             */
            typedef reg_t<0x40004400, 0x00000001, 1, rw_t> UESM;
            /*
                USART enable
             */
            typedef reg_t<0x40004400, 0x00000001, 0, rw_t> UE;
        };
        /*
            Control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004404, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                Address of the USART node
             */
            typedef reg_t<0x40004404, 0x0000000f, 28, rw_t> ADD4;
            /*
                Address of the USART node
             */
            typedef reg_t<0x40004404, 0x0000000f, 24, rw_t> ADD0;
            /*
                Receiver timeout enable
             */
            typedef reg_t<0x40004404, 0x00000001, 23, rw_t> RTOEN;
            /*
                Auto baud rate mode
             */
            typedef reg_t<0x40004404, 0x00000003, 21, rw_t> ABRMOD;
            /*
                Auto baud rate enable
             */
            typedef reg_t<0x40004404, 0x00000001, 20, rw_t> ABREN;
            /*
                Most significant bit first
             */
            typedef reg_t<0x40004404, 0x00000001, 19, rw_t> MSBFIRST;
            /*
                Binary data inversion
             */
            typedef reg_t<0x40004404, 0x00000001, 18, rw_t> DATAINV;
            /*
                TX pin active level
              inversion
             */
            typedef reg_t<0x40004404, 0x00000001, 17, rw_t> TXINV;
            /*
                RX pin active level
              inversion
             */
            typedef reg_t<0x40004404, 0x00000001, 16, rw_t> RXINV;
            /*
                Swap TX/RX pins
             */
            typedef reg_t<0x40004404, 0x00000001, 15, rw_t> SWAP;
            /*
                LIN mode enable
             */
            typedef reg_t<0x40004404, 0x00000001, 14, rw_t> LINEN;
            /*
                STOP bits
             */
            typedef reg_t<0x40004404, 0x00000003, 12, rw_t> STOP;
            /*
                Clock enable
             */
            typedef reg_t<0x40004404, 0x00000001, 11, rw_t> CLKEN;
            /*
                Clock polarity
             */
            typedef reg_t<0x40004404, 0x00000001, 10, rw_t> CPOL;
            /*
                Clock phase
             */
            typedef reg_t<0x40004404, 0x00000001, 9, rw_t> CPHA;
            /*
                Last bit clock pulse
             */
            typedef reg_t<0x40004404, 0x00000001, 8, rw_t> LBCL;
            /*
                LIN break detection interrupt
              enable
             */
            typedef reg_t<0x40004404, 0x00000001, 6, rw_t> LBDIE;
            /*
                LIN break detection length
             */
            typedef reg_t<0x40004404, 0x00000001, 5, rw_t> LBDL;
            /*
                7-bit Address Detection/4-bit Address
              Detection
             */
            typedef reg_t<0x40004404, 0x00000001, 4, rw_t> ADDM7;
        };
        /*
            Control register 3
         */
        namespace CR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004408, 0xffffffff, 0, rw_t> CR3_REG;
            /*
                Wakeup from Stop mode interrupt
              enable
             */
            typedef reg_t<0x40004408, 0x00000001, 22, rw_t> WUFIE;
            /*
                Wakeup from Stop mode interrupt flag
              selection
             */
            typedef reg_t<0x40004408, 0x00000003, 20, rw_t> WUS;
            /*
                Smartcard auto-retry count
             */
            typedef reg_t<0x40004408, 0x00000007, 17, rw_t> SCARCNT;
            /*
                Driver enable polarity
              selection
             */
            typedef reg_t<0x40004408, 0x00000001, 15, rw_t> DEP;
            /*
                Driver enable mode
             */
            typedef reg_t<0x40004408, 0x00000001, 14, rw_t> DEM;
            /*
                DMA Disable on Reception
              Error
             */
            typedef reg_t<0x40004408, 0x00000001, 13, rw_t> DDRE;
            /*
                Overrun Disable
             */
            typedef reg_t<0x40004408, 0x00000001, 12, rw_t> OVRDIS;
            /*
                One sample bit method
              enable
             */
            typedef reg_t<0x40004408, 0x00000001, 11, rw_t> ONEBIT;
            /*
                CTS interrupt enable
             */
            typedef reg_t<0x40004408, 0x00000001, 10, rw_t> CTSIE;
            /*
                CTS enable
             */
            typedef reg_t<0x40004408, 0x00000001, 9, rw_t> CTSE;
            /*
                RTS enable
             */
            typedef reg_t<0x40004408, 0x00000001, 8, rw_t> RTSE;
            /*
                DMA enable transmitter
             */
            typedef reg_t<0x40004408, 0x00000001, 7, rw_t> DMAT;
            /*
                DMA enable receiver
             */
            typedef reg_t<0x40004408, 0x00000001, 6, rw_t> DMAR;
            /*
                Smartcard mode enable
             */
            typedef reg_t<0x40004408, 0x00000001, 5, rw_t> SCEN;
            /*
                Smartcard NACK enable
             */
            typedef reg_t<0x40004408, 0x00000001, 4, rw_t> NACK;
            /*
                Half-duplex selection
             */
            typedef reg_t<0x40004408, 0x00000001, 3, rw_t> HDSEL;
            /*
                IrDA low-power
             */
            typedef reg_t<0x40004408, 0x00000001, 2, rw_t> IRLP;
            /*
                IrDA mode enable
             */
            typedef reg_t<0x40004408, 0x00000001, 1, rw_t> IREN;
            /*
                Error interrupt enable
             */
            typedef reg_t<0x40004408, 0x00000001, 0, rw_t> EIE;
        };
        /*
            Baud rate register
         */
        namespace BRR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000440c, 0xffffffff, 0, rw_t> BRR_REG;
            /*
                mantissa of USARTDIV
             */
            typedef reg_t<0x4000440c, 0x00000fff, 4, rw_t> DIV_Mantissa;
            /*
                fraction of USARTDIV
             */
            typedef reg_t<0x4000440c, 0x0000000f, 0, rw_t> DIV_Fraction;
        };
        /*
            Guard time and prescaler
          register
         */
        namespace GTPR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004410, 0xffffffff, 0, rw_t> GTPR_REG;
            /*
                Guard time value
             */
            typedef reg_t<0x40004410, 0x000000ff, 8, rw_t> GT;
            /*
                Prescaler value
             */
            typedef reg_t<0x40004410, 0x000000ff, 0, rw_t> PSC;
        };
        /*
            Receiver timeout register
         */
        namespace RTOR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004414, 0xffffffff, 0, rw_t> RTOR_REG;
            /*
                Block Length
             */
            typedef reg_t<0x40004414, 0x000000ff, 24, rw_t> BLEN;
            /*
                Receiver timeout value
             */
            typedef reg_t<0x40004414, 0x00ffffff, 0, rw_t> RTO;
        };
        /*
            Request register
         */
        namespace RQR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004418, 0xffffffff, 0, rw_t> RQR_REG;
            /*
                Transmit data flush
              request
             */
            typedef reg_t<0x40004418, 0x00000001, 4, rw_t> TXFRQ;
            /*
                Receive data flush request
             */
            typedef reg_t<0x40004418, 0x00000001, 3, rw_t> RXFRQ;
            /*
                Mute mode request
             */
            typedef reg_t<0x40004418, 0x00000001, 2, rw_t> MMRQ;
            /*
                Send break request
             */
            typedef reg_t<0x40004418, 0x00000001, 1, rw_t> SBKRQ;
            /*
                Auto baud rate request
             */
            typedef reg_t<0x40004418, 0x00000001, 0, rw_t> ABRRQ;
        };
        /*
            Interrupt & status
          register
         */
        namespace ISR {

            static constexpr uint32_t RESETVALUE = 0x000000c0;
            typedef reg_t<0x4000441c, 0xffffffff, 0, ro_t> ISR_REG;
            /*
                Receive enable acknowledge
              flag
             */
            typedef reg_t<0x4000441c, 0x00000001, 22, ro_t> REACK;
            /*
                Transmit enable acknowledge
              flag
             */
            typedef reg_t<0x4000441c, 0x00000001, 21, ro_t> TEACK;
            /*
                Wakeup from Stop mode flag
             */
            typedef reg_t<0x4000441c, 0x00000001, 20, ro_t> WUF;
            /*
                Receiver wakeup from Mute
              mode
             */
            typedef reg_t<0x4000441c, 0x00000001, 19, ro_t> RWU;
            /*
                Send break flag
             */
            typedef reg_t<0x4000441c, 0x00000001, 18, ro_t> SBKF;
            /*
                character match flag
             */
            typedef reg_t<0x4000441c, 0x00000001, 17, ro_t> CMF;
            /*
                Busy flag
             */
            typedef reg_t<0x4000441c, 0x00000001, 16, ro_t> BUSY;
            /*
                Auto baud rate flag
             */
            typedef reg_t<0x4000441c, 0x00000001, 15, ro_t> ABRF;
            /*
                Auto baud rate error
             */
            typedef reg_t<0x4000441c, 0x00000001, 14, ro_t> ABRE;
            /*
                End of block flag
             */
            typedef reg_t<0x4000441c, 0x00000001, 12, ro_t> EOBF;
            /*
                Receiver timeout
             */
            typedef reg_t<0x4000441c, 0x00000001, 11, ro_t> RTOF;
            /*
                CTS flag
             */
            typedef reg_t<0x4000441c, 0x00000001, 10, ro_t> CTS;
            /*
                CTS interrupt flag
             */
            typedef reg_t<0x4000441c, 0x00000001, 9, ro_t> CTSIF;
            /*
                LIN break detection flag
             */
            typedef reg_t<0x4000441c, 0x00000001, 8, ro_t> LBDF;
            /*
                Transmit data register
              empty
             */
            typedef reg_t<0x4000441c, 0x00000001, 7, ro_t> TXE;
            /*
                Transmission complete
             */
            typedef reg_t<0x4000441c, 0x00000001, 6, ro_t> TC;
            /*
                Read data register not
              empty
             */
            typedef reg_t<0x4000441c, 0x00000001, 5, ro_t> RXNE;
            /*
                Idle line detected
             */
            typedef reg_t<0x4000441c, 0x00000001, 4, ro_t> IDLE;
            /*
                Overrun error
             */
            typedef reg_t<0x4000441c, 0x00000001, 3, ro_t> ORE;
            /*
                Noise detected flag
             */
            typedef reg_t<0x4000441c, 0x00000001, 2, ro_t> NF;
            /*
                Framing error
             */
            typedef reg_t<0x4000441c, 0x00000001, 1, ro_t> FE;
            /*
                Parity error
             */
            typedef reg_t<0x4000441c, 0x00000001, 0, ro_t> PE;
        };
        /*
            Interrupt flag clear register
         */
        namespace ICR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004420, 0xffffffff, 0, rw_t> ICR_REG;
            /*
                Wakeup from Stop mode clear
              flag
             */
            typedef reg_t<0x40004420, 0x00000001, 20, rw_t> WUCF;
            /*
                Character match clear flag
             */
            typedef reg_t<0x40004420, 0x00000001, 17, rw_t> CMCF;
            /*
                End of timeout clear flag
             */
            typedef reg_t<0x40004420, 0x00000001, 12, rw_t> EOBCF;
            /*
                Receiver timeout clear
              flag
             */
            typedef reg_t<0x40004420, 0x00000001, 11, rw_t> RTOCF;
            /*
                CTS clear flag
             */
            typedef reg_t<0x40004420, 0x00000001, 9, rw_t> CTSCF;
            /*
                LIN break detection clear
              flag
             */
            typedef reg_t<0x40004420, 0x00000001, 8, rw_t> LBDCF;
            /*
                Transmission complete clear
              flag
             */
            typedef reg_t<0x40004420, 0x00000001, 6, rw_t> TCCF;
            /*
                Idle line detected clear
              flag
             */
            typedef reg_t<0x40004420, 0x00000001, 4, rw_t> IDLECF;
            /*
                Overrun error clear flag
             */
            typedef reg_t<0x40004420, 0x00000001, 3, rw_t> ORECF;
            /*
                Noise detected clear flag
             */
            typedef reg_t<0x40004420, 0x00000001, 2, rw_t> NCF;
            /*
                Framing error clear flag
             */
            typedef reg_t<0x40004420, 0x00000001, 1, rw_t> FECF;
            /*
                Parity error clear flag
             */
            typedef reg_t<0x40004420, 0x00000001, 0, rw_t> PECF;
        };
        /*
            Receive data register
         */
        namespace RDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004424, 0xffffffff, 0, ro_t> RDR_REG;
            /*
                Receive data value
             */
            typedef reg_t<0x40004424, 0x000001ff, 0, ro_t> RDR;
        };
        /*
            Transmit data register
         */
        namespace TDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004428, 0xffffffff, 0, rw_t> TDR_REG;
            /*
                Transmit data value
             */
            typedef reg_t<0x40004428, 0x000001ff, 0, rw_t> TDR;
        };
    };
    /*
        Universal synchronous asynchronous receiver
      transmitter
     */
    namespace USART3 {
        /*
            Control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004800, 0xffffffff, 0, rw_t> CR1_REG;
            /*
                End of Block interrupt
              enable
             */
            typedef reg_t<0x40004800, 0x00000001, 27, rw_t> EOBIE;
            /*
                Receiver timeout interrupt
              enable
             */
            typedef reg_t<0x40004800, 0x00000001, 26, rw_t> RTOIE;
            /*
                Driver Enable assertion
              time
             */
            typedef reg_t<0x40004800, 0x0000001f, 21, rw_t> DEAT;
            /*
                Driver Enable deassertion
              time
             */
            typedef reg_t<0x40004800, 0x0000001f, 16, rw_t> DEDT;
            /*
                Oversampling mode
             */
            typedef reg_t<0x40004800, 0x00000001, 15, rw_t> OVER8;
            /*
                Character match interrupt
              enable
             */
            typedef reg_t<0x40004800, 0x00000001, 14, rw_t> CMIE;
            /*
                Mute mode enable
             */
            typedef reg_t<0x40004800, 0x00000001, 13, rw_t> MME;
            /*
                Word length
             */
            typedef reg_t<0x40004800, 0x00000001, 12, rw_t> M;
            /*
                Receiver wakeup method
             */
            typedef reg_t<0x40004800, 0x00000001, 11, rw_t> WAKE;
            /*
                Parity control enable
             */
            typedef reg_t<0x40004800, 0x00000001, 10, rw_t> PCE;
            /*
                Parity selection
             */
            typedef reg_t<0x40004800, 0x00000001, 9, rw_t> PS;
            /*
                PE interrupt enable
             */
            typedef reg_t<0x40004800, 0x00000001, 8, rw_t> PEIE;
            /*
                interrupt enable
             */
            typedef reg_t<0x40004800, 0x00000001, 7, rw_t> TXEIE;
            /*
                Transmission complete interrupt
              enable
             */
            typedef reg_t<0x40004800, 0x00000001, 6, rw_t> TCIE;
            /*
                RXNE interrupt enable
             */
            typedef reg_t<0x40004800, 0x00000001, 5, rw_t> RXNEIE;
            /*
                IDLE interrupt enable
             */
            typedef reg_t<0x40004800, 0x00000001, 4, rw_t> IDLEIE;
            /*
                Transmitter enable
             */
            typedef reg_t<0x40004800, 0x00000001, 3, rw_t> TE;
            /*
                Receiver enable
             */
            typedef reg_t<0x40004800, 0x00000001, 2, rw_t> RE;
            /*
                USART enable in Stop mode
             */
            typedef reg_t<0x40004800, 0x00000001, 1, rw_t> UESM;
            /*
                USART enable
             */
            typedef reg_t<0x40004800, 0x00000001, 0, rw_t> UE;
        };
        /*
            Control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004804, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                Address of the USART node
             */
            typedef reg_t<0x40004804, 0x0000000f, 28, rw_t> ADD4;
            /*
                Address of the USART node
             */
            typedef reg_t<0x40004804, 0x0000000f, 24, rw_t> ADD0;
            /*
                Receiver timeout enable
             */
            typedef reg_t<0x40004804, 0x00000001, 23, rw_t> RTOEN;
            /*
                Auto baud rate mode
             */
            typedef reg_t<0x40004804, 0x00000003, 21, rw_t> ABRMOD;
            /*
                Auto baud rate enable
             */
            typedef reg_t<0x40004804, 0x00000001, 20, rw_t> ABREN;
            /*
                Most significant bit first
             */
            typedef reg_t<0x40004804, 0x00000001, 19, rw_t> MSBFIRST;
            /*
                Binary data inversion
             */
            typedef reg_t<0x40004804, 0x00000001, 18, rw_t> DATAINV;
            /*
                TX pin active level
              inversion
             */
            typedef reg_t<0x40004804, 0x00000001, 17, rw_t> TXINV;
            /*
                RX pin active level
              inversion
             */
            typedef reg_t<0x40004804, 0x00000001, 16, rw_t> RXINV;
            /*
                Swap TX/RX pins
             */
            typedef reg_t<0x40004804, 0x00000001, 15, rw_t> SWAP;
            /*
                LIN mode enable
             */
            typedef reg_t<0x40004804, 0x00000001, 14, rw_t> LINEN;
            /*
                STOP bits
             */
            typedef reg_t<0x40004804, 0x00000003, 12, rw_t> STOP;
            /*
                Clock enable
             */
            typedef reg_t<0x40004804, 0x00000001, 11, rw_t> CLKEN;
            /*
                Clock polarity
             */
            typedef reg_t<0x40004804, 0x00000001, 10, rw_t> CPOL;
            /*
                Clock phase
             */
            typedef reg_t<0x40004804, 0x00000001, 9, rw_t> CPHA;
            /*
                Last bit clock pulse
             */
            typedef reg_t<0x40004804, 0x00000001, 8, rw_t> LBCL;
            /*
                LIN break detection interrupt
              enable
             */
            typedef reg_t<0x40004804, 0x00000001, 6, rw_t> LBDIE;
            /*
                LIN break detection length
             */
            typedef reg_t<0x40004804, 0x00000001, 5, rw_t> LBDL;
            /*
                7-bit Address Detection/4-bit Address
              Detection
             */
            typedef reg_t<0x40004804, 0x00000001, 4, rw_t> ADDM7;
        };
        /*
            Control register 3
         */
        namespace CR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004808, 0xffffffff, 0, rw_t> CR3_REG;
            /*
                Wakeup from Stop mode interrupt
              enable
             */
            typedef reg_t<0x40004808, 0x00000001, 22, rw_t> WUFIE;
            /*
                Wakeup from Stop mode interrupt flag
              selection
             */
            typedef reg_t<0x40004808, 0x00000003, 20, rw_t> WUS;
            /*
                Smartcard auto-retry count
             */
            typedef reg_t<0x40004808, 0x00000007, 17, rw_t> SCARCNT;
            /*
                Driver enable polarity
              selection
             */
            typedef reg_t<0x40004808, 0x00000001, 15, rw_t> DEP;
            /*
                Driver enable mode
             */
            typedef reg_t<0x40004808, 0x00000001, 14, rw_t> DEM;
            /*
                DMA Disable on Reception
              Error
             */
            typedef reg_t<0x40004808, 0x00000001, 13, rw_t> DDRE;
            /*
                Overrun Disable
             */
            typedef reg_t<0x40004808, 0x00000001, 12, rw_t> OVRDIS;
            /*
                One sample bit method
              enable
             */
            typedef reg_t<0x40004808, 0x00000001, 11, rw_t> ONEBIT;
            /*
                CTS interrupt enable
             */
            typedef reg_t<0x40004808, 0x00000001, 10, rw_t> CTSIE;
            /*
                CTS enable
             */
            typedef reg_t<0x40004808, 0x00000001, 9, rw_t> CTSE;
            /*
                RTS enable
             */
            typedef reg_t<0x40004808, 0x00000001, 8, rw_t> RTSE;
            /*
                DMA enable transmitter
             */
            typedef reg_t<0x40004808, 0x00000001, 7, rw_t> DMAT;
            /*
                DMA enable receiver
             */
            typedef reg_t<0x40004808, 0x00000001, 6, rw_t> DMAR;
            /*
                Smartcard mode enable
             */
            typedef reg_t<0x40004808, 0x00000001, 5, rw_t> SCEN;
            /*
                Smartcard NACK enable
             */
            typedef reg_t<0x40004808, 0x00000001, 4, rw_t> NACK;
            /*
                Half-duplex selection
             */
            typedef reg_t<0x40004808, 0x00000001, 3, rw_t> HDSEL;
            /*
                IrDA low-power
             */
            typedef reg_t<0x40004808, 0x00000001, 2, rw_t> IRLP;
            /*
                IrDA mode enable
             */
            typedef reg_t<0x40004808, 0x00000001, 1, rw_t> IREN;
            /*
                Error interrupt enable
             */
            typedef reg_t<0x40004808, 0x00000001, 0, rw_t> EIE;
        };
        /*
            Baud rate register
         */
        namespace BRR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000480c, 0xffffffff, 0, rw_t> BRR_REG;
            /*
                mantissa of USARTDIV
             */
            typedef reg_t<0x4000480c, 0x00000fff, 4, rw_t> DIV_Mantissa;
            /*
                fraction of USARTDIV
             */
            typedef reg_t<0x4000480c, 0x0000000f, 0, rw_t> DIV_Fraction;
        };
        /*
            Guard time and prescaler
          register
         */
        namespace GTPR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004810, 0xffffffff, 0, rw_t> GTPR_REG;
            /*
                Guard time value
             */
            typedef reg_t<0x40004810, 0x000000ff, 8, rw_t> GT;
            /*
                Prescaler value
             */
            typedef reg_t<0x40004810, 0x000000ff, 0, rw_t> PSC;
        };
        /*
            Receiver timeout register
         */
        namespace RTOR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004814, 0xffffffff, 0, rw_t> RTOR_REG;
            /*
                Block Length
             */
            typedef reg_t<0x40004814, 0x000000ff, 24, rw_t> BLEN;
            /*
                Receiver timeout value
             */
            typedef reg_t<0x40004814, 0x00ffffff, 0, rw_t> RTO;
        };
        /*
            Request register
         */
        namespace RQR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004818, 0xffffffff, 0, rw_t> RQR_REG;
            /*
                Transmit data flush
              request
             */
            typedef reg_t<0x40004818, 0x00000001, 4, rw_t> TXFRQ;
            /*
                Receive data flush request
             */
            typedef reg_t<0x40004818, 0x00000001, 3, rw_t> RXFRQ;
            /*
                Mute mode request
             */
            typedef reg_t<0x40004818, 0x00000001, 2, rw_t> MMRQ;
            /*
                Send break request
             */
            typedef reg_t<0x40004818, 0x00000001, 1, rw_t> SBKRQ;
            /*
                Auto baud rate request
             */
            typedef reg_t<0x40004818, 0x00000001, 0, rw_t> ABRRQ;
        };
        /*
            Interrupt & status
          register
         */
        namespace ISR {

            static constexpr uint32_t RESETVALUE = 0x000000c0;
            typedef reg_t<0x4000481c, 0xffffffff, 0, ro_t> ISR_REG;
            /*
                Receive enable acknowledge
              flag
             */
            typedef reg_t<0x4000481c, 0x00000001, 22, ro_t> REACK;
            /*
                Transmit enable acknowledge
              flag
             */
            typedef reg_t<0x4000481c, 0x00000001, 21, ro_t> TEACK;
            /*
                Wakeup from Stop mode flag
             */
            typedef reg_t<0x4000481c, 0x00000001, 20, ro_t> WUF;
            /*
                Receiver wakeup from Mute
              mode
             */
            typedef reg_t<0x4000481c, 0x00000001, 19, ro_t> RWU;
            /*
                Send break flag
             */
            typedef reg_t<0x4000481c, 0x00000001, 18, ro_t> SBKF;
            /*
                character match flag
             */
            typedef reg_t<0x4000481c, 0x00000001, 17, ro_t> CMF;
            /*
                Busy flag
             */
            typedef reg_t<0x4000481c, 0x00000001, 16, ro_t> BUSY;
            /*
                Auto baud rate flag
             */
            typedef reg_t<0x4000481c, 0x00000001, 15, ro_t> ABRF;
            /*
                Auto baud rate error
             */
            typedef reg_t<0x4000481c, 0x00000001, 14, ro_t> ABRE;
            /*
                End of block flag
             */
            typedef reg_t<0x4000481c, 0x00000001, 12, ro_t> EOBF;
            /*
                Receiver timeout
             */
            typedef reg_t<0x4000481c, 0x00000001, 11, ro_t> RTOF;
            /*
                CTS flag
             */
            typedef reg_t<0x4000481c, 0x00000001, 10, ro_t> CTS;
            /*
                CTS interrupt flag
             */
            typedef reg_t<0x4000481c, 0x00000001, 9, ro_t> CTSIF;
            /*
                LIN break detection flag
             */
            typedef reg_t<0x4000481c, 0x00000001, 8, ro_t> LBDF;
            /*
                Transmit data register
              empty
             */
            typedef reg_t<0x4000481c, 0x00000001, 7, ro_t> TXE;
            /*
                Transmission complete
             */
            typedef reg_t<0x4000481c, 0x00000001, 6, ro_t> TC;
            /*
                Read data register not
              empty
             */
            typedef reg_t<0x4000481c, 0x00000001, 5, ro_t> RXNE;
            /*
                Idle line detected
             */
            typedef reg_t<0x4000481c, 0x00000001, 4, ro_t> IDLE;
            /*
                Overrun error
             */
            typedef reg_t<0x4000481c, 0x00000001, 3, ro_t> ORE;
            /*
                Noise detected flag
             */
            typedef reg_t<0x4000481c, 0x00000001, 2, ro_t> NF;
            /*
                Framing error
             */
            typedef reg_t<0x4000481c, 0x00000001, 1, ro_t> FE;
            /*
                Parity error
             */
            typedef reg_t<0x4000481c, 0x00000001, 0, ro_t> PE;
        };
        /*
            Interrupt flag clear register
         */
        namespace ICR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004820, 0xffffffff, 0, rw_t> ICR_REG;
            /*
                Wakeup from Stop mode clear
              flag
             */
            typedef reg_t<0x40004820, 0x00000001, 20, rw_t> WUCF;
            /*
                Character match clear flag
             */
            typedef reg_t<0x40004820, 0x00000001, 17, rw_t> CMCF;
            /*
                End of timeout clear flag
             */
            typedef reg_t<0x40004820, 0x00000001, 12, rw_t> EOBCF;
            /*
                Receiver timeout clear
              flag
             */
            typedef reg_t<0x40004820, 0x00000001, 11, rw_t> RTOCF;
            /*
                CTS clear flag
             */
            typedef reg_t<0x40004820, 0x00000001, 9, rw_t> CTSCF;
            /*
                LIN break detection clear
              flag
             */
            typedef reg_t<0x40004820, 0x00000001, 8, rw_t> LBDCF;
            /*
                Transmission complete clear
              flag
             */
            typedef reg_t<0x40004820, 0x00000001, 6, rw_t> TCCF;
            /*
                Idle line detected clear
              flag
             */
            typedef reg_t<0x40004820, 0x00000001, 4, rw_t> IDLECF;
            /*
                Overrun error clear flag
             */
            typedef reg_t<0x40004820, 0x00000001, 3, rw_t> ORECF;
            /*
                Noise detected clear flag
             */
            typedef reg_t<0x40004820, 0x00000001, 2, rw_t> NCF;
            /*
                Framing error clear flag
             */
            typedef reg_t<0x40004820, 0x00000001, 1, rw_t> FECF;
            /*
                Parity error clear flag
             */
            typedef reg_t<0x40004820, 0x00000001, 0, rw_t> PECF;
        };
        /*
            Receive data register
         */
        namespace RDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004824, 0xffffffff, 0, ro_t> RDR_REG;
            /*
                Receive data value
             */
            typedef reg_t<0x40004824, 0x000001ff, 0, ro_t> RDR;
        };
        /*
            Transmit data register
         */
        namespace TDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004828, 0xffffffff, 0, rw_t> TDR_REG;
            /*
                Transmit data value
             */
            typedef reg_t<0x40004828, 0x000001ff, 0, rw_t> TDR;
        };
    };
    /*
        Universal synchronous asynchronous receiver
      transmitter
     */
    namespace UART4 {
        /*
            Control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004c00, 0xffffffff, 0, rw_t> CR1_REG;
            /*
                End of Block interrupt
              enable
             */
            typedef reg_t<0x40004c00, 0x00000001, 27, rw_t> EOBIE;
            /*
                Receiver timeout interrupt
              enable
             */
            typedef reg_t<0x40004c00, 0x00000001, 26, rw_t> RTOIE;
            /*
                Driver Enable assertion
              time
             */
            typedef reg_t<0x40004c00, 0x0000001f, 21, rw_t> DEAT;
            /*
                Driver Enable deassertion
              time
             */
            typedef reg_t<0x40004c00, 0x0000001f, 16, rw_t> DEDT;
            /*
                Oversampling mode
             */
            typedef reg_t<0x40004c00, 0x00000001, 15, rw_t> OVER8;
            /*
                Character match interrupt
              enable
             */
            typedef reg_t<0x40004c00, 0x00000001, 14, rw_t> CMIE;
            /*
                Mute mode enable
             */
            typedef reg_t<0x40004c00, 0x00000001, 13, rw_t> MME;
            /*
                Word length
             */
            typedef reg_t<0x40004c00, 0x00000001, 12, rw_t> M;
            /*
                Receiver wakeup method
             */
            typedef reg_t<0x40004c00, 0x00000001, 11, rw_t> WAKE;
            /*
                Parity control enable
             */
            typedef reg_t<0x40004c00, 0x00000001, 10, rw_t> PCE;
            /*
                Parity selection
             */
            typedef reg_t<0x40004c00, 0x00000001, 9, rw_t> PS;
            /*
                PE interrupt enable
             */
            typedef reg_t<0x40004c00, 0x00000001, 8, rw_t> PEIE;
            /*
                interrupt enable
             */
            typedef reg_t<0x40004c00, 0x00000001, 7, rw_t> TXEIE;
            /*
                Transmission complete interrupt
              enable
             */
            typedef reg_t<0x40004c00, 0x00000001, 6, rw_t> TCIE;
            /*
                RXNE interrupt enable
             */
            typedef reg_t<0x40004c00, 0x00000001, 5, rw_t> RXNEIE;
            /*
                IDLE interrupt enable
             */
            typedef reg_t<0x40004c00, 0x00000001, 4, rw_t> IDLEIE;
            /*
                Transmitter enable
             */
            typedef reg_t<0x40004c00, 0x00000001, 3, rw_t> TE;
            /*
                Receiver enable
             */
            typedef reg_t<0x40004c00, 0x00000001, 2, rw_t> RE;
            /*
                USART enable in Stop mode
             */
            typedef reg_t<0x40004c00, 0x00000001, 1, rw_t> UESM;
            /*
                USART enable
             */
            typedef reg_t<0x40004c00, 0x00000001, 0, rw_t> UE;
        };
        /*
            Control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004c04, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                Address of the USART node
             */
            typedef reg_t<0x40004c04, 0x0000000f, 28, rw_t> ADD4;
            /*
                Address of the USART node
             */
            typedef reg_t<0x40004c04, 0x0000000f, 24, rw_t> ADD0;
            /*
                Receiver timeout enable
             */
            typedef reg_t<0x40004c04, 0x00000001, 23, rw_t> RTOEN;
            /*
                Auto baud rate mode
             */
            typedef reg_t<0x40004c04, 0x00000003, 21, rw_t> ABRMOD;
            /*
                Auto baud rate enable
             */
            typedef reg_t<0x40004c04, 0x00000001, 20, rw_t> ABREN;
            /*
                Most significant bit first
             */
            typedef reg_t<0x40004c04, 0x00000001, 19, rw_t> MSBFIRST;
            /*
                Binary data inversion
             */
            typedef reg_t<0x40004c04, 0x00000001, 18, rw_t> DATAINV;
            /*
                TX pin active level
              inversion
             */
            typedef reg_t<0x40004c04, 0x00000001, 17, rw_t> TXINV;
            /*
                RX pin active level
              inversion
             */
            typedef reg_t<0x40004c04, 0x00000001, 16, rw_t> RXINV;
            /*
                Swap TX/RX pins
             */
            typedef reg_t<0x40004c04, 0x00000001, 15, rw_t> SWAP;
            /*
                LIN mode enable
             */
            typedef reg_t<0x40004c04, 0x00000001, 14, rw_t> LINEN;
            /*
                STOP bits
             */
            typedef reg_t<0x40004c04, 0x00000003, 12, rw_t> STOP;
            /*
                Clock enable
             */
            typedef reg_t<0x40004c04, 0x00000001, 11, rw_t> CLKEN;
            /*
                Clock polarity
             */
            typedef reg_t<0x40004c04, 0x00000001, 10, rw_t> CPOL;
            /*
                Clock phase
             */
            typedef reg_t<0x40004c04, 0x00000001, 9, rw_t> CPHA;
            /*
                Last bit clock pulse
             */
            typedef reg_t<0x40004c04, 0x00000001, 8, rw_t> LBCL;
            /*
                LIN break detection interrupt
              enable
             */
            typedef reg_t<0x40004c04, 0x00000001, 6, rw_t> LBDIE;
            /*
                LIN break detection length
             */
            typedef reg_t<0x40004c04, 0x00000001, 5, rw_t> LBDL;
            /*
                7-bit Address Detection/4-bit Address
              Detection
             */
            typedef reg_t<0x40004c04, 0x00000001, 4, rw_t> ADDM7;
        };
        /*
            Control register 3
         */
        namespace CR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004c08, 0xffffffff, 0, rw_t> CR3_REG;
            /*
                Wakeup from Stop mode interrupt
              enable
             */
            typedef reg_t<0x40004c08, 0x00000001, 22, rw_t> WUFIE;
            /*
                Wakeup from Stop mode interrupt flag
              selection
             */
            typedef reg_t<0x40004c08, 0x00000003, 20, rw_t> WUS;
            /*
                Smartcard auto-retry count
             */
            typedef reg_t<0x40004c08, 0x00000007, 17, rw_t> SCARCNT;
            /*
                Driver enable polarity
              selection
             */
            typedef reg_t<0x40004c08, 0x00000001, 15, rw_t> DEP;
            /*
                Driver enable mode
             */
            typedef reg_t<0x40004c08, 0x00000001, 14, rw_t> DEM;
            /*
                DMA Disable on Reception
              Error
             */
            typedef reg_t<0x40004c08, 0x00000001, 13, rw_t> DDRE;
            /*
                Overrun Disable
             */
            typedef reg_t<0x40004c08, 0x00000001, 12, rw_t> OVRDIS;
            /*
                One sample bit method
              enable
             */
            typedef reg_t<0x40004c08, 0x00000001, 11, rw_t> ONEBIT;
            /*
                CTS interrupt enable
             */
            typedef reg_t<0x40004c08, 0x00000001, 10, rw_t> CTSIE;
            /*
                CTS enable
             */
            typedef reg_t<0x40004c08, 0x00000001, 9, rw_t> CTSE;
            /*
                RTS enable
             */
            typedef reg_t<0x40004c08, 0x00000001, 8, rw_t> RTSE;
            /*
                DMA enable transmitter
             */
            typedef reg_t<0x40004c08, 0x00000001, 7, rw_t> DMAT;
            /*
                DMA enable receiver
             */
            typedef reg_t<0x40004c08, 0x00000001, 6, rw_t> DMAR;
            /*
                Smartcard mode enable
             */
            typedef reg_t<0x40004c08, 0x00000001, 5, rw_t> SCEN;
            /*
                Smartcard NACK enable
             */
            typedef reg_t<0x40004c08, 0x00000001, 4, rw_t> NACK;
            /*
                Half-duplex selection
             */
            typedef reg_t<0x40004c08, 0x00000001, 3, rw_t> HDSEL;
            /*
                IrDA low-power
             */
            typedef reg_t<0x40004c08, 0x00000001, 2, rw_t> IRLP;
            /*
                IrDA mode enable
             */
            typedef reg_t<0x40004c08, 0x00000001, 1, rw_t> IREN;
            /*
                Error interrupt enable
             */
            typedef reg_t<0x40004c08, 0x00000001, 0, rw_t> EIE;
        };
        /*
            Baud rate register
         */
        namespace BRR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004c0c, 0xffffffff, 0, rw_t> BRR_REG;
            /*
                mantissa of USARTDIV
             */
            typedef reg_t<0x40004c0c, 0x00000fff, 4, rw_t> DIV_Mantissa;
            /*
                fraction of USARTDIV
             */
            typedef reg_t<0x40004c0c, 0x0000000f, 0, rw_t> DIV_Fraction;
        };
        /*
            Guard time and prescaler
          register
         */
        namespace GTPR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004c10, 0xffffffff, 0, rw_t> GTPR_REG;
            /*
                Guard time value
             */
            typedef reg_t<0x40004c10, 0x000000ff, 8, rw_t> GT;
            /*
                Prescaler value
             */
            typedef reg_t<0x40004c10, 0x000000ff, 0, rw_t> PSC;
        };
        /*
            Receiver timeout register
         */
        namespace RTOR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004c14, 0xffffffff, 0, rw_t> RTOR_REG;
            /*
                Block Length
             */
            typedef reg_t<0x40004c14, 0x000000ff, 24, rw_t> BLEN;
            /*
                Receiver timeout value
             */
            typedef reg_t<0x40004c14, 0x00ffffff, 0, rw_t> RTO;
        };
        /*
            Request register
         */
        namespace RQR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004c18, 0xffffffff, 0, rw_t> RQR_REG;
            /*
                Transmit data flush
              request
             */
            typedef reg_t<0x40004c18, 0x00000001, 4, rw_t> TXFRQ;
            /*
                Receive data flush request
             */
            typedef reg_t<0x40004c18, 0x00000001, 3, rw_t> RXFRQ;
            /*
                Mute mode request
             */
            typedef reg_t<0x40004c18, 0x00000001, 2, rw_t> MMRQ;
            /*
                Send break request
             */
            typedef reg_t<0x40004c18, 0x00000001, 1, rw_t> SBKRQ;
            /*
                Auto baud rate request
             */
            typedef reg_t<0x40004c18, 0x00000001, 0, rw_t> ABRRQ;
        };
        /*
            Interrupt & status
          register
         */
        namespace ISR {

            static constexpr uint32_t RESETVALUE = 0x000000c0;
            typedef reg_t<0x40004c1c, 0xffffffff, 0, ro_t> ISR_REG;
            /*
                Receive enable acknowledge
              flag
             */
            typedef reg_t<0x40004c1c, 0x00000001, 22, ro_t> REACK;
            /*
                Transmit enable acknowledge
              flag
             */
            typedef reg_t<0x40004c1c, 0x00000001, 21, ro_t> TEACK;
            /*
                Wakeup from Stop mode flag
             */
            typedef reg_t<0x40004c1c, 0x00000001, 20, ro_t> WUF;
            /*
                Receiver wakeup from Mute
              mode
             */
            typedef reg_t<0x40004c1c, 0x00000001, 19, ro_t> RWU;
            /*
                Send break flag
             */
            typedef reg_t<0x40004c1c, 0x00000001, 18, ro_t> SBKF;
            /*
                character match flag
             */
            typedef reg_t<0x40004c1c, 0x00000001, 17, ro_t> CMF;
            /*
                Busy flag
             */
            typedef reg_t<0x40004c1c, 0x00000001, 16, ro_t> BUSY;
            /*
                Auto baud rate flag
             */
            typedef reg_t<0x40004c1c, 0x00000001, 15, ro_t> ABRF;
            /*
                Auto baud rate error
             */
            typedef reg_t<0x40004c1c, 0x00000001, 14, ro_t> ABRE;
            /*
                End of block flag
             */
            typedef reg_t<0x40004c1c, 0x00000001, 12, ro_t> EOBF;
            /*
                Receiver timeout
             */
            typedef reg_t<0x40004c1c, 0x00000001, 11, ro_t> RTOF;
            /*
                CTS flag
             */
            typedef reg_t<0x40004c1c, 0x00000001, 10, ro_t> CTS;
            /*
                CTS interrupt flag
             */
            typedef reg_t<0x40004c1c, 0x00000001, 9, ro_t> CTSIF;
            /*
                LIN break detection flag
             */
            typedef reg_t<0x40004c1c, 0x00000001, 8, ro_t> LBDF;
            /*
                Transmit data register
              empty
             */
            typedef reg_t<0x40004c1c, 0x00000001, 7, ro_t> TXE;
            /*
                Transmission complete
             */
            typedef reg_t<0x40004c1c, 0x00000001, 6, ro_t> TC;
            /*
                Read data register not
              empty
             */
            typedef reg_t<0x40004c1c, 0x00000001, 5, ro_t> RXNE;
            /*
                Idle line detected
             */
            typedef reg_t<0x40004c1c, 0x00000001, 4, ro_t> IDLE;
            /*
                Overrun error
             */
            typedef reg_t<0x40004c1c, 0x00000001, 3, ro_t> ORE;
            /*
                Noise detected flag
             */
            typedef reg_t<0x40004c1c, 0x00000001, 2, ro_t> NF;
            /*
                Framing error
             */
            typedef reg_t<0x40004c1c, 0x00000001, 1, ro_t> FE;
            /*
                Parity error
             */
            typedef reg_t<0x40004c1c, 0x00000001, 0, ro_t> PE;
        };
        /*
            Interrupt flag clear register
         */
        namespace ICR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004c20, 0xffffffff, 0, rw_t> ICR_REG;
            /*
                Wakeup from Stop mode clear
              flag
             */
            typedef reg_t<0x40004c20, 0x00000001, 20, rw_t> WUCF;
            /*
                Character match clear flag
             */
            typedef reg_t<0x40004c20, 0x00000001, 17, rw_t> CMCF;
            /*
                End of timeout clear flag
             */
            typedef reg_t<0x40004c20, 0x00000001, 12, rw_t> EOBCF;
            /*
                Receiver timeout clear
              flag
             */
            typedef reg_t<0x40004c20, 0x00000001, 11, rw_t> RTOCF;
            /*
                CTS clear flag
             */
            typedef reg_t<0x40004c20, 0x00000001, 9, rw_t> CTSCF;
            /*
                LIN break detection clear
              flag
             */
            typedef reg_t<0x40004c20, 0x00000001, 8, rw_t> LBDCF;
            /*
                Transmission complete clear
              flag
             */
            typedef reg_t<0x40004c20, 0x00000001, 6, rw_t> TCCF;
            /*
                Idle line detected clear
              flag
             */
            typedef reg_t<0x40004c20, 0x00000001, 4, rw_t> IDLECF;
            /*
                Overrun error clear flag
             */
            typedef reg_t<0x40004c20, 0x00000001, 3, rw_t> ORECF;
            /*
                Noise detected clear flag
             */
            typedef reg_t<0x40004c20, 0x00000001, 2, rw_t> NCF;
            /*
                Framing error clear flag
             */
            typedef reg_t<0x40004c20, 0x00000001, 1, rw_t> FECF;
            /*
                Parity error clear flag
             */
            typedef reg_t<0x40004c20, 0x00000001, 0, rw_t> PECF;
        };
        /*
            Receive data register
         */
        namespace RDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004c24, 0xffffffff, 0, ro_t> RDR_REG;
            /*
                Receive data value
             */
            typedef reg_t<0x40004c24, 0x000001ff, 0, ro_t> RDR;
        };
        /*
            Transmit data register
         */
        namespace TDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004c28, 0xffffffff, 0, rw_t> TDR_REG;
            /*
                Transmit data value
             */
            typedef reg_t<0x40004c28, 0x000001ff, 0, rw_t> TDR;
        };
    };
    /*
        Universal synchronous asynchronous receiver
      transmitter
     */
    namespace UART5 {
        /*
            Control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005000, 0xffffffff, 0, rw_t> CR1_REG;
            /*
                End of Block interrupt
              enable
             */
            typedef reg_t<0x40005000, 0x00000001, 27, rw_t> EOBIE;
            /*
                Receiver timeout interrupt
              enable
             */
            typedef reg_t<0x40005000, 0x00000001, 26, rw_t> RTOIE;
            /*
                Driver Enable assertion
              time
             */
            typedef reg_t<0x40005000, 0x0000001f, 21, rw_t> DEAT;
            /*
                Driver Enable deassertion
              time
             */
            typedef reg_t<0x40005000, 0x0000001f, 16, rw_t> DEDT;
            /*
                Oversampling mode
             */
            typedef reg_t<0x40005000, 0x00000001, 15, rw_t> OVER8;
            /*
                Character match interrupt
              enable
             */
            typedef reg_t<0x40005000, 0x00000001, 14, rw_t> CMIE;
            /*
                Mute mode enable
             */
            typedef reg_t<0x40005000, 0x00000001, 13, rw_t> MME;
            /*
                Word length
             */
            typedef reg_t<0x40005000, 0x00000001, 12, rw_t> M;
            /*
                Receiver wakeup method
             */
            typedef reg_t<0x40005000, 0x00000001, 11, rw_t> WAKE;
            /*
                Parity control enable
             */
            typedef reg_t<0x40005000, 0x00000001, 10, rw_t> PCE;
            /*
                Parity selection
             */
            typedef reg_t<0x40005000, 0x00000001, 9, rw_t> PS;
            /*
                PE interrupt enable
             */
            typedef reg_t<0x40005000, 0x00000001, 8, rw_t> PEIE;
            /*
                interrupt enable
             */
            typedef reg_t<0x40005000, 0x00000001, 7, rw_t> TXEIE;
            /*
                Transmission complete interrupt
              enable
             */
            typedef reg_t<0x40005000, 0x00000001, 6, rw_t> TCIE;
            /*
                RXNE interrupt enable
             */
            typedef reg_t<0x40005000, 0x00000001, 5, rw_t> RXNEIE;
            /*
                IDLE interrupt enable
             */
            typedef reg_t<0x40005000, 0x00000001, 4, rw_t> IDLEIE;
            /*
                Transmitter enable
             */
            typedef reg_t<0x40005000, 0x00000001, 3, rw_t> TE;
            /*
                Receiver enable
             */
            typedef reg_t<0x40005000, 0x00000001, 2, rw_t> RE;
            /*
                USART enable in Stop mode
             */
            typedef reg_t<0x40005000, 0x00000001, 1, rw_t> UESM;
            /*
                USART enable
             */
            typedef reg_t<0x40005000, 0x00000001, 0, rw_t> UE;
        };
        /*
            Control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005004, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                Address of the USART node
             */
            typedef reg_t<0x40005004, 0x0000000f, 28, rw_t> ADD4;
            /*
                Address of the USART node
             */
            typedef reg_t<0x40005004, 0x0000000f, 24, rw_t> ADD0;
            /*
                Receiver timeout enable
             */
            typedef reg_t<0x40005004, 0x00000001, 23, rw_t> RTOEN;
            /*
                Auto baud rate mode
             */
            typedef reg_t<0x40005004, 0x00000003, 21, rw_t> ABRMOD;
            /*
                Auto baud rate enable
             */
            typedef reg_t<0x40005004, 0x00000001, 20, rw_t> ABREN;
            /*
                Most significant bit first
             */
            typedef reg_t<0x40005004, 0x00000001, 19, rw_t> MSBFIRST;
            /*
                Binary data inversion
             */
            typedef reg_t<0x40005004, 0x00000001, 18, rw_t> DATAINV;
            /*
                TX pin active level
              inversion
             */
            typedef reg_t<0x40005004, 0x00000001, 17, rw_t> TXINV;
            /*
                RX pin active level
              inversion
             */
            typedef reg_t<0x40005004, 0x00000001, 16, rw_t> RXINV;
            /*
                Swap TX/RX pins
             */
            typedef reg_t<0x40005004, 0x00000001, 15, rw_t> SWAP;
            /*
                LIN mode enable
             */
            typedef reg_t<0x40005004, 0x00000001, 14, rw_t> LINEN;
            /*
                STOP bits
             */
            typedef reg_t<0x40005004, 0x00000003, 12, rw_t> STOP;
            /*
                Clock enable
             */
            typedef reg_t<0x40005004, 0x00000001, 11, rw_t> CLKEN;
            /*
                Clock polarity
             */
            typedef reg_t<0x40005004, 0x00000001, 10, rw_t> CPOL;
            /*
                Clock phase
             */
            typedef reg_t<0x40005004, 0x00000001, 9, rw_t> CPHA;
            /*
                Last bit clock pulse
             */
            typedef reg_t<0x40005004, 0x00000001, 8, rw_t> LBCL;
            /*
                LIN break detection interrupt
              enable
             */
            typedef reg_t<0x40005004, 0x00000001, 6, rw_t> LBDIE;
            /*
                LIN break detection length
             */
            typedef reg_t<0x40005004, 0x00000001, 5, rw_t> LBDL;
            /*
                7-bit Address Detection/4-bit Address
              Detection
             */
            typedef reg_t<0x40005004, 0x00000001, 4, rw_t> ADDM7;
        };
        /*
            Control register 3
         */
        namespace CR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005008, 0xffffffff, 0, rw_t> CR3_REG;
            /*
                Wakeup from Stop mode interrupt
              enable
             */
            typedef reg_t<0x40005008, 0x00000001, 22, rw_t> WUFIE;
            /*
                Wakeup from Stop mode interrupt flag
              selection
             */
            typedef reg_t<0x40005008, 0x00000003, 20, rw_t> WUS;
            /*
                Smartcard auto-retry count
             */
            typedef reg_t<0x40005008, 0x00000007, 17, rw_t> SCARCNT;
            /*
                Driver enable polarity
              selection
             */
            typedef reg_t<0x40005008, 0x00000001, 15, rw_t> DEP;
            /*
                Driver enable mode
             */
            typedef reg_t<0x40005008, 0x00000001, 14, rw_t> DEM;
            /*
                DMA Disable on Reception
              Error
             */
            typedef reg_t<0x40005008, 0x00000001, 13, rw_t> DDRE;
            /*
                Overrun Disable
             */
            typedef reg_t<0x40005008, 0x00000001, 12, rw_t> OVRDIS;
            /*
                One sample bit method
              enable
             */
            typedef reg_t<0x40005008, 0x00000001, 11, rw_t> ONEBIT;
            /*
                CTS interrupt enable
             */
            typedef reg_t<0x40005008, 0x00000001, 10, rw_t> CTSIE;
            /*
                CTS enable
             */
            typedef reg_t<0x40005008, 0x00000001, 9, rw_t> CTSE;
            /*
                RTS enable
             */
            typedef reg_t<0x40005008, 0x00000001, 8, rw_t> RTSE;
            /*
                DMA enable transmitter
             */
            typedef reg_t<0x40005008, 0x00000001, 7, rw_t> DMAT;
            /*
                DMA enable receiver
             */
            typedef reg_t<0x40005008, 0x00000001, 6, rw_t> DMAR;
            /*
                Smartcard mode enable
             */
            typedef reg_t<0x40005008, 0x00000001, 5, rw_t> SCEN;
            /*
                Smartcard NACK enable
             */
            typedef reg_t<0x40005008, 0x00000001, 4, rw_t> NACK;
            /*
                Half-duplex selection
             */
            typedef reg_t<0x40005008, 0x00000001, 3, rw_t> HDSEL;
            /*
                IrDA low-power
             */
            typedef reg_t<0x40005008, 0x00000001, 2, rw_t> IRLP;
            /*
                IrDA mode enable
             */
            typedef reg_t<0x40005008, 0x00000001, 1, rw_t> IREN;
            /*
                Error interrupt enable
             */
            typedef reg_t<0x40005008, 0x00000001, 0, rw_t> EIE;
        };
        /*
            Baud rate register
         */
        namespace BRR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000500c, 0xffffffff, 0, rw_t> BRR_REG;
            /*
                mantissa of USARTDIV
             */
            typedef reg_t<0x4000500c, 0x00000fff, 4, rw_t> DIV_Mantissa;
            /*
                fraction of USARTDIV
             */
            typedef reg_t<0x4000500c, 0x0000000f, 0, rw_t> DIV_Fraction;
        };
        /*
            Guard time and prescaler
          register
         */
        namespace GTPR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005010, 0xffffffff, 0, rw_t> GTPR_REG;
            /*
                Guard time value
             */
            typedef reg_t<0x40005010, 0x000000ff, 8, rw_t> GT;
            /*
                Prescaler value
             */
            typedef reg_t<0x40005010, 0x000000ff, 0, rw_t> PSC;
        };
        /*
            Receiver timeout register
         */
        namespace RTOR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005014, 0xffffffff, 0, rw_t> RTOR_REG;
            /*
                Block Length
             */
            typedef reg_t<0x40005014, 0x000000ff, 24, rw_t> BLEN;
            /*
                Receiver timeout value
             */
            typedef reg_t<0x40005014, 0x00ffffff, 0, rw_t> RTO;
        };
        /*
            Request register
         */
        namespace RQR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005018, 0xffffffff, 0, rw_t> RQR_REG;
            /*
                Transmit data flush
              request
             */
            typedef reg_t<0x40005018, 0x00000001, 4, rw_t> TXFRQ;
            /*
                Receive data flush request
             */
            typedef reg_t<0x40005018, 0x00000001, 3, rw_t> RXFRQ;
            /*
                Mute mode request
             */
            typedef reg_t<0x40005018, 0x00000001, 2, rw_t> MMRQ;
            /*
                Send break request
             */
            typedef reg_t<0x40005018, 0x00000001, 1, rw_t> SBKRQ;
            /*
                Auto baud rate request
             */
            typedef reg_t<0x40005018, 0x00000001, 0, rw_t> ABRRQ;
        };
        /*
            Interrupt & status
          register
         */
        namespace ISR {

            static constexpr uint32_t RESETVALUE = 0x000000c0;
            typedef reg_t<0x4000501c, 0xffffffff, 0, ro_t> ISR_REG;
            /*
                Receive enable acknowledge
              flag
             */
            typedef reg_t<0x4000501c, 0x00000001, 22, ro_t> REACK;
            /*
                Transmit enable acknowledge
              flag
             */
            typedef reg_t<0x4000501c, 0x00000001, 21, ro_t> TEACK;
            /*
                Wakeup from Stop mode flag
             */
            typedef reg_t<0x4000501c, 0x00000001, 20, ro_t> WUF;
            /*
                Receiver wakeup from Mute
              mode
             */
            typedef reg_t<0x4000501c, 0x00000001, 19, ro_t> RWU;
            /*
                Send break flag
             */
            typedef reg_t<0x4000501c, 0x00000001, 18, ro_t> SBKF;
            /*
                character match flag
             */
            typedef reg_t<0x4000501c, 0x00000001, 17, ro_t> CMF;
            /*
                Busy flag
             */
            typedef reg_t<0x4000501c, 0x00000001, 16, ro_t> BUSY;
            /*
                Auto baud rate flag
             */
            typedef reg_t<0x4000501c, 0x00000001, 15, ro_t> ABRF;
            /*
                Auto baud rate error
             */
            typedef reg_t<0x4000501c, 0x00000001, 14, ro_t> ABRE;
            /*
                End of block flag
             */
            typedef reg_t<0x4000501c, 0x00000001, 12, ro_t> EOBF;
            /*
                Receiver timeout
             */
            typedef reg_t<0x4000501c, 0x00000001, 11, ro_t> RTOF;
            /*
                CTS flag
             */
            typedef reg_t<0x4000501c, 0x00000001, 10, ro_t> CTS;
            /*
                CTS interrupt flag
             */
            typedef reg_t<0x4000501c, 0x00000001, 9, ro_t> CTSIF;
            /*
                LIN break detection flag
             */
            typedef reg_t<0x4000501c, 0x00000001, 8, ro_t> LBDF;
            /*
                Transmit data register
              empty
             */
            typedef reg_t<0x4000501c, 0x00000001, 7, ro_t> TXE;
            /*
                Transmission complete
             */
            typedef reg_t<0x4000501c, 0x00000001, 6, ro_t> TC;
            /*
                Read data register not
              empty
             */
            typedef reg_t<0x4000501c, 0x00000001, 5, ro_t> RXNE;
            /*
                Idle line detected
             */
            typedef reg_t<0x4000501c, 0x00000001, 4, ro_t> IDLE;
            /*
                Overrun error
             */
            typedef reg_t<0x4000501c, 0x00000001, 3, ro_t> ORE;
            /*
                Noise detected flag
             */
            typedef reg_t<0x4000501c, 0x00000001, 2, ro_t> NF;
            /*
                Framing error
             */
            typedef reg_t<0x4000501c, 0x00000001, 1, ro_t> FE;
            /*
                Parity error
             */
            typedef reg_t<0x4000501c, 0x00000001, 0, ro_t> PE;
        };
        /*
            Interrupt flag clear register
         */
        namespace ICR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005020, 0xffffffff, 0, rw_t> ICR_REG;
            /*
                Wakeup from Stop mode clear
              flag
             */
            typedef reg_t<0x40005020, 0x00000001, 20, rw_t> WUCF;
            /*
                Character match clear flag
             */
            typedef reg_t<0x40005020, 0x00000001, 17, rw_t> CMCF;
            /*
                End of timeout clear flag
             */
            typedef reg_t<0x40005020, 0x00000001, 12, rw_t> EOBCF;
            /*
                Receiver timeout clear
              flag
             */
            typedef reg_t<0x40005020, 0x00000001, 11, rw_t> RTOCF;
            /*
                CTS clear flag
             */
            typedef reg_t<0x40005020, 0x00000001, 9, rw_t> CTSCF;
            /*
                LIN break detection clear
              flag
             */
            typedef reg_t<0x40005020, 0x00000001, 8, rw_t> LBDCF;
            /*
                Transmission complete clear
              flag
             */
            typedef reg_t<0x40005020, 0x00000001, 6, rw_t> TCCF;
            /*
                Idle line detected clear
              flag
             */
            typedef reg_t<0x40005020, 0x00000001, 4, rw_t> IDLECF;
            /*
                Overrun error clear flag
             */
            typedef reg_t<0x40005020, 0x00000001, 3, rw_t> ORECF;
            /*
                Noise detected clear flag
             */
            typedef reg_t<0x40005020, 0x00000001, 2, rw_t> NCF;
            /*
                Framing error clear flag
             */
            typedef reg_t<0x40005020, 0x00000001, 1, rw_t> FECF;
            /*
                Parity error clear flag
             */
            typedef reg_t<0x40005020, 0x00000001, 0, rw_t> PECF;
        };
        /*
            Receive data register
         */
        namespace RDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005024, 0xffffffff, 0, ro_t> RDR_REG;
            /*
                Receive data value
             */
            typedef reg_t<0x40005024, 0x000001ff, 0, ro_t> RDR;
        };
        /*
            Transmit data register
         */
        namespace TDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005028, 0xffffffff, 0, rw_t> TDR_REG;
            /*
                Transmit data value
             */
            typedef reg_t<0x40005028, 0x000001ff, 0, rw_t> TDR;
        };
    };
    /*
        Serial peripheral interface/Inter-IC
      sound
     */
    namespace SPI1 {
        /*
            control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013000, 0xffffffff, 0, rw_t> CR1_REG;
            /*
                Bidirectional data mode
              enable
             */
            typedef reg_t<0x40013000, 0x00000001, 15, rw_t> BIDIMODE;
            /*
                Output enable in bidirectional
              mode
             */
            typedef reg_t<0x40013000, 0x00000001, 14, rw_t> BIDIOE;
            /*
                Hardware CRC calculation
              enable
             */
            typedef reg_t<0x40013000, 0x00000001, 13, rw_t> CRCEN;
            /*
                CRC transfer next
             */
            typedef reg_t<0x40013000, 0x00000001, 12, rw_t> CRCNEXT;
            /*
                CRC length
             */
            typedef reg_t<0x40013000, 0x00000001, 11, rw_t> CRCL;
            /*
                Receive only
             */
            typedef reg_t<0x40013000, 0x00000001, 10, rw_t> RXONLY;
            /*
                Software slave management
             */
            typedef reg_t<0x40013000, 0x00000001, 9, rw_t> SSM;
            /*
                Internal slave select
             */
            typedef reg_t<0x40013000, 0x00000001, 8, rw_t> SSI;
            /*
                Frame format
             */
            typedef reg_t<0x40013000, 0x00000001, 7, rw_t> LSBFIRST;
            /*
                SPI enable
             */
            typedef reg_t<0x40013000, 0x00000001, 6, rw_t> SPE;
            /*
                Baud rate control
             */
            typedef reg_t<0x40013000, 0x00000007, 3, rw_t> BR;
            /*
                Master selection
             */
            typedef reg_t<0x40013000, 0x00000001, 2, rw_t> MSTR;
            /*
                Clock polarity
             */
            typedef reg_t<0x40013000, 0x00000001, 1, rw_t> CPOL;
            /*
                Clock phase
             */
            typedef reg_t<0x40013000, 0x00000001, 0, rw_t> CPHA;
        };
        /*
            control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013004, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                Rx buffer DMA enable
             */
            typedef reg_t<0x40013004, 0x00000001, 0, rw_t> RXDMAEN;
            /*
                Tx buffer DMA enable
             */
            typedef reg_t<0x40013004, 0x00000001, 1, rw_t> TXDMAEN;
            /*
                SS output enable
             */
            typedef reg_t<0x40013004, 0x00000001, 2, rw_t> SSOE;
            /*
                NSS pulse management
             */
            typedef reg_t<0x40013004, 0x00000001, 3, rw_t> NSSP;
            /*
                Frame format
             */
            typedef reg_t<0x40013004, 0x00000001, 4, rw_t> FRF;
            /*
                Error interrupt enable
             */
            typedef reg_t<0x40013004, 0x00000001, 5, rw_t> ERRIE;
            /*
                RX buffer not empty interrupt
              enable
             */
            typedef reg_t<0x40013004, 0x00000001, 6, rw_t> RXNEIE;
            /*
                Tx buffer empty interrupt
              enable
             */
            typedef reg_t<0x40013004, 0x00000001, 7, rw_t> TXEIE;
            /*
                Data size
             */
            typedef reg_t<0x40013004, 0x0000000f, 8, rw_t> DS;
            /*
                FIFO reception threshold
             */
            typedef reg_t<0x40013004, 0x00000001, 12, rw_t> FRXTH;
            /*
                Last DMA transfer for
              reception
             */
            typedef reg_t<0x40013004, 0x00000001, 13, rw_t> LDMA_RX;
            /*
                Last DMA transfer for
              transmission
             */
            typedef reg_t<0x40013004, 0x00000001, 14, rw_t> LDMA_TX;
        };
        /*
            status register
         */
        namespace SR {

            static constexpr uint32_t RESETVALUE = 0x00000002;
            /*
                Receive buffer not empty
             */
            typedef reg_t<0x40013008, 0x00000001, 0, ro_t> RXNE;
            /*
                Transmit buffer empty
             */
            typedef reg_t<0x40013008, 0x00000001, 1, ro_t> TXE;
            /*
                Channel side
             */
            typedef reg_t<0x40013008, 0x00000001, 2, ro_t> CHSIDE;
            /*
                Underrun flag
             */
            typedef reg_t<0x40013008, 0x00000001, 3, ro_t> UDR;
            /*
                CRC error flag
             */
            typedef reg_t<0x40013008, 0x00000001, 4, rw_t> CRCERR;
            /*
                Mode fault
             */
            typedef reg_t<0x40013008, 0x00000001, 5, ro_t> MODF;
            /*
                Overrun flag
             */
            typedef reg_t<0x40013008, 0x00000001, 6, ro_t> OVR;
            /*
                Busy flag
             */
            typedef reg_t<0x40013008, 0x00000001, 7, ro_t> BSY;
            /*
                TI frame format error
             */
            typedef reg_t<0x40013008, 0x00000001, 8, ro_t> TIFRFE;
            /*
                FIFO reception level
             */
            typedef reg_t<0x40013008, 0x00000003, 9, ro_t> FRLVL;
            /*
                FIFO transmission level
             */
            typedef reg_t<0x40013008, 0x00000003, 11, ro_t> FTLVL;
        };
        /*
            data register
         */
        namespace DR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001300c, 0xffffffff, 0, rw_t> DR_REG;
            /*
                Data register
             */
            typedef reg_t<0x4001300c, 0x0000ffff, 0, rw_t> DR;
        };
        /*
            CRC polynomial register
         */
        namespace CRCPR {

            static constexpr uint32_t RESETVALUE = 0x00000007;
            typedef reg_t<0x40013010, 0xffffffff, 0, rw_t> CRCPR_REG;
            /*
                CRC polynomial register
             */
            typedef reg_t<0x40013010, 0x0000ffff, 0, rw_t> CRCPOLY;
        };
        /*
            RX CRC register
         */
        namespace RXCRCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013014, 0xffffffff, 0, ro_t> RXCRCR_REG;
            /*
                Rx CRC register
             */
            typedef reg_t<0x40013014, 0x0000ffff, 0, ro_t> RxCRC;
        };
        /*
            TX CRC register
         */
        namespace TXCRCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013018, 0xffffffff, 0, ro_t> TXCRCR_REG;
            /*
                Tx CRC register
             */
            typedef reg_t<0x40013018, 0x0000ffff, 0, ro_t> TxCRC;
        };
        /*
            I2S configuration register
         */
        namespace I2SCFGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001301c, 0xffffffff, 0, rw_t> I2SCFGR_REG;
            /*
                I2S mode selection
             */
            typedef reg_t<0x4001301c, 0x00000001, 11, rw_t> I2SMOD;
            /*
                I2S Enable
             */
            typedef reg_t<0x4001301c, 0x00000001, 10, rw_t> I2SE;
            /*
                I2S configuration mode
             */
            typedef reg_t<0x4001301c, 0x00000003, 8, rw_t> I2SCFG;
            /*
                PCM frame synchronization
             */
            typedef reg_t<0x4001301c, 0x00000001, 7, rw_t> PCMSYNC;
            /*
                I2S standard selection
             */
            typedef reg_t<0x4001301c, 0x00000003, 4, rw_t> I2SSTD;
            /*
                Steady state clock
              polarity
             */
            typedef reg_t<0x4001301c, 0x00000001, 3, rw_t> CKPOL;
            /*
                Data length to be
              transferred
             */
            typedef reg_t<0x4001301c, 0x00000003, 1, rw_t> DATLEN;
            /*
                Channel length (number of bits per audio
              channel)
             */
            typedef reg_t<0x4001301c, 0x00000001, 0, rw_t> CHLEN;
        };
        /*
            I2S prescaler register
         */
        namespace I2SPR {

            static constexpr uint32_t RESETVALUE = 0x00000010;
            typedef reg_t<0x40013020, 0xffffffff, 0, rw_t> I2SPR_REG;
            /*
                Master clock output enable
             */
            typedef reg_t<0x40013020, 0x00000001, 9, rw_t> MCKOE;
            /*
                Odd factor for the
              prescaler
             */
            typedef reg_t<0x40013020, 0x00000001, 8, rw_t> ODD;
            /*
                I2S Linear prescaler
             */
            typedef reg_t<0x40013020, 0x000000ff, 0, rw_t> I2SDIV;
        };
    };
    /*
        Serial peripheral interface/Inter-IC
      sound
     */
    namespace SPI2 {
        /*
            control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40003800, 0xffffffff, 0, rw_t> CR1_REG;
            /*
                Bidirectional data mode
              enable
             */
            typedef reg_t<0x40003800, 0x00000001, 15, rw_t> BIDIMODE;
            /*
                Output enable in bidirectional
              mode
             */
            typedef reg_t<0x40003800, 0x00000001, 14, rw_t> BIDIOE;
            /*
                Hardware CRC calculation
              enable
             */
            typedef reg_t<0x40003800, 0x00000001, 13, rw_t> CRCEN;
            /*
                CRC transfer next
             */
            typedef reg_t<0x40003800, 0x00000001, 12, rw_t> CRCNEXT;
            /*
                CRC length
             */
            typedef reg_t<0x40003800, 0x00000001, 11, rw_t> CRCL;
            /*
                Receive only
             */
            typedef reg_t<0x40003800, 0x00000001, 10, rw_t> RXONLY;
            /*
                Software slave management
             */
            typedef reg_t<0x40003800, 0x00000001, 9, rw_t> SSM;
            /*
                Internal slave select
             */
            typedef reg_t<0x40003800, 0x00000001, 8, rw_t> SSI;
            /*
                Frame format
             */
            typedef reg_t<0x40003800, 0x00000001, 7, rw_t> LSBFIRST;
            /*
                SPI enable
             */
            typedef reg_t<0x40003800, 0x00000001, 6, rw_t> SPE;
            /*
                Baud rate control
             */
            typedef reg_t<0x40003800, 0x00000007, 3, rw_t> BR;
            /*
                Master selection
             */
            typedef reg_t<0x40003800, 0x00000001, 2, rw_t> MSTR;
            /*
                Clock polarity
             */
            typedef reg_t<0x40003800, 0x00000001, 1, rw_t> CPOL;
            /*
                Clock phase
             */
            typedef reg_t<0x40003800, 0x00000001, 0, rw_t> CPHA;
        };
        /*
            control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40003804, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                Rx buffer DMA enable
             */
            typedef reg_t<0x40003804, 0x00000001, 0, rw_t> RXDMAEN;
            /*
                Tx buffer DMA enable
             */
            typedef reg_t<0x40003804, 0x00000001, 1, rw_t> TXDMAEN;
            /*
                SS output enable
             */
            typedef reg_t<0x40003804, 0x00000001, 2, rw_t> SSOE;
            /*
                NSS pulse management
             */
            typedef reg_t<0x40003804, 0x00000001, 3, rw_t> NSSP;
            /*
                Frame format
             */
            typedef reg_t<0x40003804, 0x00000001, 4, rw_t> FRF;
            /*
                Error interrupt enable
             */
            typedef reg_t<0x40003804, 0x00000001, 5, rw_t> ERRIE;
            /*
                RX buffer not empty interrupt
              enable
             */
            typedef reg_t<0x40003804, 0x00000001, 6, rw_t> RXNEIE;
            /*
                Tx buffer empty interrupt
              enable
             */
            typedef reg_t<0x40003804, 0x00000001, 7, rw_t> TXEIE;
            /*
                Data size
             */
            typedef reg_t<0x40003804, 0x0000000f, 8, rw_t> DS;
            /*
                FIFO reception threshold
             */
            typedef reg_t<0x40003804, 0x00000001, 12, rw_t> FRXTH;
            /*
                Last DMA transfer for
              reception
             */
            typedef reg_t<0x40003804, 0x00000001, 13, rw_t> LDMA_RX;
            /*
                Last DMA transfer for
              transmission
             */
            typedef reg_t<0x40003804, 0x00000001, 14, rw_t> LDMA_TX;
        };
        /*
            status register
         */
        namespace SR {

            static constexpr uint32_t RESETVALUE = 0x00000002;
            /*
                Receive buffer not empty
             */
            typedef reg_t<0x40003808, 0x00000001, 0, ro_t> RXNE;
            /*
                Transmit buffer empty
             */
            typedef reg_t<0x40003808, 0x00000001, 1, ro_t> TXE;
            /*
                Channel side
             */
            typedef reg_t<0x40003808, 0x00000001, 2, ro_t> CHSIDE;
            /*
                Underrun flag
             */
            typedef reg_t<0x40003808, 0x00000001, 3, ro_t> UDR;
            /*
                CRC error flag
             */
            typedef reg_t<0x40003808, 0x00000001, 4, rw_t> CRCERR;
            /*
                Mode fault
             */
            typedef reg_t<0x40003808, 0x00000001, 5, ro_t> MODF;
            /*
                Overrun flag
             */
            typedef reg_t<0x40003808, 0x00000001, 6, ro_t> OVR;
            /*
                Busy flag
             */
            typedef reg_t<0x40003808, 0x00000001, 7, ro_t> BSY;
            /*
                TI frame format error
             */
            typedef reg_t<0x40003808, 0x00000001, 8, ro_t> TIFRFE;
            /*
                FIFO reception level
             */
            typedef reg_t<0x40003808, 0x00000003, 9, ro_t> FRLVL;
            /*
                FIFO transmission level
             */
            typedef reg_t<0x40003808, 0x00000003, 11, ro_t> FTLVL;
        };
        /*
            data register
         */
        namespace DR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000380c, 0xffffffff, 0, rw_t> DR_REG;
            /*
                Data register
             */
            typedef reg_t<0x4000380c, 0x0000ffff, 0, rw_t> DR;
        };
        /*
            CRC polynomial register
         */
        namespace CRCPR {

            static constexpr uint32_t RESETVALUE = 0x00000007;
            typedef reg_t<0x40003810, 0xffffffff, 0, rw_t> CRCPR_REG;
            /*
                CRC polynomial register
             */
            typedef reg_t<0x40003810, 0x0000ffff, 0, rw_t> CRCPOLY;
        };
        /*
            RX CRC register
         */
        namespace RXCRCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40003814, 0xffffffff, 0, ro_t> RXCRCR_REG;
            /*
                Rx CRC register
             */
            typedef reg_t<0x40003814, 0x0000ffff, 0, ro_t> RxCRC;
        };
        /*
            TX CRC register
         */
        namespace TXCRCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40003818, 0xffffffff, 0, ro_t> TXCRCR_REG;
            /*
                Tx CRC register
             */
            typedef reg_t<0x40003818, 0x0000ffff, 0, ro_t> TxCRC;
        };
        /*
            I2S configuration register
         */
        namespace I2SCFGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000381c, 0xffffffff, 0, rw_t> I2SCFGR_REG;
            /*
                I2S mode selection
             */
            typedef reg_t<0x4000381c, 0x00000001, 11, rw_t> I2SMOD;
            /*
                I2S Enable
             */
            typedef reg_t<0x4000381c, 0x00000001, 10, rw_t> I2SE;
            /*
                I2S configuration mode
             */
            typedef reg_t<0x4000381c, 0x00000003, 8, rw_t> I2SCFG;
            /*
                PCM frame synchronization
             */
            typedef reg_t<0x4000381c, 0x00000001, 7, rw_t> PCMSYNC;
            /*
                I2S standard selection
             */
            typedef reg_t<0x4000381c, 0x00000003, 4, rw_t> I2SSTD;
            /*
                Steady state clock
              polarity
             */
            typedef reg_t<0x4000381c, 0x00000001, 3, rw_t> CKPOL;
            /*
                Data length to be
              transferred
             */
            typedef reg_t<0x4000381c, 0x00000003, 1, rw_t> DATLEN;
            /*
                Channel length (number of bits per audio
              channel)
             */
            typedef reg_t<0x4000381c, 0x00000001, 0, rw_t> CHLEN;
        };
        /*
            I2S prescaler register
         */
        namespace I2SPR {

            static constexpr uint32_t RESETVALUE = 0x00000010;
            typedef reg_t<0x40003820, 0xffffffff, 0, rw_t> I2SPR_REG;
            /*
                Master clock output enable
             */
            typedef reg_t<0x40003820, 0x00000001, 9, rw_t> MCKOE;
            /*
                Odd factor for the
              prescaler
             */
            typedef reg_t<0x40003820, 0x00000001, 8, rw_t> ODD;
            /*
                I2S Linear prescaler
             */
            typedef reg_t<0x40003820, 0x000000ff, 0, rw_t> I2SDIV;
        };
    };
    /*
        Serial peripheral interface/Inter-IC
      sound
     */
    namespace SPI3 {
        /*
            control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40003c00, 0xffffffff, 0, rw_t> CR1_REG;
            /*
                Bidirectional data mode
              enable
             */
            typedef reg_t<0x40003c00, 0x00000001, 15, rw_t> BIDIMODE;
            /*
                Output enable in bidirectional
              mode
             */
            typedef reg_t<0x40003c00, 0x00000001, 14, rw_t> BIDIOE;
            /*
                Hardware CRC calculation
              enable
             */
            typedef reg_t<0x40003c00, 0x00000001, 13, rw_t> CRCEN;
            /*
                CRC transfer next
             */
            typedef reg_t<0x40003c00, 0x00000001, 12, rw_t> CRCNEXT;
            /*
                CRC length
             */
            typedef reg_t<0x40003c00, 0x00000001, 11, rw_t> CRCL;
            /*
                Receive only
             */
            typedef reg_t<0x40003c00, 0x00000001, 10, rw_t> RXONLY;
            /*
                Software slave management
             */
            typedef reg_t<0x40003c00, 0x00000001, 9, rw_t> SSM;
            /*
                Internal slave select
             */
            typedef reg_t<0x40003c00, 0x00000001, 8, rw_t> SSI;
            /*
                Frame format
             */
            typedef reg_t<0x40003c00, 0x00000001, 7, rw_t> LSBFIRST;
            /*
                SPI enable
             */
            typedef reg_t<0x40003c00, 0x00000001, 6, rw_t> SPE;
            /*
                Baud rate control
             */
            typedef reg_t<0x40003c00, 0x00000007, 3, rw_t> BR;
            /*
                Master selection
             */
            typedef reg_t<0x40003c00, 0x00000001, 2, rw_t> MSTR;
            /*
                Clock polarity
             */
            typedef reg_t<0x40003c00, 0x00000001, 1, rw_t> CPOL;
            /*
                Clock phase
             */
            typedef reg_t<0x40003c00, 0x00000001, 0, rw_t> CPHA;
        };
        /*
            control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40003c04, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                Rx buffer DMA enable
             */
            typedef reg_t<0x40003c04, 0x00000001, 0, rw_t> RXDMAEN;
            /*
                Tx buffer DMA enable
             */
            typedef reg_t<0x40003c04, 0x00000001, 1, rw_t> TXDMAEN;
            /*
                SS output enable
             */
            typedef reg_t<0x40003c04, 0x00000001, 2, rw_t> SSOE;
            /*
                NSS pulse management
             */
            typedef reg_t<0x40003c04, 0x00000001, 3, rw_t> NSSP;
            /*
                Frame format
             */
            typedef reg_t<0x40003c04, 0x00000001, 4, rw_t> FRF;
            /*
                Error interrupt enable
             */
            typedef reg_t<0x40003c04, 0x00000001, 5, rw_t> ERRIE;
            /*
                RX buffer not empty interrupt
              enable
             */
            typedef reg_t<0x40003c04, 0x00000001, 6, rw_t> RXNEIE;
            /*
                Tx buffer empty interrupt
              enable
             */
            typedef reg_t<0x40003c04, 0x00000001, 7, rw_t> TXEIE;
            /*
                Data size
             */
            typedef reg_t<0x40003c04, 0x0000000f, 8, rw_t> DS;
            /*
                FIFO reception threshold
             */
            typedef reg_t<0x40003c04, 0x00000001, 12, rw_t> FRXTH;
            /*
                Last DMA transfer for
              reception
             */
            typedef reg_t<0x40003c04, 0x00000001, 13, rw_t> LDMA_RX;
            /*
                Last DMA transfer for
              transmission
             */
            typedef reg_t<0x40003c04, 0x00000001, 14, rw_t> LDMA_TX;
        };
        /*
            status register
         */
        namespace SR {

            static constexpr uint32_t RESETVALUE = 0x00000002;
            /*
                Receive buffer not empty
             */
            typedef reg_t<0x40003c08, 0x00000001, 0, ro_t> RXNE;
            /*
                Transmit buffer empty
             */
            typedef reg_t<0x40003c08, 0x00000001, 1, ro_t> TXE;
            /*
                Channel side
             */
            typedef reg_t<0x40003c08, 0x00000001, 2, ro_t> CHSIDE;
            /*
                Underrun flag
             */
            typedef reg_t<0x40003c08, 0x00000001, 3, ro_t> UDR;
            /*
                CRC error flag
             */
            typedef reg_t<0x40003c08, 0x00000001, 4, rw_t> CRCERR;
            /*
                Mode fault
             */
            typedef reg_t<0x40003c08, 0x00000001, 5, ro_t> MODF;
            /*
                Overrun flag
             */
            typedef reg_t<0x40003c08, 0x00000001, 6, ro_t> OVR;
            /*
                Busy flag
             */
            typedef reg_t<0x40003c08, 0x00000001, 7, ro_t> BSY;
            /*
                TI frame format error
             */
            typedef reg_t<0x40003c08, 0x00000001, 8, ro_t> TIFRFE;
            /*
                FIFO reception level
             */
            typedef reg_t<0x40003c08, 0x00000003, 9, ro_t> FRLVL;
            /*
                FIFO transmission level
             */
            typedef reg_t<0x40003c08, 0x00000003, 11, ro_t> FTLVL;
        };
        /*
            data register
         */
        namespace DR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40003c0c, 0xffffffff, 0, rw_t> DR_REG;
            /*
                Data register
             */
            typedef reg_t<0x40003c0c, 0x0000ffff, 0, rw_t> DR;
        };
        /*
            CRC polynomial register
         */
        namespace CRCPR {

            static constexpr uint32_t RESETVALUE = 0x00000007;
            typedef reg_t<0x40003c10, 0xffffffff, 0, rw_t> CRCPR_REG;
            /*
                CRC polynomial register
             */
            typedef reg_t<0x40003c10, 0x0000ffff, 0, rw_t> CRCPOLY;
        };
        /*
            RX CRC register
         */
        namespace RXCRCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40003c14, 0xffffffff, 0, ro_t> RXCRCR_REG;
            /*
                Rx CRC register
             */
            typedef reg_t<0x40003c14, 0x0000ffff, 0, ro_t> RxCRC;
        };
        /*
            TX CRC register
         */
        namespace TXCRCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40003c18, 0xffffffff, 0, ro_t> TXCRCR_REG;
            /*
                Tx CRC register
             */
            typedef reg_t<0x40003c18, 0x0000ffff, 0, ro_t> TxCRC;
        };
        /*
            I2S configuration register
         */
        namespace I2SCFGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40003c1c, 0xffffffff, 0, rw_t> I2SCFGR_REG;
            /*
                I2S mode selection
             */
            typedef reg_t<0x40003c1c, 0x00000001, 11, rw_t> I2SMOD;
            /*
                I2S Enable
             */
            typedef reg_t<0x40003c1c, 0x00000001, 10, rw_t> I2SE;
            /*
                I2S configuration mode
             */
            typedef reg_t<0x40003c1c, 0x00000003, 8, rw_t> I2SCFG;
            /*
                PCM frame synchronization
             */
            typedef reg_t<0x40003c1c, 0x00000001, 7, rw_t> PCMSYNC;
            /*
                I2S standard selection
             */
            typedef reg_t<0x40003c1c, 0x00000003, 4, rw_t> I2SSTD;
            /*
                Steady state clock
              polarity
             */
            typedef reg_t<0x40003c1c, 0x00000001, 3, rw_t> CKPOL;
            /*
                Data length to be
              transferred
             */
            typedef reg_t<0x40003c1c, 0x00000003, 1, rw_t> DATLEN;
            /*
                Channel length (number of bits per audio
              channel)
             */
            typedef reg_t<0x40003c1c, 0x00000001, 0, rw_t> CHLEN;
        };
        /*
            I2S prescaler register
         */
        namespace I2SPR {

            static constexpr uint32_t RESETVALUE = 0x00000010;
            typedef reg_t<0x40003c20, 0xffffffff, 0, rw_t> I2SPR_REG;
            /*
                Master clock output enable
             */
            typedef reg_t<0x40003c20, 0x00000001, 9, rw_t> MCKOE;
            /*
                Odd factor for the
              prescaler
             */
            typedef reg_t<0x40003c20, 0x00000001, 8, rw_t> ODD;
            /*
                I2S Linear prescaler
             */
            typedef reg_t<0x40003c20, 0x000000ff, 0, rw_t> I2SDIV;
        };
    };
    /*
        Serial peripheral interface/Inter-IC
      sound
     */
    namespace I2S2ext {
        /*
            control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40003400, 0xffffffff, 0, rw_t> CR1_REG;
            /*
                Bidirectional data mode
              enable
             */
            typedef reg_t<0x40003400, 0x00000001, 15, rw_t> BIDIMODE;
            /*
                Output enable in bidirectional
              mode
             */
            typedef reg_t<0x40003400, 0x00000001, 14, rw_t> BIDIOE;
            /*
                Hardware CRC calculation
              enable
             */
            typedef reg_t<0x40003400, 0x00000001, 13, rw_t> CRCEN;
            /*
                CRC transfer next
             */
            typedef reg_t<0x40003400, 0x00000001, 12, rw_t> CRCNEXT;
            /*
                CRC length
             */
            typedef reg_t<0x40003400, 0x00000001, 11, rw_t> CRCL;
            /*
                Receive only
             */
            typedef reg_t<0x40003400, 0x00000001, 10, rw_t> RXONLY;
            /*
                Software slave management
             */
            typedef reg_t<0x40003400, 0x00000001, 9, rw_t> SSM;
            /*
                Internal slave select
             */
            typedef reg_t<0x40003400, 0x00000001, 8, rw_t> SSI;
            /*
                Frame format
             */
            typedef reg_t<0x40003400, 0x00000001, 7, rw_t> LSBFIRST;
            /*
                SPI enable
             */
            typedef reg_t<0x40003400, 0x00000001, 6, rw_t> SPE;
            /*
                Baud rate control
             */
            typedef reg_t<0x40003400, 0x00000007, 3, rw_t> BR;
            /*
                Master selection
             */
            typedef reg_t<0x40003400, 0x00000001, 2, rw_t> MSTR;
            /*
                Clock polarity
             */
            typedef reg_t<0x40003400, 0x00000001, 1, rw_t> CPOL;
            /*
                Clock phase
             */
            typedef reg_t<0x40003400, 0x00000001, 0, rw_t> CPHA;
        };
        /*
            control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40003404, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                Rx buffer DMA enable
             */
            typedef reg_t<0x40003404, 0x00000001, 0, rw_t> RXDMAEN;
            /*
                Tx buffer DMA enable
             */
            typedef reg_t<0x40003404, 0x00000001, 1, rw_t> TXDMAEN;
            /*
                SS output enable
             */
            typedef reg_t<0x40003404, 0x00000001, 2, rw_t> SSOE;
            /*
                NSS pulse management
             */
            typedef reg_t<0x40003404, 0x00000001, 3, rw_t> NSSP;
            /*
                Frame format
             */
            typedef reg_t<0x40003404, 0x00000001, 4, rw_t> FRF;
            /*
                Error interrupt enable
             */
            typedef reg_t<0x40003404, 0x00000001, 5, rw_t> ERRIE;
            /*
                RX buffer not empty interrupt
              enable
             */
            typedef reg_t<0x40003404, 0x00000001, 6, rw_t> RXNEIE;
            /*
                Tx buffer empty interrupt
              enable
             */
            typedef reg_t<0x40003404, 0x00000001, 7, rw_t> TXEIE;
            /*
                Data size
             */
            typedef reg_t<0x40003404, 0x0000000f, 8, rw_t> DS;
            /*
                FIFO reception threshold
             */
            typedef reg_t<0x40003404, 0x00000001, 12, rw_t> FRXTH;
            /*
                Last DMA transfer for
              reception
             */
            typedef reg_t<0x40003404, 0x00000001, 13, rw_t> LDMA_RX;
            /*
                Last DMA transfer for
              transmission
             */
            typedef reg_t<0x40003404, 0x00000001, 14, rw_t> LDMA_TX;
        };
        /*
            status register
         */
        namespace SR {

            static constexpr uint32_t RESETVALUE = 0x00000002;
            /*
                Receive buffer not empty
             */
            typedef reg_t<0x40003408, 0x00000001, 0, ro_t> RXNE;
            /*
                Transmit buffer empty
             */
            typedef reg_t<0x40003408, 0x00000001, 1, ro_t> TXE;
            /*
                Channel side
             */
            typedef reg_t<0x40003408, 0x00000001, 2, ro_t> CHSIDE;
            /*
                Underrun flag
             */
            typedef reg_t<0x40003408, 0x00000001, 3, ro_t> UDR;
            /*
                CRC error flag
             */
            typedef reg_t<0x40003408, 0x00000001, 4, rw_t> CRCERR;
            /*
                Mode fault
             */
            typedef reg_t<0x40003408, 0x00000001, 5, ro_t> MODF;
            /*
                Overrun flag
             */
            typedef reg_t<0x40003408, 0x00000001, 6, ro_t> OVR;
            /*
                Busy flag
             */
            typedef reg_t<0x40003408, 0x00000001, 7, ro_t> BSY;
            /*
                TI frame format error
             */
            typedef reg_t<0x40003408, 0x00000001, 8, ro_t> TIFRFE;
            /*
                FIFO reception level
             */
            typedef reg_t<0x40003408, 0x00000003, 9, ro_t> FRLVL;
            /*
                FIFO transmission level
             */
            typedef reg_t<0x40003408, 0x00000003, 11, ro_t> FTLVL;
        };
        /*
            data register
         */
        namespace DR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000340c, 0xffffffff, 0, rw_t> DR_REG;
            /*
                Data register
             */
            typedef reg_t<0x4000340c, 0x0000ffff, 0, rw_t> DR;
        };
        /*
            CRC polynomial register
         */
        namespace CRCPR {

            static constexpr uint32_t RESETVALUE = 0x00000007;
            typedef reg_t<0x40003410, 0xffffffff, 0, rw_t> CRCPR_REG;
            /*
                CRC polynomial register
             */
            typedef reg_t<0x40003410, 0x0000ffff, 0, rw_t> CRCPOLY;
        };
        /*
            RX CRC register
         */
        namespace RXCRCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40003414, 0xffffffff, 0, ro_t> RXCRCR_REG;
            /*
                Rx CRC register
             */
            typedef reg_t<0x40003414, 0x0000ffff, 0, ro_t> RxCRC;
        };
        /*
            TX CRC register
         */
        namespace TXCRCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40003418, 0xffffffff, 0, ro_t> TXCRCR_REG;
            /*
                Tx CRC register
             */
            typedef reg_t<0x40003418, 0x0000ffff, 0, ro_t> TxCRC;
        };
        /*
            I2S configuration register
         */
        namespace I2SCFGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000341c, 0xffffffff, 0, rw_t> I2SCFGR_REG;
            /*
                I2S mode selection
             */
            typedef reg_t<0x4000341c, 0x00000001, 11, rw_t> I2SMOD;
            /*
                I2S Enable
             */
            typedef reg_t<0x4000341c, 0x00000001, 10, rw_t> I2SE;
            /*
                I2S configuration mode
             */
            typedef reg_t<0x4000341c, 0x00000003, 8, rw_t> I2SCFG;
            /*
                PCM frame synchronization
             */
            typedef reg_t<0x4000341c, 0x00000001, 7, rw_t> PCMSYNC;
            /*
                I2S standard selection
             */
            typedef reg_t<0x4000341c, 0x00000003, 4, rw_t> I2SSTD;
            /*
                Steady state clock
              polarity
             */
            typedef reg_t<0x4000341c, 0x00000001, 3, rw_t> CKPOL;
            /*
                Data length to be
              transferred
             */
            typedef reg_t<0x4000341c, 0x00000003, 1, rw_t> DATLEN;
            /*
                Channel length (number of bits per audio
              channel)
             */
            typedef reg_t<0x4000341c, 0x00000001, 0, rw_t> CHLEN;
        };
        /*
            I2S prescaler register
         */
        namespace I2SPR {

            static constexpr uint32_t RESETVALUE = 0x00000010;
            typedef reg_t<0x40003420, 0xffffffff, 0, rw_t> I2SPR_REG;
            /*
                Master clock output enable
             */
            typedef reg_t<0x40003420, 0x00000001, 9, rw_t> MCKOE;
            /*
                Odd factor for the
              prescaler
             */
            typedef reg_t<0x40003420, 0x00000001, 8, rw_t> ODD;
            /*
                I2S Linear prescaler
             */
            typedef reg_t<0x40003420, 0x000000ff, 0, rw_t> I2SDIV;
        };
    };
    /*
        Serial peripheral interface/Inter-IC
      sound
     */
    namespace I2S3ext {
        /*
            control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004000, 0xffffffff, 0, rw_t> CR1_REG;
            /*
                Bidirectional data mode
              enable
             */
            typedef reg_t<0x40004000, 0x00000001, 15, rw_t> BIDIMODE;
            /*
                Output enable in bidirectional
              mode
             */
            typedef reg_t<0x40004000, 0x00000001, 14, rw_t> BIDIOE;
            /*
                Hardware CRC calculation
              enable
             */
            typedef reg_t<0x40004000, 0x00000001, 13, rw_t> CRCEN;
            /*
                CRC transfer next
             */
            typedef reg_t<0x40004000, 0x00000001, 12, rw_t> CRCNEXT;
            /*
                CRC length
             */
            typedef reg_t<0x40004000, 0x00000001, 11, rw_t> CRCL;
            /*
                Receive only
             */
            typedef reg_t<0x40004000, 0x00000001, 10, rw_t> RXONLY;
            /*
                Software slave management
             */
            typedef reg_t<0x40004000, 0x00000001, 9, rw_t> SSM;
            /*
                Internal slave select
             */
            typedef reg_t<0x40004000, 0x00000001, 8, rw_t> SSI;
            /*
                Frame format
             */
            typedef reg_t<0x40004000, 0x00000001, 7, rw_t> LSBFIRST;
            /*
                SPI enable
             */
            typedef reg_t<0x40004000, 0x00000001, 6, rw_t> SPE;
            /*
                Baud rate control
             */
            typedef reg_t<0x40004000, 0x00000007, 3, rw_t> BR;
            /*
                Master selection
             */
            typedef reg_t<0x40004000, 0x00000001, 2, rw_t> MSTR;
            /*
                Clock polarity
             */
            typedef reg_t<0x40004000, 0x00000001, 1, rw_t> CPOL;
            /*
                Clock phase
             */
            typedef reg_t<0x40004000, 0x00000001, 0, rw_t> CPHA;
        };
        /*
            control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004004, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                Rx buffer DMA enable
             */
            typedef reg_t<0x40004004, 0x00000001, 0, rw_t> RXDMAEN;
            /*
                Tx buffer DMA enable
             */
            typedef reg_t<0x40004004, 0x00000001, 1, rw_t> TXDMAEN;
            /*
                SS output enable
             */
            typedef reg_t<0x40004004, 0x00000001, 2, rw_t> SSOE;
            /*
                NSS pulse management
             */
            typedef reg_t<0x40004004, 0x00000001, 3, rw_t> NSSP;
            /*
                Frame format
             */
            typedef reg_t<0x40004004, 0x00000001, 4, rw_t> FRF;
            /*
                Error interrupt enable
             */
            typedef reg_t<0x40004004, 0x00000001, 5, rw_t> ERRIE;
            /*
                RX buffer not empty interrupt
              enable
             */
            typedef reg_t<0x40004004, 0x00000001, 6, rw_t> RXNEIE;
            /*
                Tx buffer empty interrupt
              enable
             */
            typedef reg_t<0x40004004, 0x00000001, 7, rw_t> TXEIE;
            /*
                Data size
             */
            typedef reg_t<0x40004004, 0x0000000f, 8, rw_t> DS;
            /*
                FIFO reception threshold
             */
            typedef reg_t<0x40004004, 0x00000001, 12, rw_t> FRXTH;
            /*
                Last DMA transfer for
              reception
             */
            typedef reg_t<0x40004004, 0x00000001, 13, rw_t> LDMA_RX;
            /*
                Last DMA transfer for
              transmission
             */
            typedef reg_t<0x40004004, 0x00000001, 14, rw_t> LDMA_TX;
        };
        /*
            status register
         */
        namespace SR {

            static constexpr uint32_t RESETVALUE = 0x00000002;
            /*
                Receive buffer not empty
             */
            typedef reg_t<0x40004008, 0x00000001, 0, ro_t> RXNE;
            /*
                Transmit buffer empty
             */
            typedef reg_t<0x40004008, 0x00000001, 1, ro_t> TXE;
            /*
                Channel side
             */
            typedef reg_t<0x40004008, 0x00000001, 2, ro_t> CHSIDE;
            /*
                Underrun flag
             */
            typedef reg_t<0x40004008, 0x00000001, 3, ro_t> UDR;
            /*
                CRC error flag
             */
            typedef reg_t<0x40004008, 0x00000001, 4, rw_t> CRCERR;
            /*
                Mode fault
             */
            typedef reg_t<0x40004008, 0x00000001, 5, ro_t> MODF;
            /*
                Overrun flag
             */
            typedef reg_t<0x40004008, 0x00000001, 6, ro_t> OVR;
            /*
                Busy flag
             */
            typedef reg_t<0x40004008, 0x00000001, 7, ro_t> BSY;
            /*
                TI frame format error
             */
            typedef reg_t<0x40004008, 0x00000001, 8, ro_t> TIFRFE;
            /*
                FIFO reception level
             */
            typedef reg_t<0x40004008, 0x00000003, 9, ro_t> FRLVL;
            /*
                FIFO transmission level
             */
            typedef reg_t<0x40004008, 0x00000003, 11, ro_t> FTLVL;
        };
        /*
            data register
         */
        namespace DR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000400c, 0xffffffff, 0, rw_t> DR_REG;
            /*
                Data register
             */
            typedef reg_t<0x4000400c, 0x0000ffff, 0, rw_t> DR;
        };
        /*
            CRC polynomial register
         */
        namespace CRCPR {

            static constexpr uint32_t RESETVALUE = 0x00000007;
            typedef reg_t<0x40004010, 0xffffffff, 0, rw_t> CRCPR_REG;
            /*
                CRC polynomial register
             */
            typedef reg_t<0x40004010, 0x0000ffff, 0, rw_t> CRCPOLY;
        };
        /*
            RX CRC register
         */
        namespace RXCRCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004014, 0xffffffff, 0, ro_t> RXCRCR_REG;
            /*
                Rx CRC register
             */
            typedef reg_t<0x40004014, 0x0000ffff, 0, ro_t> RxCRC;
        };
        /*
            TX CRC register
         */
        namespace TXCRCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40004018, 0xffffffff, 0, ro_t> TXCRCR_REG;
            /*
                Tx CRC register
             */
            typedef reg_t<0x40004018, 0x0000ffff, 0, ro_t> TxCRC;
        };
        /*
            I2S configuration register
         */
        namespace I2SCFGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000401c, 0xffffffff, 0, rw_t> I2SCFGR_REG;
            /*
                I2S mode selection
             */
            typedef reg_t<0x4000401c, 0x00000001, 11, rw_t> I2SMOD;
            /*
                I2S Enable
             */
            typedef reg_t<0x4000401c, 0x00000001, 10, rw_t> I2SE;
            /*
                I2S configuration mode
             */
            typedef reg_t<0x4000401c, 0x00000003, 8, rw_t> I2SCFG;
            /*
                PCM frame synchronization
             */
            typedef reg_t<0x4000401c, 0x00000001, 7, rw_t> PCMSYNC;
            /*
                I2S standard selection
             */
            typedef reg_t<0x4000401c, 0x00000003, 4, rw_t> I2SSTD;
            /*
                Steady state clock
              polarity
             */
            typedef reg_t<0x4000401c, 0x00000001, 3, rw_t> CKPOL;
            /*
                Data length to be
              transferred
             */
            typedef reg_t<0x4000401c, 0x00000003, 1, rw_t> DATLEN;
            /*
                Channel length (number of bits per audio
              channel)
             */
            typedef reg_t<0x4000401c, 0x00000001, 0, rw_t> CHLEN;
        };
        /*
            I2S prescaler register
         */
        namespace I2SPR {

            static constexpr uint32_t RESETVALUE = 0x00000010;
            typedef reg_t<0x40004020, 0xffffffff, 0, rw_t> I2SPR_REG;
            /*
                Master clock output enable
             */
            typedef reg_t<0x40004020, 0x00000001, 9, rw_t> MCKOE;
            /*
                Odd factor for the
              prescaler
             */
            typedef reg_t<0x40004020, 0x00000001, 8, rw_t> ODD;
            /*
                I2S Linear prescaler
             */
            typedef reg_t<0x40004020, 0x000000ff, 0, rw_t> I2SDIV;
        };
    };
    /*
        Serial peripheral interface/Inter-IC
      sound
     */
    namespace SPI4 {
        /*
            control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013c00, 0xffffffff, 0, rw_t> CR1_REG;
            /*
                Bidirectional data mode
              enable
             */
            typedef reg_t<0x40013c00, 0x00000001, 15, rw_t> BIDIMODE;
            /*
                Output enable in bidirectional
              mode
             */
            typedef reg_t<0x40013c00, 0x00000001, 14, rw_t> BIDIOE;
            /*
                Hardware CRC calculation
              enable
             */
            typedef reg_t<0x40013c00, 0x00000001, 13, rw_t> CRCEN;
            /*
                CRC transfer next
             */
            typedef reg_t<0x40013c00, 0x00000001, 12, rw_t> CRCNEXT;
            /*
                CRC length
             */
            typedef reg_t<0x40013c00, 0x00000001, 11, rw_t> CRCL;
            /*
                Receive only
             */
            typedef reg_t<0x40013c00, 0x00000001, 10, rw_t> RXONLY;
            /*
                Software slave management
             */
            typedef reg_t<0x40013c00, 0x00000001, 9, rw_t> SSM;
            /*
                Internal slave select
             */
            typedef reg_t<0x40013c00, 0x00000001, 8, rw_t> SSI;
            /*
                Frame format
             */
            typedef reg_t<0x40013c00, 0x00000001, 7, rw_t> LSBFIRST;
            /*
                SPI enable
             */
            typedef reg_t<0x40013c00, 0x00000001, 6, rw_t> SPE;
            /*
                Baud rate control
             */
            typedef reg_t<0x40013c00, 0x00000007, 3, rw_t> BR;
            /*
                Master selection
             */
            typedef reg_t<0x40013c00, 0x00000001, 2, rw_t> MSTR;
            /*
                Clock polarity
             */
            typedef reg_t<0x40013c00, 0x00000001, 1, rw_t> CPOL;
            /*
                Clock phase
             */
            typedef reg_t<0x40013c00, 0x00000001, 0, rw_t> CPHA;
        };
        /*
            control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013c04, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                Rx buffer DMA enable
             */
            typedef reg_t<0x40013c04, 0x00000001, 0, rw_t> RXDMAEN;
            /*
                Tx buffer DMA enable
             */
            typedef reg_t<0x40013c04, 0x00000001, 1, rw_t> TXDMAEN;
            /*
                SS output enable
             */
            typedef reg_t<0x40013c04, 0x00000001, 2, rw_t> SSOE;
            /*
                NSS pulse management
             */
            typedef reg_t<0x40013c04, 0x00000001, 3, rw_t> NSSP;
            /*
                Frame format
             */
            typedef reg_t<0x40013c04, 0x00000001, 4, rw_t> FRF;
            /*
                Error interrupt enable
             */
            typedef reg_t<0x40013c04, 0x00000001, 5, rw_t> ERRIE;
            /*
                RX buffer not empty interrupt
              enable
             */
            typedef reg_t<0x40013c04, 0x00000001, 6, rw_t> RXNEIE;
            /*
                Tx buffer empty interrupt
              enable
             */
            typedef reg_t<0x40013c04, 0x00000001, 7, rw_t> TXEIE;
            /*
                Data size
             */
            typedef reg_t<0x40013c04, 0x0000000f, 8, rw_t> DS;
            /*
                FIFO reception threshold
             */
            typedef reg_t<0x40013c04, 0x00000001, 12, rw_t> FRXTH;
            /*
                Last DMA transfer for
              reception
             */
            typedef reg_t<0x40013c04, 0x00000001, 13, rw_t> LDMA_RX;
            /*
                Last DMA transfer for
              transmission
             */
            typedef reg_t<0x40013c04, 0x00000001, 14, rw_t> LDMA_TX;
        };
        /*
            status register
         */
        namespace SR {

            static constexpr uint32_t RESETVALUE = 0x00000002;
            /*
                Receive buffer not empty
             */
            typedef reg_t<0x40013c08, 0x00000001, 0, ro_t> RXNE;
            /*
                Transmit buffer empty
             */
            typedef reg_t<0x40013c08, 0x00000001, 1, ro_t> TXE;
            /*
                Channel side
             */
            typedef reg_t<0x40013c08, 0x00000001, 2, ro_t> CHSIDE;
            /*
                Underrun flag
             */
            typedef reg_t<0x40013c08, 0x00000001, 3, ro_t> UDR;
            /*
                CRC error flag
             */
            typedef reg_t<0x40013c08, 0x00000001, 4, rw_t> CRCERR;
            /*
                Mode fault
             */
            typedef reg_t<0x40013c08, 0x00000001, 5, ro_t> MODF;
            /*
                Overrun flag
             */
            typedef reg_t<0x40013c08, 0x00000001, 6, ro_t> OVR;
            /*
                Busy flag
             */
            typedef reg_t<0x40013c08, 0x00000001, 7, ro_t> BSY;
            /*
                TI frame format error
             */
            typedef reg_t<0x40013c08, 0x00000001, 8, ro_t> TIFRFE;
            /*
                FIFO reception level
             */
            typedef reg_t<0x40013c08, 0x00000003, 9, ro_t> FRLVL;
            /*
                FIFO transmission level
             */
            typedef reg_t<0x40013c08, 0x00000003, 11, ro_t> FTLVL;
        };
        /*
            data register
         */
        namespace DR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013c0c, 0xffffffff, 0, rw_t> DR_REG;
            /*
                Data register
             */
            typedef reg_t<0x40013c0c, 0x0000ffff, 0, rw_t> DR;
        };
        /*
            CRC polynomial register
         */
        namespace CRCPR {

            static constexpr uint32_t RESETVALUE = 0x00000007;
            typedef reg_t<0x40013c10, 0xffffffff, 0, rw_t> CRCPR_REG;
            /*
                CRC polynomial register
             */
            typedef reg_t<0x40013c10, 0x0000ffff, 0, rw_t> CRCPOLY;
        };
        /*
            RX CRC register
         */
        namespace RXCRCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013c14, 0xffffffff, 0, ro_t> RXCRCR_REG;
            /*
                Rx CRC register
             */
            typedef reg_t<0x40013c14, 0x0000ffff, 0, ro_t> RxCRC;
        };
        /*
            TX CRC register
         */
        namespace TXCRCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013c18, 0xffffffff, 0, ro_t> TXCRCR_REG;
            /*
                Tx CRC register
             */
            typedef reg_t<0x40013c18, 0x0000ffff, 0, ro_t> TxCRC;
        };
        /*
            I2S configuration register
         */
        namespace I2SCFGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013c1c, 0xffffffff, 0, rw_t> I2SCFGR_REG;
            /*
                I2S mode selection
             */
            typedef reg_t<0x40013c1c, 0x00000001, 11, rw_t> I2SMOD;
            /*
                I2S Enable
             */
            typedef reg_t<0x40013c1c, 0x00000001, 10, rw_t> I2SE;
            /*
                I2S configuration mode
             */
            typedef reg_t<0x40013c1c, 0x00000003, 8, rw_t> I2SCFG;
            /*
                PCM frame synchronization
             */
            typedef reg_t<0x40013c1c, 0x00000001, 7, rw_t> PCMSYNC;
            /*
                I2S standard selection
             */
            typedef reg_t<0x40013c1c, 0x00000003, 4, rw_t> I2SSTD;
            /*
                Steady state clock
              polarity
             */
            typedef reg_t<0x40013c1c, 0x00000001, 3, rw_t> CKPOL;
            /*
                Data length to be
              transferred
             */
            typedef reg_t<0x40013c1c, 0x00000003, 1, rw_t> DATLEN;
            /*
                Channel length (number of bits per audio
              channel)
             */
            typedef reg_t<0x40013c1c, 0x00000001, 0, rw_t> CHLEN;
        };
        /*
            I2S prescaler register
         */
        namespace I2SPR {

            static constexpr uint32_t RESETVALUE = 0x00000010;
            typedef reg_t<0x40013c20, 0xffffffff, 0, rw_t> I2SPR_REG;
            /*
                Master clock output enable
             */
            typedef reg_t<0x40013c20, 0x00000001, 9, rw_t> MCKOE;
            /*
                Odd factor for the
              prescaler
             */
            typedef reg_t<0x40013c20, 0x00000001, 8, rw_t> ODD;
            /*
                I2S Linear prescaler
             */
            typedef reg_t<0x40013c20, 0x000000ff, 0, rw_t> I2SDIV;
        };
    };
    /*
        External interrupt/event
      controller
     */
    namespace EXTI {
        /*
            Interrupt mask register
         */
        namespace IMR1 {

            static constexpr uint32_t RESETVALUE = 0x1f800000;
            typedef reg_t<0x40010400, 0xffffffff, 0, rw_t> IMR1_REG;
            /*
                Interrupt Mask on line 0
             */
            typedef reg_t<0x40010400, 0x00000001, 0, rw_t> MR0;
            /*
                Interrupt Mask on line 1
             */
            typedef reg_t<0x40010400, 0x00000001, 1, rw_t> MR1;
            /*
                Interrupt Mask on line 2
             */
            typedef reg_t<0x40010400, 0x00000001, 2, rw_t> MR2;
            /*
                Interrupt Mask on line 3
             */
            typedef reg_t<0x40010400, 0x00000001, 3, rw_t> MR3;
            /*
                Interrupt Mask on line 4
             */
            typedef reg_t<0x40010400, 0x00000001, 4, rw_t> MR4;
            /*
                Interrupt Mask on line 5
             */
            typedef reg_t<0x40010400, 0x00000001, 5, rw_t> MR5;
            /*
                Interrupt Mask on line 6
             */
            typedef reg_t<0x40010400, 0x00000001, 6, rw_t> MR6;
            /*
                Interrupt Mask on line 7
             */
            typedef reg_t<0x40010400, 0x00000001, 7, rw_t> MR7;
            /*
                Interrupt Mask on line 8
             */
            typedef reg_t<0x40010400, 0x00000001, 8, rw_t> MR8;
            /*
                Interrupt Mask on line 9
             */
            typedef reg_t<0x40010400, 0x00000001, 9, rw_t> MR9;
            /*
                Interrupt Mask on line 10
             */
            typedef reg_t<0x40010400, 0x00000001, 10, rw_t> MR10;
            /*
                Interrupt Mask on line 11
             */
            typedef reg_t<0x40010400, 0x00000001, 11, rw_t> MR11;
            /*
                Interrupt Mask on line 12
             */
            typedef reg_t<0x40010400, 0x00000001, 12, rw_t> MR12;
            /*
                Interrupt Mask on line 13
             */
            typedef reg_t<0x40010400, 0x00000001, 13, rw_t> MR13;
            /*
                Interrupt Mask on line 14
             */
            typedef reg_t<0x40010400, 0x00000001, 14, rw_t> MR14;
            /*
                Interrupt Mask on line 15
             */
            typedef reg_t<0x40010400, 0x00000001, 15, rw_t> MR15;
            /*
                Interrupt Mask on line 16
             */
            typedef reg_t<0x40010400, 0x00000001, 16, rw_t> MR16;
            /*
                Interrupt Mask on line 17
             */
            typedef reg_t<0x40010400, 0x00000001, 17, rw_t> MR17;
            /*
                Interrupt Mask on line 18
             */
            typedef reg_t<0x40010400, 0x00000001, 18, rw_t> MR18;
            /*
                Interrupt Mask on line 19
             */
            typedef reg_t<0x40010400, 0x00000001, 19, rw_t> MR19;
            /*
                Interrupt Mask on line 20
             */
            typedef reg_t<0x40010400, 0x00000001, 20, rw_t> MR20;
            /*
                Interrupt Mask on line 21
             */
            typedef reg_t<0x40010400, 0x00000001, 21, rw_t> MR21;
            /*
                Interrupt Mask on line 22
             */
            typedef reg_t<0x40010400, 0x00000001, 22, rw_t> MR22;
            /*
                Interrupt Mask on line 23
             */
            typedef reg_t<0x40010400, 0x00000001, 23, rw_t> MR23;
            /*
                Interrupt Mask on line 24
             */
            typedef reg_t<0x40010400, 0x00000001, 24, rw_t> MR24;
            /*
                Interrupt Mask on line 25
             */
            typedef reg_t<0x40010400, 0x00000001, 25, rw_t> MR25;
            /*
                Interrupt Mask on line 26
             */
            typedef reg_t<0x40010400, 0x00000001, 26, rw_t> MR26;
            /*
                Interrupt Mask on line 27
             */
            typedef reg_t<0x40010400, 0x00000001, 27, rw_t> MR27;
            /*
                Interrupt Mask on line 28
             */
            typedef reg_t<0x40010400, 0x00000001, 28, rw_t> MR28;
            /*
                Interrupt Mask on line 29
             */
            typedef reg_t<0x40010400, 0x00000001, 29, rw_t> MR29;
            /*
                Interrupt Mask on line 30
             */
            typedef reg_t<0x40010400, 0x00000001, 30, rw_t> MR30;
            /*
                Interrupt Mask on line 31
             */
            typedef reg_t<0x40010400, 0x00000001, 31, rw_t> MR31;
        };
        /*
            Event mask register
         */
        namespace EMR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40010404, 0xffffffff, 0, rw_t> EMR1_REG;
            /*
                Event Mask on line 0
             */
            typedef reg_t<0x40010404, 0x00000001, 0, rw_t> MR0;
            /*
                Event Mask on line 1
             */
            typedef reg_t<0x40010404, 0x00000001, 1, rw_t> MR1;
            /*
                Event Mask on line 2
             */
            typedef reg_t<0x40010404, 0x00000001, 2, rw_t> MR2;
            /*
                Event Mask on line 3
             */
            typedef reg_t<0x40010404, 0x00000001, 3, rw_t> MR3;
            /*
                Event Mask on line 4
             */
            typedef reg_t<0x40010404, 0x00000001, 4, rw_t> MR4;
            /*
                Event Mask on line 5
             */
            typedef reg_t<0x40010404, 0x00000001, 5, rw_t> MR5;
            /*
                Event Mask on line 6
             */
            typedef reg_t<0x40010404, 0x00000001, 6, rw_t> MR6;
            /*
                Event Mask on line 7
             */
            typedef reg_t<0x40010404, 0x00000001, 7, rw_t> MR7;
            /*
                Event Mask on line 8
             */
            typedef reg_t<0x40010404, 0x00000001, 8, rw_t> MR8;
            /*
                Event Mask on line 9
             */
            typedef reg_t<0x40010404, 0x00000001, 9, rw_t> MR9;
            /*
                Event Mask on line 10
             */
            typedef reg_t<0x40010404, 0x00000001, 10, rw_t> MR10;
            /*
                Event Mask on line 11
             */
            typedef reg_t<0x40010404, 0x00000001, 11, rw_t> MR11;
            /*
                Event Mask on line 12
             */
            typedef reg_t<0x40010404, 0x00000001, 12, rw_t> MR12;
            /*
                Event Mask on line 13
             */
            typedef reg_t<0x40010404, 0x00000001, 13, rw_t> MR13;
            /*
                Event Mask on line 14
             */
            typedef reg_t<0x40010404, 0x00000001, 14, rw_t> MR14;
            /*
                Event Mask on line 15
             */
            typedef reg_t<0x40010404, 0x00000001, 15, rw_t> MR15;
            /*
                Event Mask on line 16
             */
            typedef reg_t<0x40010404, 0x00000001, 16, rw_t> MR16;
            /*
                Event Mask on line 17
             */
            typedef reg_t<0x40010404, 0x00000001, 17, rw_t> MR17;
            /*
                Event Mask on line 18
             */
            typedef reg_t<0x40010404, 0x00000001, 18, rw_t> MR18;
            /*
                Event Mask on line 19
             */
            typedef reg_t<0x40010404, 0x00000001, 19, rw_t> MR19;
            /*
                Event Mask on line 20
             */
            typedef reg_t<0x40010404, 0x00000001, 20, rw_t> MR20;
            /*
                Event Mask on line 21
             */
            typedef reg_t<0x40010404, 0x00000001, 21, rw_t> MR21;
            /*
                Event Mask on line 22
             */
            typedef reg_t<0x40010404, 0x00000001, 22, rw_t> MR22;
            /*
                Event Mask on line 23
             */
            typedef reg_t<0x40010404, 0x00000001, 23, rw_t> MR23;
            /*
                Event Mask on line 24
             */
            typedef reg_t<0x40010404, 0x00000001, 24, rw_t> MR24;
            /*
                Event Mask on line 25
             */
            typedef reg_t<0x40010404, 0x00000001, 25, rw_t> MR25;
            /*
                Event Mask on line 26
             */
            typedef reg_t<0x40010404, 0x00000001, 26, rw_t> MR26;
            /*
                Event Mask on line 27
             */
            typedef reg_t<0x40010404, 0x00000001, 27, rw_t> MR27;
            /*
                Event Mask on line 28
             */
            typedef reg_t<0x40010404, 0x00000001, 28, rw_t> MR28;
            /*
                Event Mask on line 29
             */
            typedef reg_t<0x40010404, 0x00000001, 29, rw_t> MR29;
            /*
                Event Mask on line 30
             */
            typedef reg_t<0x40010404, 0x00000001, 30, rw_t> MR30;
            /*
                Event Mask on line 31
             */
            typedef reg_t<0x40010404, 0x00000001, 31, rw_t> MR31;
        };
        /*
            Rising Trigger selection
          register
         */
        namespace RTSR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40010408, 0xffffffff, 0, rw_t> RTSR1_REG;
            /*
                Rising trigger event configuration of
              line 0
             */
            typedef reg_t<0x40010408, 0x00000001, 0, rw_t> TR0;
            /*
                Rising trigger event configuration of
              line 1
             */
            typedef reg_t<0x40010408, 0x00000001, 1, rw_t> TR1;
            /*
                Rising trigger event configuration of
              line 2
             */
            typedef reg_t<0x40010408, 0x00000001, 2, rw_t> TR2;
            /*
                Rising trigger event configuration of
              line 3
             */
            typedef reg_t<0x40010408, 0x00000001, 3, rw_t> TR3;
            /*
                Rising trigger event configuration of
              line 4
             */
            typedef reg_t<0x40010408, 0x00000001, 4, rw_t> TR4;
            /*
                Rising trigger event configuration of
              line 5
             */
            typedef reg_t<0x40010408, 0x00000001, 5, rw_t> TR5;
            /*
                Rising trigger event configuration of
              line 6
             */
            typedef reg_t<0x40010408, 0x00000001, 6, rw_t> TR6;
            /*
                Rising trigger event configuration of
              line 7
             */
            typedef reg_t<0x40010408, 0x00000001, 7, rw_t> TR7;
            /*
                Rising trigger event configuration of
              line 8
             */
            typedef reg_t<0x40010408, 0x00000001, 8, rw_t> TR8;
            /*
                Rising trigger event configuration of
              line 9
             */
            typedef reg_t<0x40010408, 0x00000001, 9, rw_t> TR9;
            /*
                Rising trigger event configuration of
              line 10
             */
            typedef reg_t<0x40010408, 0x00000001, 10, rw_t> TR10;
            /*
                Rising trigger event configuration of
              line 11
             */
            typedef reg_t<0x40010408, 0x00000001, 11, rw_t> TR11;
            /*
                Rising trigger event configuration of
              line 12
             */
            typedef reg_t<0x40010408, 0x00000001, 12, rw_t> TR12;
            /*
                Rising trigger event configuration of
              line 13
             */
            typedef reg_t<0x40010408, 0x00000001, 13, rw_t> TR13;
            /*
                Rising trigger event configuration of
              line 14
             */
            typedef reg_t<0x40010408, 0x00000001, 14, rw_t> TR14;
            /*
                Rising trigger event configuration of
              line 15
             */
            typedef reg_t<0x40010408, 0x00000001, 15, rw_t> TR15;
            /*
                Rising trigger event configuration of
              line 16
             */
            typedef reg_t<0x40010408, 0x00000001, 16, rw_t> TR16;
            /*
                Rising trigger event configuration of
              line 17
             */
            typedef reg_t<0x40010408, 0x00000001, 17, rw_t> TR17;
            /*
                Rising trigger event configuration of
              line 18
             */
            typedef reg_t<0x40010408, 0x00000001, 18, rw_t> TR18;
            /*
                Rising trigger event configuration of
              line 19
             */
            typedef reg_t<0x40010408, 0x00000001, 19, rw_t> TR19;
            /*
                Rising trigger event configuration of
              line 20
             */
            typedef reg_t<0x40010408, 0x00000001, 20, rw_t> TR20;
            /*
                Rising trigger event configuration of
              line 21
             */
            typedef reg_t<0x40010408, 0x00000001, 21, rw_t> TR21;
            /*
                Rising trigger event configuration of
              line 22
             */
            typedef reg_t<0x40010408, 0x00000001, 22, rw_t> TR22;
            /*
                Rising trigger event configuration of
              line 29
             */
            typedef reg_t<0x40010408, 0x00000001, 29, rw_t> TR29;
            /*
                Rising trigger event configuration of
              line 30
             */
            typedef reg_t<0x40010408, 0x00000001, 30, rw_t> TR30;
            /*
                Rising trigger event configuration of
              line 31
             */
            typedef reg_t<0x40010408, 0x00000001, 31, rw_t> TR31;
        };
        /*
            Falling Trigger selection
          register
         */
        namespace FTSR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001040c, 0xffffffff, 0, rw_t> FTSR1_REG;
            /*
                Falling trigger event configuration of
              line 0
             */
            typedef reg_t<0x4001040c, 0x00000001, 0, rw_t> TR0;
            /*
                Falling trigger event configuration of
              line 1
             */
            typedef reg_t<0x4001040c, 0x00000001, 1, rw_t> TR1;
            /*
                Falling trigger event configuration of
              line 2
             */
            typedef reg_t<0x4001040c, 0x00000001, 2, rw_t> TR2;
            /*
                Falling trigger event configuration of
              line 3
             */
            typedef reg_t<0x4001040c, 0x00000001, 3, rw_t> TR3;
            /*
                Falling trigger event configuration of
              line 4
             */
            typedef reg_t<0x4001040c, 0x00000001, 4, rw_t> TR4;
            /*
                Falling trigger event configuration of
              line 5
             */
            typedef reg_t<0x4001040c, 0x00000001, 5, rw_t> TR5;
            /*
                Falling trigger event configuration of
              line 6
             */
            typedef reg_t<0x4001040c, 0x00000001, 6, rw_t> TR6;
            /*
                Falling trigger event configuration of
              line 7
             */
            typedef reg_t<0x4001040c, 0x00000001, 7, rw_t> TR7;
            /*
                Falling trigger event configuration of
              line 8
             */
            typedef reg_t<0x4001040c, 0x00000001, 8, rw_t> TR8;
            /*
                Falling trigger event configuration of
              line 9
             */
            typedef reg_t<0x4001040c, 0x00000001, 9, rw_t> TR9;
            /*
                Falling trigger event configuration of
              line 10
             */
            typedef reg_t<0x4001040c, 0x00000001, 10, rw_t> TR10;
            /*
                Falling trigger event configuration of
              line 11
             */
            typedef reg_t<0x4001040c, 0x00000001, 11, rw_t> TR11;
            /*
                Falling trigger event configuration of
              line 12
             */
            typedef reg_t<0x4001040c, 0x00000001, 12, rw_t> TR12;
            /*
                Falling trigger event configuration of
              line 13
             */
            typedef reg_t<0x4001040c, 0x00000001, 13, rw_t> TR13;
            /*
                Falling trigger event configuration of
              line 14
             */
            typedef reg_t<0x4001040c, 0x00000001, 14, rw_t> TR14;
            /*
                Falling trigger event configuration of
              line 15
             */
            typedef reg_t<0x4001040c, 0x00000001, 15, rw_t> TR15;
            /*
                Falling trigger event configuration of
              line 16
             */
            typedef reg_t<0x4001040c, 0x00000001, 16, rw_t> TR16;
            /*
                Falling trigger event configuration of
              line 17
             */
            typedef reg_t<0x4001040c, 0x00000001, 17, rw_t> TR17;
            /*
                Falling trigger event configuration of
              line 18
             */
            typedef reg_t<0x4001040c, 0x00000001, 18, rw_t> TR18;
            /*
                Falling trigger event configuration of
              line 19
             */
            typedef reg_t<0x4001040c, 0x00000001, 19, rw_t> TR19;
            /*
                Falling trigger event configuration of
              line 20
             */
            typedef reg_t<0x4001040c, 0x00000001, 20, rw_t> TR20;
            /*
                Falling trigger event configuration of
              line 21
             */
            typedef reg_t<0x4001040c, 0x00000001, 21, rw_t> TR21;
            /*
                Falling trigger event configuration of
              line 22
             */
            typedef reg_t<0x4001040c, 0x00000001, 22, rw_t> TR22;
            /*
                Falling trigger event configuration of
              line 29
             */
            typedef reg_t<0x4001040c, 0x00000001, 29, rw_t> TR29;
            /*
                Falling trigger event configuration of
              line 30.
             */
            typedef reg_t<0x4001040c, 0x00000001, 30, rw_t> TR30;
            /*
                Falling trigger event configuration of
              line 31
             */
            typedef reg_t<0x4001040c, 0x00000001, 31, rw_t> TR31;
        };
        /*
            Software interrupt event
          register
         */
        namespace SWIER1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40010410, 0xffffffff, 0, rw_t> SWIER1_REG;
            /*
                Software Interrupt on line
              0
             */
            typedef reg_t<0x40010410, 0x00000001, 0, rw_t> SWIER0;
            /*
                Software Interrupt on line
              1
             */
            typedef reg_t<0x40010410, 0x00000001, 1, rw_t> SWIER1;
            /*
                Software Interrupt on line
              2
             */
            typedef reg_t<0x40010410, 0x00000001, 2, rw_t> SWIER2;
            /*
                Software Interrupt on line
              3
             */
            typedef reg_t<0x40010410, 0x00000001, 3, rw_t> SWIER3;
            /*
                Software Interrupt on line
              4
             */
            typedef reg_t<0x40010410, 0x00000001, 4, rw_t> SWIER4;
            /*
                Software Interrupt on line
              5
             */
            typedef reg_t<0x40010410, 0x00000001, 5, rw_t> SWIER5;
            /*
                Software Interrupt on line
              6
             */
            typedef reg_t<0x40010410, 0x00000001, 6, rw_t> SWIER6;
            /*
                Software Interrupt on line
              7
             */
            typedef reg_t<0x40010410, 0x00000001, 7, rw_t> SWIER7;
            /*
                Software Interrupt on line
              8
             */
            typedef reg_t<0x40010410, 0x00000001, 8, rw_t> SWIER8;
            /*
                Software Interrupt on line
              9
             */
            typedef reg_t<0x40010410, 0x00000001, 9, rw_t> SWIER9;
            /*
                Software Interrupt on line
              10
             */
            typedef reg_t<0x40010410, 0x00000001, 10, rw_t> SWIER10;
            /*
                Software Interrupt on line
              11
             */
            typedef reg_t<0x40010410, 0x00000001, 11, rw_t> SWIER11;
            /*
                Software Interrupt on line
              12
             */
            typedef reg_t<0x40010410, 0x00000001, 12, rw_t> SWIER12;
            /*
                Software Interrupt on line
              13
             */
            typedef reg_t<0x40010410, 0x00000001, 13, rw_t> SWIER13;
            /*
                Software Interrupt on line
              14
             */
            typedef reg_t<0x40010410, 0x00000001, 14, rw_t> SWIER14;
            /*
                Software Interrupt on line
              15
             */
            typedef reg_t<0x40010410, 0x00000001, 15, rw_t> SWIER15;
            /*
                Software Interrupt on line
              16
             */
            typedef reg_t<0x40010410, 0x00000001, 16, rw_t> SWIER16;
            /*
                Software Interrupt on line
              17
             */
            typedef reg_t<0x40010410, 0x00000001, 17, rw_t> SWIER17;
            /*
                Software Interrupt on line
              18
             */
            typedef reg_t<0x40010410, 0x00000001, 18, rw_t> SWIER18;
            /*
                Software Interrupt on line
              19
             */
            typedef reg_t<0x40010410, 0x00000001, 19, rw_t> SWIER19;
            /*
                Software Interrupt on line
              20
             */
            typedef reg_t<0x40010410, 0x00000001, 20, rw_t> SWIER20;
            /*
                Software Interrupt on line
              21
             */
            typedef reg_t<0x40010410, 0x00000001, 21, rw_t> SWIER21;
            /*
                Software Interrupt on line
              22
             */
            typedef reg_t<0x40010410, 0x00000001, 22, rw_t> SWIER22;
            /*
                Software Interrupt on line
              29
             */
            typedef reg_t<0x40010410, 0x00000001, 29, rw_t> SWIER29;
            /*
                Software Interrupt on line
              309
             */
            typedef reg_t<0x40010410, 0x00000001, 30, rw_t> SWIER30;
            /*
                Software Interrupt on line
              319
             */
            typedef reg_t<0x40010410, 0x00000001, 31, rw_t> SWIER31;
        };
        /*
            Pending register
         */
        namespace PR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40010414, 0xffffffff, 0, rw_t> PR1_REG;
            /*
                Pending bit 0
             */
            typedef reg_t<0x40010414, 0x00000001, 0, rw_t> PR0;
            /*
                Pending bit 1
             */
            typedef reg_t<0x40010414, 0x00000001, 1, rw_t> PR1;
            /*
                Pending bit 2
             */
            typedef reg_t<0x40010414, 0x00000001, 2, rw_t> PR2;
            /*
                Pending bit 3
             */
            typedef reg_t<0x40010414, 0x00000001, 3, rw_t> PR3;
            /*
                Pending bit 4
             */
            typedef reg_t<0x40010414, 0x00000001, 4, rw_t> PR4;
            /*
                Pending bit 5
             */
            typedef reg_t<0x40010414, 0x00000001, 5, rw_t> PR5;
            /*
                Pending bit 6
             */
            typedef reg_t<0x40010414, 0x00000001, 6, rw_t> PR6;
            /*
                Pending bit 7
             */
            typedef reg_t<0x40010414, 0x00000001, 7, rw_t> PR7;
            /*
                Pending bit 8
             */
            typedef reg_t<0x40010414, 0x00000001, 8, rw_t> PR8;
            /*
                Pending bit 9
             */
            typedef reg_t<0x40010414, 0x00000001, 9, rw_t> PR9;
            /*
                Pending bit 10
             */
            typedef reg_t<0x40010414, 0x00000001, 10, rw_t> PR10;
            /*
                Pending bit 11
             */
            typedef reg_t<0x40010414, 0x00000001, 11, rw_t> PR11;
            /*
                Pending bit 12
             */
            typedef reg_t<0x40010414, 0x00000001, 12, rw_t> PR12;
            /*
                Pending bit 13
             */
            typedef reg_t<0x40010414, 0x00000001, 13, rw_t> PR13;
            /*
                Pending bit 14
             */
            typedef reg_t<0x40010414, 0x00000001, 14, rw_t> PR14;
            /*
                Pending bit 15
             */
            typedef reg_t<0x40010414, 0x00000001, 15, rw_t> PR15;
            /*
                Pending bit 16
             */
            typedef reg_t<0x40010414, 0x00000001, 16, rw_t> PR16;
            /*
                Pending bit 17
             */
            typedef reg_t<0x40010414, 0x00000001, 17, rw_t> PR17;
            /*
                Pending bit 18
             */
            typedef reg_t<0x40010414, 0x00000001, 18, rw_t> PR18;
            /*
                Pending bit 19
             */
            typedef reg_t<0x40010414, 0x00000001, 19, rw_t> PR19;
            /*
                Pending bit 20
             */
            typedef reg_t<0x40010414, 0x00000001, 20, rw_t> PR20;
            /*
                Pending bit 21
             */
            typedef reg_t<0x40010414, 0x00000001, 21, rw_t> PR21;
            /*
                Pending bit 22
             */
            typedef reg_t<0x40010414, 0x00000001, 22, rw_t> PR22;
            /*
                Pending bit 29
             */
            typedef reg_t<0x40010414, 0x00000001, 29, rw_t> PR29;
            /*
                Pending bit 30
             */
            typedef reg_t<0x40010414, 0x00000001, 30, rw_t> PR30;
            /*
                Pending bit 31
             */
            typedef reg_t<0x40010414, 0x00000001, 31, rw_t> PR31;
        };
        /*
            Interrupt mask register
         */
        namespace IMR2 {

            static constexpr uint32_t RESETVALUE = 0xfffffffc;
            typedef reg_t<0x40010418, 0xffffffff, 0, rw_t> IMR2_REG;
            /*
                Interrupt Mask on external/internal line
              32
             */
            typedef reg_t<0x40010418, 0x00000001, 0, rw_t> MR32;
            /*
                Interrupt Mask on external/internal line
              33
             */
            typedef reg_t<0x40010418, 0x00000001, 1, rw_t> MR33;
            /*
                Interrupt Mask on external/internal line
              34
             */
            typedef reg_t<0x40010418, 0x00000001, 2, rw_t> MR34;
            /*
                Interrupt Mask on external/internal line
              35
             */
            typedef reg_t<0x40010418, 0x00000001, 3, rw_t> MR35;
        };
        /*
            Event mask register
         */
        namespace EMR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001041c, 0xffffffff, 0, rw_t> EMR2_REG;
            /*
                Event mask on external/internal line
              32
             */
            typedef reg_t<0x4001041c, 0x00000001, 0, rw_t> MR32;
            /*
                Event mask on external/internal line
              33
             */
            typedef reg_t<0x4001041c, 0x00000001, 1, rw_t> MR33;
            /*
                Event mask on external/internal line
              34
             */
            typedef reg_t<0x4001041c, 0x00000001, 2, rw_t> MR34;
            /*
                Event mask on external/internal line
              35
             */
            typedef reg_t<0x4001041c, 0x00000001, 3, rw_t> MR35;
        };
        /*
            Rising Trigger selection
          register
         */
        namespace RTSR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40010420, 0xffffffff, 0, rw_t> RTSR2_REG;
            /*
                Rising trigger event configuration bit
              of line 32
             */
            typedef reg_t<0x40010420, 0x00000001, 0, rw_t> TR32;
            /*
                Rising trigger event configuration bit
              of line 33
             */
            typedef reg_t<0x40010420, 0x00000001, 1, rw_t> TR33;
        };
        /*
            Falling Trigger selection
          register
         */
        namespace FTSR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40010424, 0xffffffff, 0, rw_t> FTSR2_REG;
            /*
                Falling trigger event configuration bit
              of line 32
             */
            typedef reg_t<0x40010424, 0x00000001, 0, rw_t> TR32;
            /*
                Falling trigger event configuration bit
              of line 33
             */
            typedef reg_t<0x40010424, 0x00000001, 1, rw_t> TR33;
        };
        /*
            Software interrupt event
          register
         */
        namespace SWIER2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40010428, 0xffffffff, 0, rw_t> SWIER2_REG;
            /*
                Software interrupt on line
              32
             */
            typedef reg_t<0x40010428, 0x00000001, 0, rw_t> SWIER32;
            /*
                Software interrupt on line
              33
             */
            typedef reg_t<0x40010428, 0x00000001, 1, rw_t> SWIER33;
        };
        /*
            Pending register
         */
        namespace PR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001042c, 0xffffffff, 0, rw_t> PR2_REG;
            /*
                Pending bit on line 32
             */
            typedef reg_t<0x4001042c, 0x00000001, 0, rw_t> PR32;
            /*
                Pending bit on line 33
             */
            typedef reg_t<0x4001042c, 0x00000001, 1, rw_t> PR33;
        };
    };
    /*
        Power control
     */
    namespace PWR {
        /*
            power control register
         */
        namespace CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40007000, 0xffffffff, 0, rw_t> CR_REG;
            /*
                Low-power deep sleep
             */
            typedef reg_t<0x40007000, 0x00000001, 0, rw_t> LPDS;
            /*
                Power down deepsleep
             */
            typedef reg_t<0x40007000, 0x00000001, 1, rw_t> PDDS;
            /*
                Clear wakeup flag
             */
            typedef reg_t<0x40007000, 0x00000001, 2, rw_t> CWUF;
            /*
                Clear standby flag
             */
            typedef reg_t<0x40007000, 0x00000001, 3, rw_t> CSBF;
            /*
                Power voltage detector
              enable
             */
            typedef reg_t<0x40007000, 0x00000001, 4, rw_t> PVDE;
            /*
                PVD level selection
             */
            typedef reg_t<0x40007000, 0x00000007, 5, rw_t> PLS;
            /*
                Disable backup domain write
              protection
             */
            typedef reg_t<0x40007000, 0x00000001, 8, rw_t> DBP;
        };
        /*
            power control/status register
         */
        namespace CSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Wakeup flag
             */
            typedef reg_t<0x40007004, 0x00000001, 0, ro_t> WUF;
            /*
                Standby flag
             */
            typedef reg_t<0x40007004, 0x00000001, 1, ro_t> SBF;
            /*
                PVD output
             */
            typedef reg_t<0x40007004, 0x00000001, 2, ro_t> PVDO;
            /*
                Enable WKUP1 pin
             */
            typedef reg_t<0x40007004, 0x00000001, 8, rw_t> EWUP1;
            /*
                Enable WKUP2 pin
             */
            typedef reg_t<0x40007004, 0x00000001, 9, rw_t> EWUP2;
        };
    };
    /*
        Controller area network
     */
    namespace CAN {
        /*
            master control register
         */
        namespace MCR {

            static constexpr uint32_t RESETVALUE = 0x00010002;
            typedef reg_t<0x40006400, 0xffffffff, 0, rw_t> MCR_REG;
            /*
                DBF
             */
            typedef reg_t<0x40006400, 0x00000001, 16, rw_t> DBF;
            /*
                RESET
             */
            typedef reg_t<0x40006400, 0x00000001, 15, rw_t> RESET;
            /*
                TTCM
             */
            typedef reg_t<0x40006400, 0x00000001, 7, rw_t> TTCM;
            /*
                ABOM
             */
            typedef reg_t<0x40006400, 0x00000001, 6, rw_t> ABOM;
            /*
                AWUM
             */
            typedef reg_t<0x40006400, 0x00000001, 5, rw_t> AWUM;
            /*
                NART
             */
            typedef reg_t<0x40006400, 0x00000001, 4, rw_t> NART;
            /*
                RFLM
             */
            typedef reg_t<0x40006400, 0x00000001, 3, rw_t> RFLM;
            /*
                TXFP
             */
            typedef reg_t<0x40006400, 0x00000001, 2, rw_t> TXFP;
            /*
                SLEEP
             */
            typedef reg_t<0x40006400, 0x00000001, 1, rw_t> SLEEP;
            /*
                INRQ
             */
            typedef reg_t<0x40006400, 0x00000001, 0, rw_t> INRQ;
        };
        /*
            master status register
         */
        namespace MSR {

            static constexpr uint32_t RESETVALUE = 0x00000c02;
            /*
                RX
             */
            typedef reg_t<0x40006404, 0x00000001, 11, ro_t> RX;
            /*
                SAMP
             */
            typedef reg_t<0x40006404, 0x00000001, 10, ro_t> SAMP;
            /*
                RXM
             */
            typedef reg_t<0x40006404, 0x00000001, 9, ro_t> RXM;
            /*
                TXM
             */
            typedef reg_t<0x40006404, 0x00000001, 8, ro_t> TXM;
            /*
                SLAKI
             */
            typedef reg_t<0x40006404, 0x00000001, 4, rw_t> SLAKI;
            /*
                WKUI
             */
            typedef reg_t<0x40006404, 0x00000001, 3, rw_t> WKUI;
            /*
                ERRI
             */
            typedef reg_t<0x40006404, 0x00000001, 2, rw_t> ERRI;
            /*
                SLAK
             */
            typedef reg_t<0x40006404, 0x00000001, 1, ro_t> SLAK;
            /*
                INAK
             */
            typedef reg_t<0x40006404, 0x00000001, 0, ro_t> INAK;
        };
        /*
            transmit status register
         */
        namespace TSR {

            static constexpr uint32_t RESETVALUE = 0x1c000000;
            /*
                Lowest priority flag for mailbox
              2
             */
            typedef reg_t<0x40006408, 0x00000001, 31, ro_t> LOW2;
            /*
                Lowest priority flag for mailbox
              1
             */
            typedef reg_t<0x40006408, 0x00000001, 30, ro_t> LOW1;
            /*
                Lowest priority flag for mailbox
              0
             */
            typedef reg_t<0x40006408, 0x00000001, 29, ro_t> LOW0;
            /*
                Lowest priority flag for mailbox
              2
             */
            typedef reg_t<0x40006408, 0x00000001, 28, ro_t> TME2;
            /*
                Lowest priority flag for mailbox
              1
             */
            typedef reg_t<0x40006408, 0x00000001, 27, ro_t> TME1;
            /*
                Lowest priority flag for mailbox
              0
             */
            typedef reg_t<0x40006408, 0x00000001, 26, ro_t> TME0;
            /*
                CODE
             */
            typedef reg_t<0x40006408, 0x00000003, 24, ro_t> CODE;
            /*
                ABRQ2
             */
            typedef reg_t<0x40006408, 0x00000001, 23, rw_t> ABRQ2;
            /*
                TERR2
             */
            typedef reg_t<0x40006408, 0x00000001, 19, rw_t> TERR2;
            /*
                ALST2
             */
            typedef reg_t<0x40006408, 0x00000001, 18, rw_t> ALST2;
            /*
                TXOK2
             */
            typedef reg_t<0x40006408, 0x00000001, 17, rw_t> TXOK2;
            /*
                RQCP2
             */
            typedef reg_t<0x40006408, 0x00000001, 16, rw_t> RQCP2;
            /*
                ABRQ1
             */
            typedef reg_t<0x40006408, 0x00000001, 15, rw_t> ABRQ1;
            /*
                TERR1
             */
            typedef reg_t<0x40006408, 0x00000001, 11, rw_t> TERR1;
            /*
                ALST1
             */
            typedef reg_t<0x40006408, 0x00000001, 10, rw_t> ALST1;
            /*
                TXOK1
             */
            typedef reg_t<0x40006408, 0x00000001, 9, rw_t> TXOK1;
            /*
                RQCP1
             */
            typedef reg_t<0x40006408, 0x00000001, 8, rw_t> RQCP1;
            /*
                ABRQ0
             */
            typedef reg_t<0x40006408, 0x00000001, 7, rw_t> ABRQ0;
            /*
                TERR0
             */
            typedef reg_t<0x40006408, 0x00000001, 3, rw_t> TERR0;
            /*
                ALST0
             */
            typedef reg_t<0x40006408, 0x00000001, 2, rw_t> ALST0;
            /*
                TXOK0
             */
            typedef reg_t<0x40006408, 0x00000001, 1, rw_t> TXOK0;
            /*
                RQCP0
             */
            typedef reg_t<0x40006408, 0x00000001, 0, rw_t> RQCP0;
        };
        /*
            receive FIFO 0 register
         */
        namespace RF0R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                RFOM0
             */
            typedef reg_t<0x4000640c, 0x00000001, 5, rw_t> RFOM0;
            /*
                FOVR0
             */
            typedef reg_t<0x4000640c, 0x00000001, 4, rw_t> FOVR0;
            /*
                FULL0
             */
            typedef reg_t<0x4000640c, 0x00000001, 3, rw_t> FULL0;
            /*
                FMP0
             */
            typedef reg_t<0x4000640c, 0x00000003, 0, ro_t> FMP0;
        };
        /*
            receive FIFO 1 register
         */
        namespace RF1R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                RFOM1
             */
            typedef reg_t<0x40006410, 0x00000001, 5, rw_t> RFOM1;
            /*
                FOVR1
             */
            typedef reg_t<0x40006410, 0x00000001, 4, rw_t> FOVR1;
            /*
                FULL1
             */
            typedef reg_t<0x40006410, 0x00000001, 3, rw_t> FULL1;
            /*
                FMP1
             */
            typedef reg_t<0x40006410, 0x00000003, 0, ro_t> FMP1;
        };
        /*
            interrupt enable register
         */
        namespace IER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006414, 0xffffffff, 0, rw_t> IER_REG;
            /*
                SLKIE
             */
            typedef reg_t<0x40006414, 0x00000001, 17, rw_t> SLKIE;
            /*
                WKUIE
             */
            typedef reg_t<0x40006414, 0x00000001, 16, rw_t> WKUIE;
            /*
                ERRIE
             */
            typedef reg_t<0x40006414, 0x00000001, 15, rw_t> ERRIE;
            /*
                LECIE
             */
            typedef reg_t<0x40006414, 0x00000001, 11, rw_t> LECIE;
            /*
                BOFIE
             */
            typedef reg_t<0x40006414, 0x00000001, 10, rw_t> BOFIE;
            /*
                EPVIE
             */
            typedef reg_t<0x40006414, 0x00000001, 9, rw_t> EPVIE;
            /*
                EWGIE
             */
            typedef reg_t<0x40006414, 0x00000001, 8, rw_t> EWGIE;
            /*
                FOVIE1
             */
            typedef reg_t<0x40006414, 0x00000001, 6, rw_t> FOVIE1;
            /*
                FFIE1
             */
            typedef reg_t<0x40006414, 0x00000001, 5, rw_t> FFIE1;
            /*
                FMPIE1
             */
            typedef reg_t<0x40006414, 0x00000001, 4, rw_t> FMPIE1;
            /*
                FOVIE0
             */
            typedef reg_t<0x40006414, 0x00000001, 3, rw_t> FOVIE0;
            /*
                FFIE0
             */
            typedef reg_t<0x40006414, 0x00000001, 2, rw_t> FFIE0;
            /*
                FMPIE0
             */
            typedef reg_t<0x40006414, 0x00000001, 1, rw_t> FMPIE0;
            /*
                TMEIE
             */
            typedef reg_t<0x40006414, 0x00000001, 0, rw_t> TMEIE;
        };
        /*
            error status register
         */
        namespace ESR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                REC
             */
            typedef reg_t<0x40006418, 0x000000ff, 24, ro_t> REC;
            /*
                TEC
             */
            typedef reg_t<0x40006418, 0x000000ff, 16, ro_t> TEC;
            /*
                LEC
             */
            typedef reg_t<0x40006418, 0x00000007, 4, rw_t> LEC;
            /*
                BOFF
             */
            typedef reg_t<0x40006418, 0x00000001, 2, ro_t> BOFF;
            /*
                EPVF
             */
            typedef reg_t<0x40006418, 0x00000001, 1, ro_t> EPVF;
            /*
                EWGF
             */
            typedef reg_t<0x40006418, 0x00000001, 0, ro_t> EWGF;
        };
        /*
            bit timing register
         */
        namespace BTR {

            static constexpr uint32_t RESETVALUE = 0x01230000;
            typedef reg_t<0x4000641c, 0xffffffff, 0, rw_t> BTR_REG;
            /*
                SILM
             */
            typedef reg_t<0x4000641c, 0x00000001, 31, rw_t> SILM;
            /*
                LBKM
             */
            typedef reg_t<0x4000641c, 0x00000001, 30, rw_t> LBKM;
            /*
                SJW
             */
            typedef reg_t<0x4000641c, 0x00000003, 24, rw_t> SJW;
            /*
                TS2
             */
            typedef reg_t<0x4000641c, 0x00000007, 20, rw_t> TS2;
            /*
                TS1
             */
            typedef reg_t<0x4000641c, 0x0000000f, 16, rw_t> TS1;
            /*
                BRP
             */
            typedef reg_t<0x4000641c, 0x000003ff, 0, rw_t> BRP;
        };
        /*
            TX mailbox identifier register
         */
        namespace TI0R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006580, 0xffffffff, 0, rw_t> TI0R_REG;
            /*
                STID
             */
            typedef reg_t<0x40006580, 0x000007ff, 21, rw_t> STID;
            /*
                EXID
             */
            typedef reg_t<0x40006580, 0x0003ffff, 3, rw_t> EXID;
            /*
                IDE
             */
            typedef reg_t<0x40006580, 0x00000001, 2, rw_t> IDE;
            /*
                RTR
             */
            typedef reg_t<0x40006580, 0x00000001, 1, rw_t> RTR;
            /*
                TXRQ
             */
            typedef reg_t<0x40006580, 0x00000001, 0, rw_t> TXRQ;
        };
        /*
            mailbox data length control and time stamp
          register
         */
        namespace TDT0R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006584, 0xffffffff, 0, rw_t> TDT0R_REG;
            /*
                TIME
             */
            typedef reg_t<0x40006584, 0x0000ffff, 16, rw_t> TIME;
            /*
                TGT
             */
            typedef reg_t<0x40006584, 0x00000001, 8, rw_t> TGT;
            /*
                DLC
             */
            typedef reg_t<0x40006584, 0x0000000f, 0, rw_t> DLC;
        };
        /*
            mailbox data low register
         */
        namespace TDL0R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006588, 0xffffffff, 0, rw_t> TDL0R_REG;
            /*
                DATA3
             */
            typedef reg_t<0x40006588, 0x000000ff, 24, rw_t> DATA3;
            /*
                DATA2
             */
            typedef reg_t<0x40006588, 0x000000ff, 16, rw_t> DATA2;
            /*
                DATA1
             */
            typedef reg_t<0x40006588, 0x000000ff, 8, rw_t> DATA1;
            /*
                DATA0
             */
            typedef reg_t<0x40006588, 0x000000ff, 0, rw_t> DATA0;
        };
        /*
            mailbox data high register
         */
        namespace TDH0R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000658c, 0xffffffff, 0, rw_t> TDH0R_REG;
            /*
                DATA7
             */
            typedef reg_t<0x4000658c, 0x000000ff, 24, rw_t> DATA7;
            /*
                DATA6
             */
            typedef reg_t<0x4000658c, 0x000000ff, 16, rw_t> DATA6;
            /*
                DATA5
             */
            typedef reg_t<0x4000658c, 0x000000ff, 8, rw_t> DATA5;
            /*
                DATA4
             */
            typedef reg_t<0x4000658c, 0x000000ff, 0, rw_t> DATA4;
        };
        /*
            TX mailbox identifier register
         */
        namespace TI1R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006590, 0xffffffff, 0, rw_t> TI1R_REG;
            /*
                STID
             */
            typedef reg_t<0x40006590, 0x000007ff, 21, rw_t> STID;
            /*
                EXID
             */
            typedef reg_t<0x40006590, 0x0003ffff, 3, rw_t> EXID;
            /*
                IDE
             */
            typedef reg_t<0x40006590, 0x00000001, 2, rw_t> IDE;
            /*
                RTR
             */
            typedef reg_t<0x40006590, 0x00000001, 1, rw_t> RTR;
            /*
                TXRQ
             */
            typedef reg_t<0x40006590, 0x00000001, 0, rw_t> TXRQ;
        };
        /*
            mailbox data length control and time stamp
          register
         */
        namespace TDT1R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006594, 0xffffffff, 0, rw_t> TDT1R_REG;
            /*
                TIME
             */
            typedef reg_t<0x40006594, 0x0000ffff, 16, rw_t> TIME;
            /*
                TGT
             */
            typedef reg_t<0x40006594, 0x00000001, 8, rw_t> TGT;
            /*
                DLC
             */
            typedef reg_t<0x40006594, 0x0000000f, 0, rw_t> DLC;
        };
        /*
            mailbox data low register
         */
        namespace TDL1R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006598, 0xffffffff, 0, rw_t> TDL1R_REG;
            /*
                DATA3
             */
            typedef reg_t<0x40006598, 0x000000ff, 24, rw_t> DATA3;
            /*
                DATA2
             */
            typedef reg_t<0x40006598, 0x000000ff, 16, rw_t> DATA2;
            /*
                DATA1
             */
            typedef reg_t<0x40006598, 0x000000ff, 8, rw_t> DATA1;
            /*
                DATA0
             */
            typedef reg_t<0x40006598, 0x000000ff, 0, rw_t> DATA0;
        };
        /*
            mailbox data high register
         */
        namespace TDH1R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000659c, 0xffffffff, 0, rw_t> TDH1R_REG;
            /*
                DATA7
             */
            typedef reg_t<0x4000659c, 0x000000ff, 24, rw_t> DATA7;
            /*
                DATA6
             */
            typedef reg_t<0x4000659c, 0x000000ff, 16, rw_t> DATA6;
            /*
                DATA5
             */
            typedef reg_t<0x4000659c, 0x000000ff, 8, rw_t> DATA5;
            /*
                DATA4
             */
            typedef reg_t<0x4000659c, 0x000000ff, 0, rw_t> DATA4;
        };
        /*
            TX mailbox identifier register
         */
        namespace TI2R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400065a0, 0xffffffff, 0, rw_t> TI2R_REG;
            /*
                STID
             */
            typedef reg_t<0x400065a0, 0x000007ff, 21, rw_t> STID;
            /*
                EXID
             */
            typedef reg_t<0x400065a0, 0x0003ffff, 3, rw_t> EXID;
            /*
                IDE
             */
            typedef reg_t<0x400065a0, 0x00000001, 2, rw_t> IDE;
            /*
                RTR
             */
            typedef reg_t<0x400065a0, 0x00000001, 1, rw_t> RTR;
            /*
                TXRQ
             */
            typedef reg_t<0x400065a0, 0x00000001, 0, rw_t> TXRQ;
        };
        /*
            mailbox data length control and time stamp
          register
         */
        namespace TDT2R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400065a4, 0xffffffff, 0, rw_t> TDT2R_REG;
            /*
                TIME
             */
            typedef reg_t<0x400065a4, 0x0000ffff, 16, rw_t> TIME;
            /*
                TGT
             */
            typedef reg_t<0x400065a4, 0x00000001, 8, rw_t> TGT;
            /*
                DLC
             */
            typedef reg_t<0x400065a4, 0x0000000f, 0, rw_t> DLC;
        };
        /*
            mailbox data low register
         */
        namespace TDL2R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400065a8, 0xffffffff, 0, rw_t> TDL2R_REG;
            /*
                DATA3
             */
            typedef reg_t<0x400065a8, 0x000000ff, 24, rw_t> DATA3;
            /*
                DATA2
             */
            typedef reg_t<0x400065a8, 0x000000ff, 16, rw_t> DATA2;
            /*
                DATA1
             */
            typedef reg_t<0x400065a8, 0x000000ff, 8, rw_t> DATA1;
            /*
                DATA0
             */
            typedef reg_t<0x400065a8, 0x000000ff, 0, rw_t> DATA0;
        };
        /*
            mailbox data high register
         */
        namespace TDH2R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400065ac, 0xffffffff, 0, rw_t> TDH2R_REG;
            /*
                DATA7
             */
            typedef reg_t<0x400065ac, 0x000000ff, 24, rw_t> DATA7;
            /*
                DATA6
             */
            typedef reg_t<0x400065ac, 0x000000ff, 16, rw_t> DATA6;
            /*
                DATA5
             */
            typedef reg_t<0x400065ac, 0x000000ff, 8, rw_t> DATA5;
            /*
                DATA4
             */
            typedef reg_t<0x400065ac, 0x000000ff, 0, rw_t> DATA4;
        };
        /*
            receive FIFO mailbox identifier
          register
         */
        namespace RI0R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400065b0, 0xffffffff, 0, ro_t> RI0R_REG;
            /*
                STID
             */
            typedef reg_t<0x400065b0, 0x000007ff, 21, ro_t> STID;
            /*
                EXID
             */
            typedef reg_t<0x400065b0, 0x0003ffff, 3, ro_t> EXID;
            /*
                IDE
             */
            typedef reg_t<0x400065b0, 0x00000001, 2, ro_t> IDE;
            /*
                RTR
             */
            typedef reg_t<0x400065b0, 0x00000001, 1, ro_t> RTR;
        };
        /*
            receive FIFO mailbox data length control and
          time stamp register
         */
        namespace RDT0R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400065b4, 0xffffffff, 0, ro_t> RDT0R_REG;
            /*
                TIME
             */
            typedef reg_t<0x400065b4, 0x0000ffff, 16, ro_t> TIME;
            /*
                FMI
             */
            typedef reg_t<0x400065b4, 0x000000ff, 8, ro_t> FMI;
            /*
                DLC
             */
            typedef reg_t<0x400065b4, 0x0000000f, 0, ro_t> DLC;
        };
        /*
            receive FIFO mailbox data low
          register
         */
        namespace RDL0R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400065b8, 0xffffffff, 0, ro_t> RDL0R_REG;
            /*
                DATA3
             */
            typedef reg_t<0x400065b8, 0x000000ff, 24, ro_t> DATA3;
            /*
                DATA2
             */
            typedef reg_t<0x400065b8, 0x000000ff, 16, ro_t> DATA2;
            /*
                DATA1
             */
            typedef reg_t<0x400065b8, 0x000000ff, 8, ro_t> DATA1;
            /*
                DATA0
             */
            typedef reg_t<0x400065b8, 0x000000ff, 0, ro_t> DATA0;
        };
        /*
            receive FIFO mailbox data high
          register
         */
        namespace RDH0R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400065bc, 0xffffffff, 0, ro_t> RDH0R_REG;
            /*
                DATA7
             */
            typedef reg_t<0x400065bc, 0x000000ff, 24, ro_t> DATA7;
            /*
                DATA6
             */
            typedef reg_t<0x400065bc, 0x000000ff, 16, ro_t> DATA6;
            /*
                DATA5
             */
            typedef reg_t<0x400065bc, 0x000000ff, 8, ro_t> DATA5;
            /*
                DATA4
             */
            typedef reg_t<0x400065bc, 0x000000ff, 0, ro_t> DATA4;
        };
        /*
            receive FIFO mailbox identifier
          register
         */
        namespace RI1R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400065c0, 0xffffffff, 0, ro_t> RI1R_REG;
            /*
                STID
             */
            typedef reg_t<0x400065c0, 0x000007ff, 21, ro_t> STID;
            /*
                EXID
             */
            typedef reg_t<0x400065c0, 0x0003ffff, 3, ro_t> EXID;
            /*
                IDE
             */
            typedef reg_t<0x400065c0, 0x00000001, 2, ro_t> IDE;
            /*
                RTR
             */
            typedef reg_t<0x400065c0, 0x00000001, 1, ro_t> RTR;
        };
        /*
            receive FIFO mailbox data length control and
          time stamp register
         */
        namespace RDT1R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400065c4, 0xffffffff, 0, ro_t> RDT1R_REG;
            /*
                TIME
             */
            typedef reg_t<0x400065c4, 0x0000ffff, 16, ro_t> TIME;
            /*
                FMI
             */
            typedef reg_t<0x400065c4, 0x000000ff, 8, ro_t> FMI;
            /*
                DLC
             */
            typedef reg_t<0x400065c4, 0x0000000f, 0, ro_t> DLC;
        };
        /*
            receive FIFO mailbox data low
          register
         */
        namespace RDL1R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400065c8, 0xffffffff, 0, ro_t> RDL1R_REG;
            /*
                DATA3
             */
            typedef reg_t<0x400065c8, 0x000000ff, 24, ro_t> DATA3;
            /*
                DATA2
             */
            typedef reg_t<0x400065c8, 0x000000ff, 16, ro_t> DATA2;
            /*
                DATA1
             */
            typedef reg_t<0x400065c8, 0x000000ff, 8, ro_t> DATA1;
            /*
                DATA0
             */
            typedef reg_t<0x400065c8, 0x000000ff, 0, ro_t> DATA0;
        };
        /*
            receive FIFO mailbox data high
          register
         */
        namespace RDH1R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400065cc, 0xffffffff, 0, ro_t> RDH1R_REG;
            /*
                DATA7
             */
            typedef reg_t<0x400065cc, 0x000000ff, 24, ro_t> DATA7;
            /*
                DATA6
             */
            typedef reg_t<0x400065cc, 0x000000ff, 16, ro_t> DATA6;
            /*
                DATA5
             */
            typedef reg_t<0x400065cc, 0x000000ff, 8, ro_t> DATA5;
            /*
                DATA4
             */
            typedef reg_t<0x400065cc, 0x000000ff, 0, ro_t> DATA4;
        };
        /*
            filter master register
         */
        namespace FMR {

            static constexpr uint32_t RESETVALUE = 0x2a1c0e01;
            typedef reg_t<0x40006600, 0xffffffff, 0, rw_t> FMR_REG;
            /*
                CAN2 start bank
             */
            typedef reg_t<0x40006600, 0x0000003f, 8, rw_t> CAN2SB;
            /*
                Filter init mode
             */
            typedef reg_t<0x40006600, 0x00000001, 0, rw_t> FINIT;
        };
        /*
            filter mode register
         */
        namespace FM1R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006604, 0xffffffff, 0, rw_t> FM1R_REG;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 0, rw_t> FBM0;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 1, rw_t> FBM1;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 2, rw_t> FBM2;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 3, rw_t> FBM3;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 4, rw_t> FBM4;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 5, rw_t> FBM5;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 6, rw_t> FBM6;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 7, rw_t> FBM7;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 8, rw_t> FBM8;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 9, rw_t> FBM9;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 10, rw_t> FBM10;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 11, rw_t> FBM11;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 12, rw_t> FBM12;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 13, rw_t> FBM13;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 14, rw_t> FBM14;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 15, rw_t> FBM15;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 16, rw_t> FBM16;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 17, rw_t> FBM17;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 18, rw_t> FBM18;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 19, rw_t> FBM19;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 20, rw_t> FBM20;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 21, rw_t> FBM21;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 22, rw_t> FBM22;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 23, rw_t> FBM23;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 24, rw_t> FBM24;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 25, rw_t> FBM25;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 26, rw_t> FBM26;
            /*
                Filter mode
             */
            typedef reg_t<0x40006604, 0x00000001, 27, rw_t> FBM27;
        };
        /*
            filter scale register
         */
        namespace FS1R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000660c, 0xffffffff, 0, rw_t> FS1R_REG;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 0, rw_t> FSC0;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 1, rw_t> FSC1;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 2, rw_t> FSC2;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 3, rw_t> FSC3;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 4, rw_t> FSC4;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 5, rw_t> FSC5;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 6, rw_t> FSC6;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 7, rw_t> FSC7;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 8, rw_t> FSC8;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 9, rw_t> FSC9;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 10, rw_t> FSC10;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 11, rw_t> FSC11;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 12, rw_t> FSC12;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 13, rw_t> FSC13;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 14, rw_t> FSC14;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 15, rw_t> FSC15;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 16, rw_t> FSC16;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 17, rw_t> FSC17;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 18, rw_t> FSC18;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 19, rw_t> FSC19;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 20, rw_t> FSC20;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 21, rw_t> FSC21;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 22, rw_t> FSC22;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 23, rw_t> FSC23;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 24, rw_t> FSC24;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 25, rw_t> FSC25;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 26, rw_t> FSC26;
            /*
                Filter scale configuration
             */
            typedef reg_t<0x4000660c, 0x00000001, 27, rw_t> FSC27;
        };
        /*
            filter FIFO assignment
          register
         */
        namespace FFA1R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006614, 0xffffffff, 0, rw_t> FFA1R_REG;
            /*
                Filter FIFO assignment for filter
              0
             */
            typedef reg_t<0x40006614, 0x00000001, 0, rw_t> FFA0;
            /*
                Filter FIFO assignment for filter
              1
             */
            typedef reg_t<0x40006614, 0x00000001, 1, rw_t> FFA1;
            /*
                Filter FIFO assignment for filter
              2
             */
            typedef reg_t<0x40006614, 0x00000001, 2, rw_t> FFA2;
            /*
                Filter FIFO assignment for filter
              3
             */
            typedef reg_t<0x40006614, 0x00000001, 3, rw_t> FFA3;
            /*
                Filter FIFO assignment for filter
              4
             */
            typedef reg_t<0x40006614, 0x00000001, 4, rw_t> FFA4;
            /*
                Filter FIFO assignment for filter
              5
             */
            typedef reg_t<0x40006614, 0x00000001, 5, rw_t> FFA5;
            /*
                Filter FIFO assignment for filter
              6
             */
            typedef reg_t<0x40006614, 0x00000001, 6, rw_t> FFA6;
            /*
                Filter FIFO assignment for filter
              7
             */
            typedef reg_t<0x40006614, 0x00000001, 7, rw_t> FFA7;
            /*
                Filter FIFO assignment for filter
              8
             */
            typedef reg_t<0x40006614, 0x00000001, 8, rw_t> FFA8;
            /*
                Filter FIFO assignment for filter
              9
             */
            typedef reg_t<0x40006614, 0x00000001, 9, rw_t> FFA9;
            /*
                Filter FIFO assignment for filter
              10
             */
            typedef reg_t<0x40006614, 0x00000001, 10, rw_t> FFA10;
            /*
                Filter FIFO assignment for filter
              11
             */
            typedef reg_t<0x40006614, 0x00000001, 11, rw_t> FFA11;
            /*
                Filter FIFO assignment for filter
              12
             */
            typedef reg_t<0x40006614, 0x00000001, 12, rw_t> FFA12;
            /*
                Filter FIFO assignment for filter
              13
             */
            typedef reg_t<0x40006614, 0x00000001, 13, rw_t> FFA13;
            /*
                Filter FIFO assignment for filter
              14
             */
            typedef reg_t<0x40006614, 0x00000001, 14, rw_t> FFA14;
            /*
                Filter FIFO assignment for filter
              15
             */
            typedef reg_t<0x40006614, 0x00000001, 15, rw_t> FFA15;
            /*
                Filter FIFO assignment for filter
              16
             */
            typedef reg_t<0x40006614, 0x00000001, 16, rw_t> FFA16;
            /*
                Filter FIFO assignment for filter
              17
             */
            typedef reg_t<0x40006614, 0x00000001, 17, rw_t> FFA17;
            /*
                Filter FIFO assignment for filter
              18
             */
            typedef reg_t<0x40006614, 0x00000001, 18, rw_t> FFA18;
            /*
                Filter FIFO assignment for filter
              19
             */
            typedef reg_t<0x40006614, 0x00000001, 19, rw_t> FFA19;
            /*
                Filter FIFO assignment for filter
              20
             */
            typedef reg_t<0x40006614, 0x00000001, 20, rw_t> FFA20;
            /*
                Filter FIFO assignment for filter
              21
             */
            typedef reg_t<0x40006614, 0x00000001, 21, rw_t> FFA21;
            /*
                Filter FIFO assignment for filter
              22
             */
            typedef reg_t<0x40006614, 0x00000001, 22, rw_t> FFA22;
            /*
                Filter FIFO assignment for filter
              23
             */
            typedef reg_t<0x40006614, 0x00000001, 23, rw_t> FFA23;
            /*
                Filter FIFO assignment for filter
              24
             */
            typedef reg_t<0x40006614, 0x00000001, 24, rw_t> FFA24;
            /*
                Filter FIFO assignment for filter
              25
             */
            typedef reg_t<0x40006614, 0x00000001, 25, rw_t> FFA25;
            /*
                Filter FIFO assignment for filter
              26
             */
            typedef reg_t<0x40006614, 0x00000001, 26, rw_t> FFA26;
            /*
                Filter FIFO assignment for filter
              27
             */
            typedef reg_t<0x40006614, 0x00000001, 27, rw_t> FFA27;
        };
        /*
            CAN filter activation register
         */
        namespace FA1R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000661c, 0xffffffff, 0, rw_t> FA1R_REG;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 0, rw_t> FACT0;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 1, rw_t> FACT1;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 2, rw_t> FACT2;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 3, rw_t> FACT3;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 4, rw_t> FACT4;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 5, rw_t> FACT5;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 6, rw_t> FACT6;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 7, rw_t> FACT7;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 8, rw_t> FACT8;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 9, rw_t> FACT9;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 10, rw_t> FACT10;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 11, rw_t> FACT11;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 12, rw_t> FACT12;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 13, rw_t> FACT13;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 14, rw_t> FACT14;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 15, rw_t> FACT15;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 16, rw_t> FACT16;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 17, rw_t> FACT17;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 18, rw_t> FACT18;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 19, rw_t> FACT19;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 20, rw_t> FACT20;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 21, rw_t> FACT21;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 22, rw_t> FACT22;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 23, rw_t> FACT23;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 24, rw_t> FACT24;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 25, rw_t> FACT25;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 26, rw_t> FACT26;
            /*
                Filter active
             */
            typedef reg_t<0x4000661c, 0x00000001, 27, rw_t> FACT27;
        };
        /*
            Filter bank 0 register 1
         */
        namespace F0R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006640, 0xffffffff, 0, rw_t> F0R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006640, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 0 register 2
         */
        namespace F0R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006644, 0xffffffff, 0, rw_t> F0R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006644, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 1 register 1
         */
        namespace F1R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006648, 0xffffffff, 0, rw_t> F1R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006648, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 1 register 2
         */
        namespace F1R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000664c, 0xffffffff, 0, rw_t> F1R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x4000664c, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 2 register 1
         */
        namespace F2R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006650, 0xffffffff, 0, rw_t> F2R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006650, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 2 register 2
         */
        namespace F2R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006654, 0xffffffff, 0, rw_t> F2R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006654, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 3 register 1
         */
        namespace F3R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006658, 0xffffffff, 0, rw_t> F3R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006658, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 3 register 2
         */
        namespace F3R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000665c, 0xffffffff, 0, rw_t> F3R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x4000665c, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 4 register 1
         */
        namespace F4R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006660, 0xffffffff, 0, rw_t> F4R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006660, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 4 register 2
         */
        namespace F4R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006664, 0xffffffff, 0, rw_t> F4R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006664, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 5 register 1
         */
        namespace F5R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006668, 0xffffffff, 0, rw_t> F5R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006668, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 5 register 2
         */
        namespace F5R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000666c, 0xffffffff, 0, rw_t> F5R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x4000666c, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 6 register 1
         */
        namespace F6R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006670, 0xffffffff, 0, rw_t> F6R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006670, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 6 register 2
         */
        namespace F6R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006674, 0xffffffff, 0, rw_t> F6R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006674, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 7 register 1
         */
        namespace F7R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006678, 0xffffffff, 0, rw_t> F7R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006678, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 7 register 2
         */
        namespace F7R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000667c, 0xffffffff, 0, rw_t> F7R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x4000667c, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 8 register 1
         */
        namespace F8R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006680, 0xffffffff, 0, rw_t> F8R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006680, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 8 register 2
         */
        namespace F8R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006684, 0xffffffff, 0, rw_t> F8R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006684, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 9 register 1
         */
        namespace F9R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006688, 0xffffffff, 0, rw_t> F9R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006688, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 9 register 2
         */
        namespace F9R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000668c, 0xffffffff, 0, rw_t> F9R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x4000668c, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 10 register 1
         */
        namespace F10R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006690, 0xffffffff, 0, rw_t> F10R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006690, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 10 register 2
         */
        namespace F10R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006694, 0xffffffff, 0, rw_t> F10R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006694, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 11 register 1
         */
        namespace F11R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006698, 0xffffffff, 0, rw_t> F11R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006698, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 11 register 2
         */
        namespace F11R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000669c, 0xffffffff, 0, rw_t> F11R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x4000669c, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 4 register 1
         */
        namespace F12R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066a0, 0xffffffff, 0, rw_t> F12R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a0, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 12 register 2
         */
        namespace F12R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066a4, 0xffffffff, 0, rw_t> F12R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a4, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 13 register 1
         */
        namespace F13R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066a8, 0xffffffff, 0, rw_t> F13R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066a8, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 13 register 2
         */
        namespace F13R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066ac, 0xffffffff, 0, rw_t> F13R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ac, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 14 register 1
         */
        namespace F14R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066b0, 0xffffffff, 0, rw_t> F14R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b0, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 14 register 2
         */
        namespace F14R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066b4, 0xffffffff, 0, rw_t> F14R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b4, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 15 register 1
         */
        namespace F15R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066b8, 0xffffffff, 0, rw_t> F15R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066b8, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 15 register 2
         */
        namespace F15R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066bc, 0xffffffff, 0, rw_t> F15R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066bc, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 16 register 1
         */
        namespace F16R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066c0, 0xffffffff, 0, rw_t> F16R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c0, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 16 register 2
         */
        namespace F16R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066c4, 0xffffffff, 0, rw_t> F16R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c4, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 17 register 1
         */
        namespace F17R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066c8, 0xffffffff, 0, rw_t> F17R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066c8, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 17 register 2
         */
        namespace F17R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066cc, 0xffffffff, 0, rw_t> F17R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066cc, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 18 register 1
         */
        namespace F18R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066d0, 0xffffffff, 0, rw_t> F18R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d0, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 18 register 2
         */
        namespace F18R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066d4, 0xffffffff, 0, rw_t> F18R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d4, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 19 register 1
         */
        namespace F19R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066d8, 0xffffffff, 0, rw_t> F19R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066d8, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 19 register 2
         */
        namespace F19R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066dc, 0xffffffff, 0, rw_t> F19R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066dc, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 20 register 1
         */
        namespace F20R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066e0, 0xffffffff, 0, rw_t> F20R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e0, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 20 register 2
         */
        namespace F20R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066e4, 0xffffffff, 0, rw_t> F20R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e4, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 21 register 1
         */
        namespace F21R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066e8, 0xffffffff, 0, rw_t> F21R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066e8, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 21 register 2
         */
        namespace F21R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066ec, 0xffffffff, 0, rw_t> F21R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066ec, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 22 register 1
         */
        namespace F22R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066f0, 0xffffffff, 0, rw_t> F22R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f0, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 22 register 2
         */
        namespace F22R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066f4, 0xffffffff, 0, rw_t> F22R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f4, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 23 register 1
         */
        namespace F23R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066f8, 0xffffffff, 0, rw_t> F23R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066f8, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 23 register 2
         */
        namespace F23R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400066fc, 0xffffffff, 0, rw_t> F23R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x400066fc, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 24 register 1
         */
        namespace F24R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006700, 0xffffffff, 0, rw_t> F24R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006700, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 24 register 2
         */
        namespace F24R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006704, 0xffffffff, 0, rw_t> F24R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006704, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 25 register 1
         */
        namespace F25R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006708, 0xffffffff, 0, rw_t> F25R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006708, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 25 register 2
         */
        namespace F25R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000670c, 0xffffffff, 0, rw_t> F25R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x4000670c, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 26 register 1
         */
        namespace F26R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006710, 0xffffffff, 0, rw_t> F26R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006710, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 26 register 2
         */
        namespace F26R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006714, 0xffffffff, 0, rw_t> F26R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006714, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 27 register 1
         */
        namespace F27R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40006718, 0xffffffff, 0, rw_t> F27R1_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x40006718, 0x00000001, 31, rw_t> FB31;
        };
        /*
            Filter bank 27 register 2
         */
        namespace F27R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000671c, 0xffffffff, 0, rw_t> F27R2_REG;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 0, rw_t> FB0;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 1, rw_t> FB1;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 2, rw_t> FB2;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 3, rw_t> FB3;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 4, rw_t> FB4;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 5, rw_t> FB5;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 6, rw_t> FB6;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 7, rw_t> FB7;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 8, rw_t> FB8;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 9, rw_t> FB9;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 10, rw_t> FB10;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 11, rw_t> FB11;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 12, rw_t> FB12;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 13, rw_t> FB13;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 14, rw_t> FB14;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 15, rw_t> FB15;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 16, rw_t> FB16;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 17, rw_t> FB17;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 18, rw_t> FB18;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 19, rw_t> FB19;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 20, rw_t> FB20;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 21, rw_t> FB21;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 22, rw_t> FB22;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 23, rw_t> FB23;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 24, rw_t> FB24;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 25, rw_t> FB25;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 26, rw_t> FB26;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 27, rw_t> FB27;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 28, rw_t> FB28;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 29, rw_t> FB29;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 30, rw_t> FB30;
            /*
                Filter bits
             */
            typedef reg_t<0x4000671c, 0x00000001, 31, rw_t> FB31;
        };
    };
    /*
        Universal serial bus full-speed device
      interface
     */
    namespace USB_FS {
        /*
            endpoint 0 register
         */
        namespace USB_EP0R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Endpoint address
             */
            typedef reg_t<0x40005c00, 0x0000000f, 0, rw_t> EA;
            /*
                Status bits, for transmission
              transfers
             */
            typedef reg_t<0x40005c00, 0x00000003, 4, rw_t> STAT_TX;
            /*
                Data Toggle, for transmission
              transfers
             */
            typedef reg_t<0x40005c00, 0x00000001, 6, rw_t> DTOG_TX;
            /*
                Correct Transfer for
              transmission
             */
            typedef reg_t<0x40005c00, 0x00000001, 7, rw_t> CTR_TX;
            /*
                Endpoint kind
             */
            typedef reg_t<0x40005c00, 0x00000001, 8, rw_t> EP_KIND;
            /*
                Endpoint type
             */
            typedef reg_t<0x40005c00, 0x00000003, 9, rw_t> EP_TYPE;
            /*
                Setup transaction
              completed
             */
            typedef reg_t<0x40005c00, 0x00000001, 11, ro_t> SETUP;
            /*
                Status bits, for reception
              transfers
             */
            typedef reg_t<0x40005c00, 0x00000003, 12, rw_t> STAT_RX;
            /*
                Data Toggle, for reception
              transfers
             */
            typedef reg_t<0x40005c00, 0x00000001, 14, rw_t> DTOG_RX;
            /*
                Correct transfer for
              reception
             */
            typedef reg_t<0x40005c00, 0x00000001, 15, rw_t> CTR_RX;
        };
        /*
            endpoint 1 register
         */
        namespace USB_EP1R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Endpoint address
             */
            typedef reg_t<0x40005c04, 0x0000000f, 0, rw_t> EA;
            /*
                Status bits, for transmission
              transfers
             */
            typedef reg_t<0x40005c04, 0x00000003, 4, rw_t> STAT_TX;
            /*
                Data Toggle, for transmission
              transfers
             */
            typedef reg_t<0x40005c04, 0x00000001, 6, rw_t> DTOG_TX;
            /*
                Correct Transfer for
              transmission
             */
            typedef reg_t<0x40005c04, 0x00000001, 7, rw_t> CTR_TX;
            /*
                Endpoint kind
             */
            typedef reg_t<0x40005c04, 0x00000001, 8, rw_t> EP_KIND;
            /*
                Endpoint type
             */
            typedef reg_t<0x40005c04, 0x00000003, 9, rw_t> EP_TYPE;
            /*
                Setup transaction
              completed
             */
            typedef reg_t<0x40005c04, 0x00000001, 11, ro_t> SETUP;
            /*
                Status bits, for reception
              transfers
             */
            typedef reg_t<0x40005c04, 0x00000003, 12, rw_t> STAT_RX;
            /*
                Data Toggle, for reception
              transfers
             */
            typedef reg_t<0x40005c04, 0x00000001, 14, rw_t> DTOG_RX;
            /*
                Correct transfer for
              reception
             */
            typedef reg_t<0x40005c04, 0x00000001, 15, rw_t> CTR_RX;
        };
        /*
            endpoint 2 register
         */
        namespace USB_EP2R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Endpoint address
             */
            typedef reg_t<0x40005c08, 0x0000000f, 0, rw_t> EA;
            /*
                Status bits, for transmission
              transfers
             */
            typedef reg_t<0x40005c08, 0x00000003, 4, rw_t> STAT_TX;
            /*
                Data Toggle, for transmission
              transfers
             */
            typedef reg_t<0x40005c08, 0x00000001, 6, rw_t> DTOG_TX;
            /*
                Correct Transfer for
              transmission
             */
            typedef reg_t<0x40005c08, 0x00000001, 7, rw_t> CTR_TX;
            /*
                Endpoint kind
             */
            typedef reg_t<0x40005c08, 0x00000001, 8, rw_t> EP_KIND;
            /*
                Endpoint type
             */
            typedef reg_t<0x40005c08, 0x00000003, 9, rw_t> EP_TYPE;
            /*
                Setup transaction
              completed
             */
            typedef reg_t<0x40005c08, 0x00000001, 11, ro_t> SETUP;
            /*
                Status bits, for reception
              transfers
             */
            typedef reg_t<0x40005c08, 0x00000003, 12, rw_t> STAT_RX;
            /*
                Data Toggle, for reception
              transfers
             */
            typedef reg_t<0x40005c08, 0x00000001, 14, rw_t> DTOG_RX;
            /*
                Correct transfer for
              reception
             */
            typedef reg_t<0x40005c08, 0x00000001, 15, rw_t> CTR_RX;
        };
        /*
            endpoint 3 register
         */
        namespace USB_EP3R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Endpoint address
             */
            typedef reg_t<0x40005c0c, 0x0000000f, 0, rw_t> EA;
            /*
                Status bits, for transmission
              transfers
             */
            typedef reg_t<0x40005c0c, 0x00000003, 4, rw_t> STAT_TX;
            /*
                Data Toggle, for transmission
              transfers
             */
            typedef reg_t<0x40005c0c, 0x00000001, 6, rw_t> DTOG_TX;
            /*
                Correct Transfer for
              transmission
             */
            typedef reg_t<0x40005c0c, 0x00000001, 7, rw_t> CTR_TX;
            /*
                Endpoint kind
             */
            typedef reg_t<0x40005c0c, 0x00000001, 8, rw_t> EP_KIND;
            /*
                Endpoint type
             */
            typedef reg_t<0x40005c0c, 0x00000003, 9, rw_t> EP_TYPE;
            /*
                Setup transaction
              completed
             */
            typedef reg_t<0x40005c0c, 0x00000001, 11, ro_t> SETUP;
            /*
                Status bits, for reception
              transfers
             */
            typedef reg_t<0x40005c0c, 0x00000003, 12, rw_t> STAT_RX;
            /*
                Data Toggle, for reception
              transfers
             */
            typedef reg_t<0x40005c0c, 0x00000001, 14, rw_t> DTOG_RX;
            /*
                Correct transfer for
              reception
             */
            typedef reg_t<0x40005c0c, 0x00000001, 15, rw_t> CTR_RX;
        };
        /*
            endpoint 4 register
         */
        namespace USB_EP4R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Endpoint address
             */
            typedef reg_t<0x40005c10, 0x0000000f, 0, rw_t> EA;
            /*
                Status bits, for transmission
              transfers
             */
            typedef reg_t<0x40005c10, 0x00000003, 4, rw_t> STAT_TX;
            /*
                Data Toggle, for transmission
              transfers
             */
            typedef reg_t<0x40005c10, 0x00000001, 6, rw_t> DTOG_TX;
            /*
                Correct Transfer for
              transmission
             */
            typedef reg_t<0x40005c10, 0x00000001, 7, rw_t> CTR_TX;
            /*
                Endpoint kind
             */
            typedef reg_t<0x40005c10, 0x00000001, 8, rw_t> EP_KIND;
            /*
                Endpoint type
             */
            typedef reg_t<0x40005c10, 0x00000003, 9, rw_t> EP_TYPE;
            /*
                Setup transaction
              completed
             */
            typedef reg_t<0x40005c10, 0x00000001, 11, ro_t> SETUP;
            /*
                Status bits, for reception
              transfers
             */
            typedef reg_t<0x40005c10, 0x00000003, 12, rw_t> STAT_RX;
            /*
                Data Toggle, for reception
              transfers
             */
            typedef reg_t<0x40005c10, 0x00000001, 14, rw_t> DTOG_RX;
            /*
                Correct transfer for
              reception
             */
            typedef reg_t<0x40005c10, 0x00000001, 15, rw_t> CTR_RX;
        };
        /*
            endpoint 5 register
         */
        namespace USB_EP5R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Endpoint address
             */
            typedef reg_t<0x40005c14, 0x0000000f, 0, rw_t> EA;
            /*
                Status bits, for transmission
              transfers
             */
            typedef reg_t<0x40005c14, 0x00000003, 4, rw_t> STAT_TX;
            /*
                Data Toggle, for transmission
              transfers
             */
            typedef reg_t<0x40005c14, 0x00000001, 6, rw_t> DTOG_TX;
            /*
                Correct Transfer for
              transmission
             */
            typedef reg_t<0x40005c14, 0x00000001, 7, rw_t> CTR_TX;
            /*
                Endpoint kind
             */
            typedef reg_t<0x40005c14, 0x00000001, 8, rw_t> EP_KIND;
            /*
                Endpoint type
             */
            typedef reg_t<0x40005c14, 0x00000003, 9, rw_t> EP_TYPE;
            /*
                Setup transaction
              completed
             */
            typedef reg_t<0x40005c14, 0x00000001, 11, ro_t> SETUP;
            /*
                Status bits, for reception
              transfers
             */
            typedef reg_t<0x40005c14, 0x00000003, 12, rw_t> STAT_RX;
            /*
                Data Toggle, for reception
              transfers
             */
            typedef reg_t<0x40005c14, 0x00000001, 14, rw_t> DTOG_RX;
            /*
                Correct transfer for
              reception
             */
            typedef reg_t<0x40005c14, 0x00000001, 15, rw_t> CTR_RX;
        };
        /*
            endpoint 6 register
         */
        namespace USB_EP6R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Endpoint address
             */
            typedef reg_t<0x40005c18, 0x0000000f, 0, rw_t> EA;
            /*
                Status bits, for transmission
              transfers
             */
            typedef reg_t<0x40005c18, 0x00000003, 4, rw_t> STAT_TX;
            /*
                Data Toggle, for transmission
              transfers
             */
            typedef reg_t<0x40005c18, 0x00000001, 6, rw_t> DTOG_TX;
            /*
                Correct Transfer for
              transmission
             */
            typedef reg_t<0x40005c18, 0x00000001, 7, rw_t> CTR_TX;
            /*
                Endpoint kind
             */
            typedef reg_t<0x40005c18, 0x00000001, 8, rw_t> EP_KIND;
            /*
                Endpoint type
             */
            typedef reg_t<0x40005c18, 0x00000003, 9, rw_t> EP_TYPE;
            /*
                Setup transaction
              completed
             */
            typedef reg_t<0x40005c18, 0x00000001, 11, ro_t> SETUP;
            /*
                Status bits, for reception
              transfers
             */
            typedef reg_t<0x40005c18, 0x00000003, 12, rw_t> STAT_RX;
            /*
                Data Toggle, for reception
              transfers
             */
            typedef reg_t<0x40005c18, 0x00000001, 14, rw_t> DTOG_RX;
            /*
                Correct transfer for
              reception
             */
            typedef reg_t<0x40005c18, 0x00000001, 15, rw_t> CTR_RX;
        };
        /*
            endpoint 7 register
         */
        namespace USB_EP7R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Endpoint address
             */
            typedef reg_t<0x40005c1c, 0x0000000f, 0, rw_t> EA;
            /*
                Status bits, for transmission
              transfers
             */
            typedef reg_t<0x40005c1c, 0x00000003, 4, rw_t> STAT_TX;
            /*
                Data Toggle, for transmission
              transfers
             */
            typedef reg_t<0x40005c1c, 0x00000001, 6, rw_t> DTOG_TX;
            /*
                Correct Transfer for
              transmission
             */
            typedef reg_t<0x40005c1c, 0x00000001, 7, rw_t> CTR_TX;
            /*
                Endpoint kind
             */
            typedef reg_t<0x40005c1c, 0x00000001, 8, rw_t> EP_KIND;
            /*
                Endpoint type
             */
            typedef reg_t<0x40005c1c, 0x00000003, 9, rw_t> EP_TYPE;
            /*
                Setup transaction
              completed
             */
            typedef reg_t<0x40005c1c, 0x00000001, 11, ro_t> SETUP;
            /*
                Status bits, for reception
              transfers
             */
            typedef reg_t<0x40005c1c, 0x00000003, 12, rw_t> STAT_RX;
            /*
                Data Toggle, for reception
              transfers
             */
            typedef reg_t<0x40005c1c, 0x00000001, 14, rw_t> DTOG_RX;
            /*
                Correct transfer for
              reception
             */
            typedef reg_t<0x40005c1c, 0x00000001, 15, rw_t> CTR_RX;
        };
        /*
            control register
         */
        namespace USB_CNTR {

            static constexpr uint32_t RESETVALUE = 0x00000003;
            typedef reg_t<0x40005c40, 0xffffffff, 0, rw_t> USB_CNTR_REG;
            /*
                Force USB Reset
             */
            typedef reg_t<0x40005c40, 0x00000001, 0, rw_t> FRES;
            /*
                Power down
             */
            typedef reg_t<0x40005c40, 0x00000001, 1, rw_t> PDWN;
            /*
                Low-power mode
             */
            typedef reg_t<0x40005c40, 0x00000001, 2, rw_t> LPMODE;
            /*
                Force suspend
             */
            typedef reg_t<0x40005c40, 0x00000001, 3, rw_t> FSUSP;
            /*
                Resume request
             */
            typedef reg_t<0x40005c40, 0x00000001, 4, rw_t> RESUME;
            /*
                Expected start of frame interrupt
              mask
             */
            typedef reg_t<0x40005c40, 0x00000001, 8, rw_t> ESOFM;
            /*
                Start of frame interrupt
              mask
             */
            typedef reg_t<0x40005c40, 0x00000001, 9, rw_t> SOFM;
            /*
                USB reset interrupt mask
             */
            typedef reg_t<0x40005c40, 0x00000001, 10, rw_t> RESETM;
            /*
                Suspend mode interrupt
              mask
             */
            typedef reg_t<0x40005c40, 0x00000001, 11, rw_t> SUSPM;
            /*
                Wakeup interrupt mask
             */
            typedef reg_t<0x40005c40, 0x00000001, 12, rw_t> WKUPM;
            /*
                Error interrupt mask
             */
            typedef reg_t<0x40005c40, 0x00000001, 13, rw_t> ERRM;
            /*
                Packet memory area over / underrun
              interrupt mask
             */
            typedef reg_t<0x40005c40, 0x00000001, 14, rw_t> PMAOVRM;
            /*
                Correct transfer interrupt
              mask
             */
            typedef reg_t<0x40005c40, 0x00000001, 15, rw_t> CTRM;
        };
        /*
            interrupt status register
         */
        namespace ISTR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Endpoint Identifier
             */
            typedef reg_t<0x40005c44, 0x0000000f, 0, ro_t> EP_ID;
            /*
                Direction of transaction
             */
            typedef reg_t<0x40005c44, 0x00000001, 4, ro_t> DIR;
            /*
                Expected start frame
             */
            typedef reg_t<0x40005c44, 0x00000001, 8, rw_t> ESOF;
            /*
                start of frame
             */
            typedef reg_t<0x40005c44, 0x00000001, 9, rw_t> SOF;
            /*
                reset request
             */
            typedef reg_t<0x40005c44, 0x00000001, 10, rw_t> RESET;
            /*
                Suspend mode request
             */
            typedef reg_t<0x40005c44, 0x00000001, 11, rw_t> SUSP;
            /*
                Wakeup
             */
            typedef reg_t<0x40005c44, 0x00000001, 12, rw_t> WKUP;
            /*
                Error
             */
            typedef reg_t<0x40005c44, 0x00000001, 13, rw_t> ERR;
            /*
                Packet memory area over /
              underrun
             */
            typedef reg_t<0x40005c44, 0x00000001, 14, rw_t> PMAOVR;
            /*
                Correct transfer
             */
            typedef reg_t<0x40005c44, 0x00000001, 15, ro_t> CTR;
        };
        /*
            frame number register
         */
        namespace FNR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005c48, 0xffffffff, 0, ro_t> FNR_REG;
            /*
                Frame number
             */
            typedef reg_t<0x40005c48, 0x000007ff, 0, ro_t> FN;
            /*
                Lost SOF
             */
            typedef reg_t<0x40005c48, 0x00000003, 11, ro_t> LSOF;
            /*
                Locked
             */
            typedef reg_t<0x40005c48, 0x00000001, 13, ro_t> LCK;
            /*
                Receive data - line status
             */
            typedef reg_t<0x40005c48, 0x00000001, 14, ro_t> RXDM;
            /*
                Receive data + line status
             */
            typedef reg_t<0x40005c48, 0x00000001, 15, ro_t> RXDP;
        };
        /*
            device address
         */
        namespace DADDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005c4c, 0xffffffff, 0, rw_t> DADDR_REG;
            /*
                Device address
             */
            typedef reg_t<0x40005c4c, 0x00000001, 0, rw_t> ADD;
            /*
                Device address
             */
            typedef reg_t<0x40005c4c, 0x00000001, 1, rw_t> ADD1;
            /*
                Device address
             */
            typedef reg_t<0x40005c4c, 0x00000001, 2, rw_t> ADD2;
            /*
                Device address
             */
            typedef reg_t<0x40005c4c, 0x00000001, 3, rw_t> ADD3;
            /*
                Device address
             */
            typedef reg_t<0x40005c4c, 0x00000001, 4, rw_t> ADD4;
            /*
                Device address
             */
            typedef reg_t<0x40005c4c, 0x00000001, 5, rw_t> ADD5;
            /*
                Device address
             */
            typedef reg_t<0x40005c4c, 0x00000001, 6, rw_t> ADD6;
            /*
                Enable function
             */
            typedef reg_t<0x40005c4c, 0x00000001, 7, rw_t> EF;
        };
        /*
            Buffer table address
         */
        namespace BTABLE {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005c50, 0xffffffff, 0, rw_t> BTABLE_REG;
            /*
                Buffer table
             */
            typedef reg_t<0x40005c50, 0x00001fff, 3, rw_t> BTABLE;
        };
    };
    /*
        Inter-integrated circuit
     */
    namespace I2C1 {
        /*
            Control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Peripheral enable
             */
            typedef reg_t<0x40005400, 0x00000001, 0, rw_t> PE;
            /*
                TX Interrupt enable
             */
            typedef reg_t<0x40005400, 0x00000001, 1, rw_t> TXIE;
            /*
                RX Interrupt enable
             */
            typedef reg_t<0x40005400, 0x00000001, 2, rw_t> RXIE;
            /*
                Address match interrupt enable (slave
              only)
             */
            typedef reg_t<0x40005400, 0x00000001, 3, rw_t> ADDRIE;
            /*
                Not acknowledge received interrupt
              enable
             */
            typedef reg_t<0x40005400, 0x00000001, 4, rw_t> NACKIE;
            /*
                STOP detection Interrupt
              enable
             */
            typedef reg_t<0x40005400, 0x00000001, 5, rw_t> STOPIE;
            /*
                Transfer Complete interrupt
              enable
             */
            typedef reg_t<0x40005400, 0x00000001, 6, rw_t> TCIE;
            /*
                Error interrupts enable
             */
            typedef reg_t<0x40005400, 0x00000001, 7, rw_t> ERRIE;
            /*
                Digital noise filter
             */
            typedef reg_t<0x40005400, 0x0000000f, 8, rw_t> DNF;
            /*
                Analog noise filter OFF
             */
            typedef reg_t<0x40005400, 0x00000001, 12, rw_t> ANFOFF;
            /*
                Software reset
             */
            typedef reg_t<0x40005400, 0x00000001, 13, wo_t> SWRST;
            /*
                DMA transmission requests
              enable
             */
            typedef reg_t<0x40005400, 0x00000001, 14, rw_t> TXDMAEN;
            /*
                DMA reception requests
              enable
             */
            typedef reg_t<0x40005400, 0x00000001, 15, rw_t> RXDMAEN;
            /*
                Slave byte control
             */
            typedef reg_t<0x40005400, 0x00000001, 16, rw_t> SBC;
            /*
                Clock stretching disable
             */
            typedef reg_t<0x40005400, 0x00000001, 17, rw_t> NOSTRETCH;
            /*
                Wakeup from STOP enable
             */
            typedef reg_t<0x40005400, 0x00000001, 18, rw_t> WUPEN;
            /*
                General call enable
             */
            typedef reg_t<0x40005400, 0x00000001, 19, rw_t> GCEN;
            /*
                SMBus Host address enable
             */
            typedef reg_t<0x40005400, 0x00000001, 20, rw_t> SMBHEN;
            /*
                SMBus Device Default address
              enable
             */
            typedef reg_t<0x40005400, 0x00000001, 21, rw_t> SMBDEN;
            /*
                SMBUS alert enable
             */
            typedef reg_t<0x40005400, 0x00000001, 22, rw_t> ALERTEN;
            /*
                PEC enable
             */
            typedef reg_t<0x40005400, 0x00000001, 23, rw_t> PECEN;
        };
        /*
            Control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005404, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                Packet error checking byte
             */
            typedef reg_t<0x40005404, 0x00000001, 26, rw_t> PECBYTE;
            /*
                Automatic end mode (master
              mode)
             */
            typedef reg_t<0x40005404, 0x00000001, 25, rw_t> AUTOEND;
            /*
                NBYTES reload mode
             */
            typedef reg_t<0x40005404, 0x00000001, 24, rw_t> RELOAD;
            /*
                Number of bytes
             */
            typedef reg_t<0x40005404, 0x000000ff, 16, rw_t> NBYTES;
            /*
                NACK generation (slave
              mode)
             */
            typedef reg_t<0x40005404, 0x00000001, 15, rw_t> NACK;
            /*
                Stop generation (master
              mode)
             */
            typedef reg_t<0x40005404, 0x00000001, 14, rw_t> STOP;
            /*
                Start generation
             */
            typedef reg_t<0x40005404, 0x00000001, 13, rw_t> START;
            /*
                10-bit address header only read
              direction (master receiver mode)
             */
            typedef reg_t<0x40005404, 0x00000001, 12, rw_t> HEAD10R;
            /*
                10-bit addressing mode (master
              mode)
             */
            typedef reg_t<0x40005404, 0x00000001, 11, rw_t> ADD10;
            /*
                Transfer direction (master
              mode)
             */
            typedef reg_t<0x40005404, 0x00000001, 10, rw_t> RD_WRN;
            /*
                Slave address bit 9:8 (master
              mode)
             */
            typedef reg_t<0x40005404, 0x00000003, 8, rw_t> SADD8;
            /*
                Slave address bit 7:1 (master
              mode)
             */
            typedef reg_t<0x40005404, 0x0000007f, 1, rw_t> SADD1;
            /*
                Slave address bit 0 (master
              mode)
             */
            typedef reg_t<0x40005404, 0x00000001, 0, rw_t> SADD0;
        };
        /*
            Own address register 1
         */
        namespace OAR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005408, 0xffffffff, 0, rw_t> OAR1_REG;
            /*
                Interface address
             */
            typedef reg_t<0x40005408, 0x00000001, 0, rw_t> OA1_0;
            /*
                Interface address
             */
            typedef reg_t<0x40005408, 0x0000007f, 1, rw_t> OA1_1;
            /*
                Interface address
             */
            typedef reg_t<0x40005408, 0x00000003, 8, rw_t> OA1_8;
            /*
                Own Address 1 10-bit mode
             */
            typedef reg_t<0x40005408, 0x00000001, 10, rw_t> OA1MODE;
            /*
                Own Address 1 enable
             */
            typedef reg_t<0x40005408, 0x00000001, 15, rw_t> OA1EN;
        };
        /*
            Own address register 2
         */
        namespace OAR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000540c, 0xffffffff, 0, rw_t> OAR2_REG;
            /*
                Interface address
             */
            typedef reg_t<0x4000540c, 0x0000007f, 1, rw_t> OA2;
            /*
                Own Address 2 masks
             */
            typedef reg_t<0x4000540c, 0x00000007, 8, rw_t> OA2MSK;
            /*
                Own Address 2 enable
             */
            typedef reg_t<0x4000540c, 0x00000001, 15, rw_t> OA2EN;
        };
        /*
            Timing register
         */
        namespace TIMINGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005410, 0xffffffff, 0, rw_t> TIMINGR_REG;
            /*
                SCL low period (master
              mode)
             */
            typedef reg_t<0x40005410, 0x000000ff, 0, rw_t> SCLL;
            /*
                SCL high period (master
              mode)
             */
            typedef reg_t<0x40005410, 0x000000ff, 8, rw_t> SCLH;
            /*
                Data hold time
             */
            typedef reg_t<0x40005410, 0x0000000f, 16, rw_t> SDADEL;
            /*
                Data setup time
             */
            typedef reg_t<0x40005410, 0x0000000f, 20, rw_t> SCLDEL;
            /*
                Timing prescaler
             */
            typedef reg_t<0x40005410, 0x0000000f, 28, rw_t> PRESC;
        };
        /*
            Status register 1
         */
        namespace TIMEOUTR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005414, 0xffffffff, 0, rw_t> TIMEOUTR_REG;
            /*
                Bus timeout A
             */
            typedef reg_t<0x40005414, 0x00000fff, 0, rw_t> TIMEOUTA;
            /*
                Idle clock timeout
              detection
             */
            typedef reg_t<0x40005414, 0x00000001, 12, rw_t> TIDLE;
            /*
                Clock timeout enable
             */
            typedef reg_t<0x40005414, 0x00000001, 15, rw_t> TIMOUTEN;
            /*
                Bus timeout B
             */
            typedef reg_t<0x40005414, 0x00000fff, 16, rw_t> TIMEOUTB;
            /*
                Extended clock timeout
              enable
             */
            typedef reg_t<0x40005414, 0x00000001, 31, rw_t> TEXTEN;
        };
        /*
            Interrupt and Status register
         */
        namespace ISR {

            static constexpr uint32_t RESETVALUE = 0x00000001;
            /*
                Address match code (Slave
              mode)
             */
            typedef reg_t<0x40005418, 0x0000007f, 17, ro_t> ADDCODE;
            /*
                Transfer direction (Slave
              mode)
             */
            typedef reg_t<0x40005418, 0x00000001, 16, ro_t> DIR;
            /*
                Bus busy
             */
            typedef reg_t<0x40005418, 0x00000001, 15, ro_t> BUSY;
            /*
                SMBus alert
             */
            typedef reg_t<0x40005418, 0x00000001, 13, ro_t> ALERT;
            /*
                Timeout or t_low detection
              flag
             */
            typedef reg_t<0x40005418, 0x00000001, 12, ro_t> TIMEOUT;
            /*
                PEC Error in reception
             */
            typedef reg_t<0x40005418, 0x00000001, 11, ro_t> PECERR;
            /*
                Overrun/Underrun (slave
              mode)
             */
            typedef reg_t<0x40005418, 0x00000001, 10, ro_t> OVR;
            /*
                Arbitration lost
             */
            typedef reg_t<0x40005418, 0x00000001, 9, ro_t> ARLO;
            /*
                Bus error
             */
            typedef reg_t<0x40005418, 0x00000001, 8, ro_t> BERR;
            /*
                Transfer Complete Reload
             */
            typedef reg_t<0x40005418, 0x00000001, 7, ro_t> TCR;
            /*
                Transfer Complete (master
              mode)
             */
            typedef reg_t<0x40005418, 0x00000001, 6, ro_t> TC;
            /*
                Stop detection flag
             */
            typedef reg_t<0x40005418, 0x00000001, 5, ro_t> STOPF;
            /*
                Not acknowledge received
              flag
             */
            typedef reg_t<0x40005418, 0x00000001, 4, ro_t> NACKF;
            /*
                Address matched (slave
              mode)
             */
            typedef reg_t<0x40005418, 0x00000001, 3, ro_t> ADDR;
            /*
                Receive data register not empty
              (receivers)
             */
            typedef reg_t<0x40005418, 0x00000001, 2, ro_t> RXNE;
            /*
                Transmit interrupt status
              (transmitters)
             */
            typedef reg_t<0x40005418, 0x00000001, 1, rw_t> TXIS;
            /*
                Transmit data register empty
              (transmitters)
             */
            typedef reg_t<0x40005418, 0x00000001, 0, rw_t> TXE;
        };
        /*
            Interrupt clear register
         */
        namespace ICR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000541c, 0xffffffff, 0, wo_t> ICR_REG;
            /*
                Alert flag clear
             */
            typedef reg_t<0x4000541c, 0x00000001, 13, wo_t> ALERTCF;
            /*
                Timeout detection flag
              clear
             */
            typedef reg_t<0x4000541c, 0x00000001, 12, wo_t> TIMOUTCF;
            /*
                PEC Error flag clear
             */
            typedef reg_t<0x4000541c, 0x00000001, 11, wo_t> PECCF;
            /*
                Overrun/Underrun flag
              clear
             */
            typedef reg_t<0x4000541c, 0x00000001, 10, wo_t> OVRCF;
            /*
                Arbitration lost flag
              clear
             */
            typedef reg_t<0x4000541c, 0x00000001, 9, wo_t> ARLOCF;
            /*
                Bus error flag clear
             */
            typedef reg_t<0x4000541c, 0x00000001, 8, wo_t> BERRCF;
            /*
                Stop detection flag clear
             */
            typedef reg_t<0x4000541c, 0x00000001, 5, wo_t> STOPCF;
            /*
                Not Acknowledge flag clear
             */
            typedef reg_t<0x4000541c, 0x00000001, 4, wo_t> NACKCF;
            /*
                Address Matched flag clear
             */
            typedef reg_t<0x4000541c, 0x00000001, 3, wo_t> ADDRCF;
        };
        /*
            PEC register
         */
        namespace PECR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005420, 0xffffffff, 0, ro_t> PECR_REG;
            /*
                Packet error checking
              register
             */
            typedef reg_t<0x40005420, 0x000000ff, 0, ro_t> PEC;
        };
        /*
            Receive data register
         */
        namespace RXDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005424, 0xffffffff, 0, ro_t> RXDR_REG;
            /*
                8-bit receive data
             */
            typedef reg_t<0x40005424, 0x000000ff, 0, ro_t> RXDATA;
        };
        /*
            Transmit data register
         */
        namespace TXDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005428, 0xffffffff, 0, rw_t> TXDR_REG;
            /*
                8-bit transmit data
             */
            typedef reg_t<0x40005428, 0x000000ff, 0, rw_t> TXDATA;
        };
    };
    /*
        Inter-integrated circuit
     */
    namespace I2C2 {
        /*
            Control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Peripheral enable
             */
            typedef reg_t<0x40005800, 0x00000001, 0, rw_t> PE;
            /*
                TX Interrupt enable
             */
            typedef reg_t<0x40005800, 0x00000001, 1, rw_t> TXIE;
            /*
                RX Interrupt enable
             */
            typedef reg_t<0x40005800, 0x00000001, 2, rw_t> RXIE;
            /*
                Address match interrupt enable (slave
              only)
             */
            typedef reg_t<0x40005800, 0x00000001, 3, rw_t> ADDRIE;
            /*
                Not acknowledge received interrupt
              enable
             */
            typedef reg_t<0x40005800, 0x00000001, 4, rw_t> NACKIE;
            /*
                STOP detection Interrupt
              enable
             */
            typedef reg_t<0x40005800, 0x00000001, 5, rw_t> STOPIE;
            /*
                Transfer Complete interrupt
              enable
             */
            typedef reg_t<0x40005800, 0x00000001, 6, rw_t> TCIE;
            /*
                Error interrupts enable
             */
            typedef reg_t<0x40005800, 0x00000001, 7, rw_t> ERRIE;
            /*
                Digital noise filter
             */
            typedef reg_t<0x40005800, 0x0000000f, 8, rw_t> DNF;
            /*
                Analog noise filter OFF
             */
            typedef reg_t<0x40005800, 0x00000001, 12, rw_t> ANFOFF;
            /*
                Software reset
             */
            typedef reg_t<0x40005800, 0x00000001, 13, wo_t> SWRST;
            /*
                DMA transmission requests
              enable
             */
            typedef reg_t<0x40005800, 0x00000001, 14, rw_t> TXDMAEN;
            /*
                DMA reception requests
              enable
             */
            typedef reg_t<0x40005800, 0x00000001, 15, rw_t> RXDMAEN;
            /*
                Slave byte control
             */
            typedef reg_t<0x40005800, 0x00000001, 16, rw_t> SBC;
            /*
                Clock stretching disable
             */
            typedef reg_t<0x40005800, 0x00000001, 17, rw_t> NOSTRETCH;
            /*
                Wakeup from STOP enable
             */
            typedef reg_t<0x40005800, 0x00000001, 18, rw_t> WUPEN;
            /*
                General call enable
             */
            typedef reg_t<0x40005800, 0x00000001, 19, rw_t> GCEN;
            /*
                SMBus Host address enable
             */
            typedef reg_t<0x40005800, 0x00000001, 20, rw_t> SMBHEN;
            /*
                SMBus Device Default address
              enable
             */
            typedef reg_t<0x40005800, 0x00000001, 21, rw_t> SMBDEN;
            /*
                SMBUS alert enable
             */
            typedef reg_t<0x40005800, 0x00000001, 22, rw_t> ALERTEN;
            /*
                PEC enable
             */
            typedef reg_t<0x40005800, 0x00000001, 23, rw_t> PECEN;
        };
        /*
            Control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005804, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                Packet error checking byte
             */
            typedef reg_t<0x40005804, 0x00000001, 26, rw_t> PECBYTE;
            /*
                Automatic end mode (master
              mode)
             */
            typedef reg_t<0x40005804, 0x00000001, 25, rw_t> AUTOEND;
            /*
                NBYTES reload mode
             */
            typedef reg_t<0x40005804, 0x00000001, 24, rw_t> RELOAD;
            /*
                Number of bytes
             */
            typedef reg_t<0x40005804, 0x000000ff, 16, rw_t> NBYTES;
            /*
                NACK generation (slave
              mode)
             */
            typedef reg_t<0x40005804, 0x00000001, 15, rw_t> NACK;
            /*
                Stop generation (master
              mode)
             */
            typedef reg_t<0x40005804, 0x00000001, 14, rw_t> STOP;
            /*
                Start generation
             */
            typedef reg_t<0x40005804, 0x00000001, 13, rw_t> START;
            /*
                10-bit address header only read
              direction (master receiver mode)
             */
            typedef reg_t<0x40005804, 0x00000001, 12, rw_t> HEAD10R;
            /*
                10-bit addressing mode (master
              mode)
             */
            typedef reg_t<0x40005804, 0x00000001, 11, rw_t> ADD10;
            /*
                Transfer direction (master
              mode)
             */
            typedef reg_t<0x40005804, 0x00000001, 10, rw_t> RD_WRN;
            /*
                Slave address bit 9:8 (master
              mode)
             */
            typedef reg_t<0x40005804, 0x00000003, 8, rw_t> SADD8;
            /*
                Slave address bit 7:1 (master
              mode)
             */
            typedef reg_t<0x40005804, 0x0000007f, 1, rw_t> SADD1;
            /*
                Slave address bit 0 (master
              mode)
             */
            typedef reg_t<0x40005804, 0x00000001, 0, rw_t> SADD0;
        };
        /*
            Own address register 1
         */
        namespace OAR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005808, 0xffffffff, 0, rw_t> OAR1_REG;
            /*
                Interface address
             */
            typedef reg_t<0x40005808, 0x00000001, 0, rw_t> OA1_0;
            /*
                Interface address
             */
            typedef reg_t<0x40005808, 0x0000007f, 1, rw_t> OA1_1;
            /*
                Interface address
             */
            typedef reg_t<0x40005808, 0x00000003, 8, rw_t> OA1_8;
            /*
                Own Address 1 10-bit mode
             */
            typedef reg_t<0x40005808, 0x00000001, 10, rw_t> OA1MODE;
            /*
                Own Address 1 enable
             */
            typedef reg_t<0x40005808, 0x00000001, 15, rw_t> OA1EN;
        };
        /*
            Own address register 2
         */
        namespace OAR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000580c, 0xffffffff, 0, rw_t> OAR2_REG;
            /*
                Interface address
             */
            typedef reg_t<0x4000580c, 0x0000007f, 1, rw_t> OA2;
            /*
                Own Address 2 masks
             */
            typedef reg_t<0x4000580c, 0x00000007, 8, rw_t> OA2MSK;
            /*
                Own Address 2 enable
             */
            typedef reg_t<0x4000580c, 0x00000001, 15, rw_t> OA2EN;
        };
        /*
            Timing register
         */
        namespace TIMINGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005810, 0xffffffff, 0, rw_t> TIMINGR_REG;
            /*
                SCL low period (master
              mode)
             */
            typedef reg_t<0x40005810, 0x000000ff, 0, rw_t> SCLL;
            /*
                SCL high period (master
              mode)
             */
            typedef reg_t<0x40005810, 0x000000ff, 8, rw_t> SCLH;
            /*
                Data hold time
             */
            typedef reg_t<0x40005810, 0x0000000f, 16, rw_t> SDADEL;
            /*
                Data setup time
             */
            typedef reg_t<0x40005810, 0x0000000f, 20, rw_t> SCLDEL;
            /*
                Timing prescaler
             */
            typedef reg_t<0x40005810, 0x0000000f, 28, rw_t> PRESC;
        };
        /*
            Status register 1
         */
        namespace TIMEOUTR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005814, 0xffffffff, 0, rw_t> TIMEOUTR_REG;
            /*
                Bus timeout A
             */
            typedef reg_t<0x40005814, 0x00000fff, 0, rw_t> TIMEOUTA;
            /*
                Idle clock timeout
              detection
             */
            typedef reg_t<0x40005814, 0x00000001, 12, rw_t> TIDLE;
            /*
                Clock timeout enable
             */
            typedef reg_t<0x40005814, 0x00000001, 15, rw_t> TIMOUTEN;
            /*
                Bus timeout B
             */
            typedef reg_t<0x40005814, 0x00000fff, 16, rw_t> TIMEOUTB;
            /*
                Extended clock timeout
              enable
             */
            typedef reg_t<0x40005814, 0x00000001, 31, rw_t> TEXTEN;
        };
        /*
            Interrupt and Status register
         */
        namespace ISR {

            static constexpr uint32_t RESETVALUE = 0x00000001;
            /*
                Address match code (Slave
              mode)
             */
            typedef reg_t<0x40005818, 0x0000007f, 17, ro_t> ADDCODE;
            /*
                Transfer direction (Slave
              mode)
             */
            typedef reg_t<0x40005818, 0x00000001, 16, ro_t> DIR;
            /*
                Bus busy
             */
            typedef reg_t<0x40005818, 0x00000001, 15, ro_t> BUSY;
            /*
                SMBus alert
             */
            typedef reg_t<0x40005818, 0x00000001, 13, ro_t> ALERT;
            /*
                Timeout or t_low detection
              flag
             */
            typedef reg_t<0x40005818, 0x00000001, 12, ro_t> TIMEOUT;
            /*
                PEC Error in reception
             */
            typedef reg_t<0x40005818, 0x00000001, 11, ro_t> PECERR;
            /*
                Overrun/Underrun (slave
              mode)
             */
            typedef reg_t<0x40005818, 0x00000001, 10, ro_t> OVR;
            /*
                Arbitration lost
             */
            typedef reg_t<0x40005818, 0x00000001, 9, ro_t> ARLO;
            /*
                Bus error
             */
            typedef reg_t<0x40005818, 0x00000001, 8, ro_t> BERR;
            /*
                Transfer Complete Reload
             */
            typedef reg_t<0x40005818, 0x00000001, 7, ro_t> TCR;
            /*
                Transfer Complete (master
              mode)
             */
            typedef reg_t<0x40005818, 0x00000001, 6, ro_t> TC;
            /*
                Stop detection flag
             */
            typedef reg_t<0x40005818, 0x00000001, 5, ro_t> STOPF;
            /*
                Not acknowledge received
              flag
             */
            typedef reg_t<0x40005818, 0x00000001, 4, ro_t> NACKF;
            /*
                Address matched (slave
              mode)
             */
            typedef reg_t<0x40005818, 0x00000001, 3, ro_t> ADDR;
            /*
                Receive data register not empty
              (receivers)
             */
            typedef reg_t<0x40005818, 0x00000001, 2, ro_t> RXNE;
            /*
                Transmit interrupt status
              (transmitters)
             */
            typedef reg_t<0x40005818, 0x00000001, 1, rw_t> TXIS;
            /*
                Transmit data register empty
              (transmitters)
             */
            typedef reg_t<0x40005818, 0x00000001, 0, rw_t> TXE;
        };
        /*
            Interrupt clear register
         */
        namespace ICR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000581c, 0xffffffff, 0, wo_t> ICR_REG;
            /*
                Alert flag clear
             */
            typedef reg_t<0x4000581c, 0x00000001, 13, wo_t> ALERTCF;
            /*
                Timeout detection flag
              clear
             */
            typedef reg_t<0x4000581c, 0x00000001, 12, wo_t> TIMOUTCF;
            /*
                PEC Error flag clear
             */
            typedef reg_t<0x4000581c, 0x00000001, 11, wo_t> PECCF;
            /*
                Overrun/Underrun flag
              clear
             */
            typedef reg_t<0x4000581c, 0x00000001, 10, wo_t> OVRCF;
            /*
                Arbitration lost flag
              clear
             */
            typedef reg_t<0x4000581c, 0x00000001, 9, wo_t> ARLOCF;
            /*
                Bus error flag clear
             */
            typedef reg_t<0x4000581c, 0x00000001, 8, wo_t> BERRCF;
            /*
                Stop detection flag clear
             */
            typedef reg_t<0x4000581c, 0x00000001, 5, wo_t> STOPCF;
            /*
                Not Acknowledge flag clear
             */
            typedef reg_t<0x4000581c, 0x00000001, 4, wo_t> NACKCF;
            /*
                Address Matched flag clear
             */
            typedef reg_t<0x4000581c, 0x00000001, 3, wo_t> ADDRCF;
        };
        /*
            PEC register
         */
        namespace PECR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005820, 0xffffffff, 0, ro_t> PECR_REG;
            /*
                Packet error checking
              register
             */
            typedef reg_t<0x40005820, 0x000000ff, 0, ro_t> PEC;
        };
        /*
            Receive data register
         */
        namespace RXDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005824, 0xffffffff, 0, ro_t> RXDR_REG;
            /*
                8-bit receive data
             */
            typedef reg_t<0x40005824, 0x000000ff, 0, ro_t> RXDATA;
        };
        /*
            Transmit data register
         */
        namespace TXDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40005828, 0xffffffff, 0, rw_t> TXDR_REG;
            /*
                8-bit transmit data
             */
            typedef reg_t<0x40005828, 0x000000ff, 0, rw_t> TXDATA;
        };
    };
    /*
        Inter-integrated circuit
     */
    namespace I2C3 {
        /*
            Control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Peripheral enable
             */
            typedef reg_t<0x40007800, 0x00000001, 0, rw_t> PE;
            /*
                TX Interrupt enable
             */
            typedef reg_t<0x40007800, 0x00000001, 1, rw_t> TXIE;
            /*
                RX Interrupt enable
             */
            typedef reg_t<0x40007800, 0x00000001, 2, rw_t> RXIE;
            /*
                Address match interrupt enable (slave
              only)
             */
            typedef reg_t<0x40007800, 0x00000001, 3, rw_t> ADDRIE;
            /*
                Not acknowledge received interrupt
              enable
             */
            typedef reg_t<0x40007800, 0x00000001, 4, rw_t> NACKIE;
            /*
                STOP detection Interrupt
              enable
             */
            typedef reg_t<0x40007800, 0x00000001, 5, rw_t> STOPIE;
            /*
                Transfer Complete interrupt
              enable
             */
            typedef reg_t<0x40007800, 0x00000001, 6, rw_t> TCIE;
            /*
                Error interrupts enable
             */
            typedef reg_t<0x40007800, 0x00000001, 7, rw_t> ERRIE;
            /*
                Digital noise filter
             */
            typedef reg_t<0x40007800, 0x0000000f, 8, rw_t> DNF;
            /*
                Analog noise filter OFF
             */
            typedef reg_t<0x40007800, 0x00000001, 12, rw_t> ANFOFF;
            /*
                Software reset
             */
            typedef reg_t<0x40007800, 0x00000001, 13, wo_t> SWRST;
            /*
                DMA transmission requests
              enable
             */
            typedef reg_t<0x40007800, 0x00000001, 14, rw_t> TXDMAEN;
            /*
                DMA reception requests
              enable
             */
            typedef reg_t<0x40007800, 0x00000001, 15, rw_t> RXDMAEN;
            /*
                Slave byte control
             */
            typedef reg_t<0x40007800, 0x00000001, 16, rw_t> SBC;
            /*
                Clock stretching disable
             */
            typedef reg_t<0x40007800, 0x00000001, 17, rw_t> NOSTRETCH;
            /*
                Wakeup from STOP enable
             */
            typedef reg_t<0x40007800, 0x00000001, 18, rw_t> WUPEN;
            /*
                General call enable
             */
            typedef reg_t<0x40007800, 0x00000001, 19, rw_t> GCEN;
            /*
                SMBus Host address enable
             */
            typedef reg_t<0x40007800, 0x00000001, 20, rw_t> SMBHEN;
            /*
                SMBus Device Default address
              enable
             */
            typedef reg_t<0x40007800, 0x00000001, 21, rw_t> SMBDEN;
            /*
                SMBUS alert enable
             */
            typedef reg_t<0x40007800, 0x00000001, 22, rw_t> ALERTEN;
            /*
                PEC enable
             */
            typedef reg_t<0x40007800, 0x00000001, 23, rw_t> PECEN;
        };
        /*
            Control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40007804, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                Packet error checking byte
             */
            typedef reg_t<0x40007804, 0x00000001, 26, rw_t> PECBYTE;
            /*
                Automatic end mode (master
              mode)
             */
            typedef reg_t<0x40007804, 0x00000001, 25, rw_t> AUTOEND;
            /*
                NBYTES reload mode
             */
            typedef reg_t<0x40007804, 0x00000001, 24, rw_t> RELOAD;
            /*
                Number of bytes
             */
            typedef reg_t<0x40007804, 0x000000ff, 16, rw_t> NBYTES;
            /*
                NACK generation (slave
              mode)
             */
            typedef reg_t<0x40007804, 0x00000001, 15, rw_t> NACK;
            /*
                Stop generation (master
              mode)
             */
            typedef reg_t<0x40007804, 0x00000001, 14, rw_t> STOP;
            /*
                Start generation
             */
            typedef reg_t<0x40007804, 0x00000001, 13, rw_t> START;
            /*
                10-bit address header only read
              direction (master receiver mode)
             */
            typedef reg_t<0x40007804, 0x00000001, 12, rw_t> HEAD10R;
            /*
                10-bit addressing mode (master
              mode)
             */
            typedef reg_t<0x40007804, 0x00000001, 11, rw_t> ADD10;
            /*
                Transfer direction (master
              mode)
             */
            typedef reg_t<0x40007804, 0x00000001, 10, rw_t> RD_WRN;
            /*
                Slave address bit 9:8 (master
              mode)
             */
            typedef reg_t<0x40007804, 0x00000003, 8, rw_t> SADD8;
            /*
                Slave address bit 7:1 (master
              mode)
             */
            typedef reg_t<0x40007804, 0x0000007f, 1, rw_t> SADD1;
            /*
                Slave address bit 0 (master
              mode)
             */
            typedef reg_t<0x40007804, 0x00000001, 0, rw_t> SADD0;
        };
        /*
            Own address register 1
         */
        namespace OAR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40007808, 0xffffffff, 0, rw_t> OAR1_REG;
            /*
                Interface address
             */
            typedef reg_t<0x40007808, 0x00000001, 0, rw_t> OA1_0;
            /*
                Interface address
             */
            typedef reg_t<0x40007808, 0x0000007f, 1, rw_t> OA1_1;
            /*
                Interface address
             */
            typedef reg_t<0x40007808, 0x00000003, 8, rw_t> OA1_8;
            /*
                Own Address 1 10-bit mode
             */
            typedef reg_t<0x40007808, 0x00000001, 10, rw_t> OA1MODE;
            /*
                Own Address 1 enable
             */
            typedef reg_t<0x40007808, 0x00000001, 15, rw_t> OA1EN;
        };
        /*
            Own address register 2
         */
        namespace OAR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000780c, 0xffffffff, 0, rw_t> OAR2_REG;
            /*
                Interface address
             */
            typedef reg_t<0x4000780c, 0x0000007f, 1, rw_t> OA2;
            /*
                Own Address 2 masks
             */
            typedef reg_t<0x4000780c, 0x00000007, 8, rw_t> OA2MSK;
            /*
                Own Address 2 enable
             */
            typedef reg_t<0x4000780c, 0x00000001, 15, rw_t> OA2EN;
        };
        /*
            Timing register
         */
        namespace TIMINGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40007810, 0xffffffff, 0, rw_t> TIMINGR_REG;
            /*
                SCL low period (master
              mode)
             */
            typedef reg_t<0x40007810, 0x000000ff, 0, rw_t> SCLL;
            /*
                SCL high period (master
              mode)
             */
            typedef reg_t<0x40007810, 0x000000ff, 8, rw_t> SCLH;
            /*
                Data hold time
             */
            typedef reg_t<0x40007810, 0x0000000f, 16, rw_t> SDADEL;
            /*
                Data setup time
             */
            typedef reg_t<0x40007810, 0x0000000f, 20, rw_t> SCLDEL;
            /*
                Timing prescaler
             */
            typedef reg_t<0x40007810, 0x0000000f, 28, rw_t> PRESC;
        };
        /*
            Status register 1
         */
        namespace TIMEOUTR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40007814, 0xffffffff, 0, rw_t> TIMEOUTR_REG;
            /*
                Bus timeout A
             */
            typedef reg_t<0x40007814, 0x00000fff, 0, rw_t> TIMEOUTA;
            /*
                Idle clock timeout
              detection
             */
            typedef reg_t<0x40007814, 0x00000001, 12, rw_t> TIDLE;
            /*
                Clock timeout enable
             */
            typedef reg_t<0x40007814, 0x00000001, 15, rw_t> TIMOUTEN;
            /*
                Bus timeout B
             */
            typedef reg_t<0x40007814, 0x00000fff, 16, rw_t> TIMEOUTB;
            /*
                Extended clock timeout
              enable
             */
            typedef reg_t<0x40007814, 0x00000001, 31, rw_t> TEXTEN;
        };
        /*
            Interrupt and Status register
         */
        namespace ISR {

            static constexpr uint32_t RESETVALUE = 0x00000001;
            /*
                Address match code (Slave
              mode)
             */
            typedef reg_t<0x40007818, 0x0000007f, 17, ro_t> ADDCODE;
            /*
                Transfer direction (Slave
              mode)
             */
            typedef reg_t<0x40007818, 0x00000001, 16, ro_t> DIR;
            /*
                Bus busy
             */
            typedef reg_t<0x40007818, 0x00000001, 15, ro_t> BUSY;
            /*
                SMBus alert
             */
            typedef reg_t<0x40007818, 0x00000001, 13, ro_t> ALERT;
            /*
                Timeout or t_low detection
              flag
             */
            typedef reg_t<0x40007818, 0x00000001, 12, ro_t> TIMEOUT;
            /*
                PEC Error in reception
             */
            typedef reg_t<0x40007818, 0x00000001, 11, ro_t> PECERR;
            /*
                Overrun/Underrun (slave
              mode)
             */
            typedef reg_t<0x40007818, 0x00000001, 10, ro_t> OVR;
            /*
                Arbitration lost
             */
            typedef reg_t<0x40007818, 0x00000001, 9, ro_t> ARLO;
            /*
                Bus error
             */
            typedef reg_t<0x40007818, 0x00000001, 8, ro_t> BERR;
            /*
                Transfer Complete Reload
             */
            typedef reg_t<0x40007818, 0x00000001, 7, ro_t> TCR;
            /*
                Transfer Complete (master
              mode)
             */
            typedef reg_t<0x40007818, 0x00000001, 6, ro_t> TC;
            /*
                Stop detection flag
             */
            typedef reg_t<0x40007818, 0x00000001, 5, ro_t> STOPF;
            /*
                Not acknowledge received
              flag
             */
            typedef reg_t<0x40007818, 0x00000001, 4, ro_t> NACKF;
            /*
                Address matched (slave
              mode)
             */
            typedef reg_t<0x40007818, 0x00000001, 3, ro_t> ADDR;
            /*
                Receive data register not empty
              (receivers)
             */
            typedef reg_t<0x40007818, 0x00000001, 2, ro_t> RXNE;
            /*
                Transmit interrupt status
              (transmitters)
             */
            typedef reg_t<0x40007818, 0x00000001, 1, rw_t> TXIS;
            /*
                Transmit data register empty
              (transmitters)
             */
            typedef reg_t<0x40007818, 0x00000001, 0, rw_t> TXE;
        };
        /*
            Interrupt clear register
         */
        namespace ICR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000781c, 0xffffffff, 0, wo_t> ICR_REG;
            /*
                Alert flag clear
             */
            typedef reg_t<0x4000781c, 0x00000001, 13, wo_t> ALERTCF;
            /*
                Timeout detection flag
              clear
             */
            typedef reg_t<0x4000781c, 0x00000001, 12, wo_t> TIMOUTCF;
            /*
                PEC Error flag clear
             */
            typedef reg_t<0x4000781c, 0x00000001, 11, wo_t> PECCF;
            /*
                Overrun/Underrun flag
              clear
             */
            typedef reg_t<0x4000781c, 0x00000001, 10, wo_t> OVRCF;
            /*
                Arbitration lost flag
              clear
             */
            typedef reg_t<0x4000781c, 0x00000001, 9, wo_t> ARLOCF;
            /*
                Bus error flag clear
             */
            typedef reg_t<0x4000781c, 0x00000001, 8, wo_t> BERRCF;
            /*
                Stop detection flag clear
             */
            typedef reg_t<0x4000781c, 0x00000001, 5, wo_t> STOPCF;
            /*
                Not Acknowledge flag clear
             */
            typedef reg_t<0x4000781c, 0x00000001, 4, wo_t> NACKCF;
            /*
                Address Matched flag clear
             */
            typedef reg_t<0x4000781c, 0x00000001, 3, wo_t> ADDRCF;
        };
        /*
            PEC register
         */
        namespace PECR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40007820, 0xffffffff, 0, ro_t> PECR_REG;
            /*
                Packet error checking
              register
             */
            typedef reg_t<0x40007820, 0x000000ff, 0, ro_t> PEC;
        };
        /*
            Receive data register
         */
        namespace RXDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40007824, 0xffffffff, 0, ro_t> RXDR_REG;
            /*
                8-bit receive data
             */
            typedef reg_t<0x40007824, 0x000000ff, 0, ro_t> RXDATA;
        };
        /*
            Transmit data register
         */
        namespace TXDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40007828, 0xffffffff, 0, rw_t> TXDR_REG;
            /*
                8-bit transmit data
             */
            typedef reg_t<0x40007828, 0x000000ff, 0, rw_t> TXDATA;
        };
    };
    /*
        Independent watchdog
     */
    namespace IWDG {
        /*
            Key register
         */
        namespace KR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40003000, 0xffffffff, 0, wo_t> KR_REG;
            /*
                Key value
             */
            typedef reg_t<0x40003000, 0x0000ffff, 0, wo_t> KEY;
        };
        /*
            Prescaler register
         */
        namespace PR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40003004, 0xffffffff, 0, rw_t> PR_REG;
            /*
                Prescaler divider
             */
            typedef reg_t<0x40003004, 0x00000007, 0, rw_t> PR;
        };
        /*
            Reload register
         */
        namespace RLR {

            static constexpr uint32_t RESETVALUE = 0x00000fff;
            typedef reg_t<0x40003008, 0xffffffff, 0, rw_t> RLR_REG;
            /*
                Watchdog counter reload
              value
             */
            typedef reg_t<0x40003008, 0x00000fff, 0, rw_t> RL;
        };
        /*
            Status register
         */
        namespace SR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000300c, 0xffffffff, 0, ro_t> SR_REG;
            /*
                Watchdog prescaler value
              update
             */
            typedef reg_t<0x4000300c, 0x00000001, 0, ro_t> PVU;
            /*
                Watchdog counter reload value
              update
             */
            typedef reg_t<0x4000300c, 0x00000001, 1, ro_t> RVU;
            /*
                Watchdog counter window value
              update
             */
            typedef reg_t<0x4000300c, 0x00000001, 2, ro_t> WVU;
        };
        /*
            Window register
         */
        namespace WINR {

            static constexpr uint32_t RESETVALUE = 0x00000fff;
            typedef reg_t<0x40003010, 0xffffffff, 0, rw_t> WINR_REG;
            /*
                Watchdog counter window
              value
             */
            typedef reg_t<0x40003010, 0x00000fff, 0, rw_t> WIN;
        };
    };
    /*
        Window watchdog
     */
    namespace WWDG {
        /*
            Control register
         */
        namespace CR {

            static constexpr uint32_t RESETVALUE = 0x0000007f;
            typedef reg_t<0x40002c00, 0xffffffff, 0, rw_t> CR_REG;
            /*
                7-bit counter
             */
            typedef reg_t<0x40002c00, 0x0000007f, 0, rw_t> T;
            /*
                Activation bit
             */
            typedef reg_t<0x40002c00, 0x00000001, 7, rw_t> WDGA;
        };
        /*
            Configuration register
         */
        namespace CFR {

            static constexpr uint32_t RESETVALUE = 0x0000007f;
            typedef reg_t<0x40002c04, 0xffffffff, 0, rw_t> CFR_REG;
            /*
                Early wakeup interrupt
             */
            typedef reg_t<0x40002c04, 0x00000001, 9, rw_t> EWI;
            /*
                Timer base
             */
            typedef reg_t<0x40002c04, 0x00000003, 7, rw_t> WDGTB;
            /*
                7-bit window value
             */
            typedef reg_t<0x40002c04, 0x0000007f, 0, rw_t> W;
        };
        /*
            Status register
         */
        namespace SR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002c08, 0xffffffff, 0, rw_t> SR_REG;
            /*
                Early wakeup interrupt
              flag
             */
            typedef reg_t<0x40002c08, 0x00000001, 0, rw_t> EWIF;
        };
    };
    /*
        Real-time clock
     */
    namespace RTC {
        /*
            time register
         */
        namespace TR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002800, 0xffffffff, 0, rw_t> TR_REG;
            /*
                AM/PM notation
             */
            typedef reg_t<0x40002800, 0x00000001, 22, rw_t> PM;
            /*
                Hour tens in BCD format
             */
            typedef reg_t<0x40002800, 0x00000003, 20, rw_t> HT;
            /*
                Hour units in BCD format
             */
            typedef reg_t<0x40002800, 0x0000000f, 16, rw_t> HU;
            /*
                Minute tens in BCD format
             */
            typedef reg_t<0x40002800, 0x00000007, 12, rw_t> MNT;
            /*
                Minute units in BCD format
             */
            typedef reg_t<0x40002800, 0x0000000f, 8, rw_t> MNU;
            /*
                Second tens in BCD format
             */
            typedef reg_t<0x40002800, 0x00000007, 4, rw_t> ST;
            /*
                Second units in BCD format
             */
            typedef reg_t<0x40002800, 0x0000000f, 0, rw_t> SU;
        };
        /*
            date register
         */
        namespace DR {

            static constexpr uint32_t RESETVALUE = 0x00002101;
            typedef reg_t<0x40002804, 0xffffffff, 0, rw_t> DR_REG;
            /*
                Year tens in BCD format
             */
            typedef reg_t<0x40002804, 0x0000000f, 20, rw_t> YT;
            /*
                Year units in BCD format
             */
            typedef reg_t<0x40002804, 0x0000000f, 16, rw_t> YU;
            /*
                Week day units
             */
            typedef reg_t<0x40002804, 0x00000007, 13, rw_t> WDU;
            /*
                Month tens in BCD format
             */
            typedef reg_t<0x40002804, 0x00000001, 12, rw_t> MT;
            /*
                Month units in BCD format
             */
            typedef reg_t<0x40002804, 0x0000000f, 8, rw_t> MU;
            /*
                Date tens in BCD format
             */
            typedef reg_t<0x40002804, 0x00000003, 4, rw_t> DT;
            /*
                Date units in BCD format
             */
            typedef reg_t<0x40002804, 0x0000000f, 0, rw_t> DU;
        };
        /*
            control register
         */
        namespace CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002808, 0xffffffff, 0, rw_t> CR_REG;
            /*
                Wakeup clock selection
             */
            typedef reg_t<0x40002808, 0x00000007, 0, rw_t> WCKSEL;
            /*
                Time-stamp event active
              edge
             */
            typedef reg_t<0x40002808, 0x00000001, 3, rw_t> TSEDGE;
            /*
                Reference clock detection enable (50 or
              60 Hz)
             */
            typedef reg_t<0x40002808, 0x00000001, 4, rw_t> REFCKON;
            /*
                Bypass the shadow
              registers
             */
            typedef reg_t<0x40002808, 0x00000001, 5, rw_t> BYPSHAD;
            /*
                Hour format
             */
            typedef reg_t<0x40002808, 0x00000001, 6, rw_t> FMT;
            /*
                Alarm A enable
             */
            typedef reg_t<0x40002808, 0x00000001, 8, rw_t> ALRAE;
            /*
                Alarm B enable
             */
            typedef reg_t<0x40002808, 0x00000001, 9, rw_t> ALRBE;
            /*
                Wakeup timer enable
             */
            typedef reg_t<0x40002808, 0x00000001, 10, rw_t> WUTE;
            /*
                Time stamp enable
             */
            typedef reg_t<0x40002808, 0x00000001, 11, rw_t> TSE;
            /*
                Alarm A interrupt enable
             */
            typedef reg_t<0x40002808, 0x00000001, 12, rw_t> ALRAIE;
            /*
                Alarm B interrupt enable
             */
            typedef reg_t<0x40002808, 0x00000001, 13, rw_t> ALRBIE;
            /*
                Wakeup timer interrupt
              enable
             */
            typedef reg_t<0x40002808, 0x00000001, 14, rw_t> WUTIE;
            /*
                Time-stamp interrupt
              enable
             */
            typedef reg_t<0x40002808, 0x00000001, 15, rw_t> TSIE;
            /*
                Add 1 hour (summer time
              change)
             */
            typedef reg_t<0x40002808, 0x00000001, 16, rw_t> ADD1H;
            /*
                Subtract 1 hour (winter time
              change)
             */
            typedef reg_t<0x40002808, 0x00000001, 17, rw_t> SUB1H;
            /*
                Backup
             */
            typedef reg_t<0x40002808, 0x00000001, 18, rw_t> BKP;
            /*
                Calibration output
              selection
             */
            typedef reg_t<0x40002808, 0x00000001, 19, rw_t> COSEL;
            /*
                Output polarity
             */
            typedef reg_t<0x40002808, 0x00000001, 20, rw_t> POL;
            /*
                Output selection
             */
            typedef reg_t<0x40002808, 0x00000003, 21, rw_t> OSEL;
            /*
                Calibration output enable
             */
            typedef reg_t<0x40002808, 0x00000001, 23, rw_t> COE;
        };
        /*
            initialization and status
          register
         */
        namespace ISR {

            static constexpr uint32_t RESETVALUE = 0x00000007;
            /*
                Alarm A write flag
             */
            typedef reg_t<0x4000280c, 0x00000001, 0, ro_t> ALRAWF;
            /*
                Alarm B write flag
             */
            typedef reg_t<0x4000280c, 0x00000001, 1, ro_t> ALRBWF;
            /*
                Wakeup timer write flag
             */
            typedef reg_t<0x4000280c, 0x00000001, 2, ro_t> WUTWF;
            /*
                Shift operation pending
             */
            typedef reg_t<0x4000280c, 0x00000001, 3, rw_t> SHPF;
            /*
                Initialization status flag
             */
            typedef reg_t<0x4000280c, 0x00000001, 4, ro_t> INITS;
            /*
                Registers synchronization
              flag
             */
            typedef reg_t<0x4000280c, 0x00000001, 5, rw_t> RSF;
            /*
                Initialization flag
             */
            typedef reg_t<0x4000280c, 0x00000001, 6, ro_t> INITF;
            /*
                Initialization mode
             */
            typedef reg_t<0x4000280c, 0x00000001, 7, rw_t> INIT;
            /*
                Alarm A flag
             */
            typedef reg_t<0x4000280c, 0x00000001, 8, rw_t> ALRAF;
            /*
                Alarm B flag
             */
            typedef reg_t<0x4000280c, 0x00000001, 9, rw_t> ALRBF;
            /*
                Wakeup timer flag
             */
            typedef reg_t<0x4000280c, 0x00000001, 10, rw_t> WUTF;
            /*
                Time-stamp flag
             */
            typedef reg_t<0x4000280c, 0x00000001, 11, rw_t> TSF;
            /*
                Time-stamp overflow flag
             */
            typedef reg_t<0x4000280c, 0x00000001, 12, rw_t> TSOVF;
            /*
                Tamper detection flag
             */
            typedef reg_t<0x4000280c, 0x00000001, 13, rw_t> TAMP1F;
            /*
                RTC_TAMP2 detection flag
             */
            typedef reg_t<0x4000280c, 0x00000001, 14, rw_t> TAMP2F;
            /*
                RTC_TAMP3 detection flag
             */
            typedef reg_t<0x4000280c, 0x00000001, 15, rw_t> TAMP3F;
            /*
                Recalibration pending Flag
             */
            typedef reg_t<0x4000280c, 0x00000001, 16, ro_t> RECALPF;
        };
        /*
            prescaler register
         */
        namespace PRER {

            static constexpr uint32_t RESETVALUE = 0x007f00ff;
            typedef reg_t<0x40002810, 0xffffffff, 0, rw_t> PRER_REG;
            /*
                Asynchronous prescaler
              factor
             */
            typedef reg_t<0x40002810, 0x0000007f, 16, rw_t> PREDIV_A;
            /*
                Synchronous prescaler
              factor
             */
            typedef reg_t<0x40002810, 0x00007fff, 0, rw_t> PREDIV_S;
        };
        /*
            wakeup timer register
         */
        namespace WUTR {

            static constexpr uint32_t RESETVALUE = 0x0000ffff;
            typedef reg_t<0x40002814, 0xffffffff, 0, rw_t> WUTR_REG;
            /*
                Wakeup auto-reload value
              bits
             */
            typedef reg_t<0x40002814, 0x0000ffff, 0, rw_t> WUT;
        };
        /*
            alarm A register
         */
        namespace ALRMAR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000281c, 0xffffffff, 0, rw_t> ALRMAR_REG;
            /*
                Alarm A date mask
             */
            typedef reg_t<0x4000281c, 0x00000001, 31, rw_t> MSK4;
            /*
                Week day selection
             */
            typedef reg_t<0x4000281c, 0x00000001, 30, rw_t> WDSEL;
            /*
                Date tens in BCD format
             */
            typedef reg_t<0x4000281c, 0x00000003, 28, rw_t> DT;
            /*
                Date units or day in BCD
              format
             */
            typedef reg_t<0x4000281c, 0x0000000f, 24, rw_t> DU;
            /*
                Alarm A hours mask
             */
            typedef reg_t<0x4000281c, 0x00000001, 23, rw_t> MSK3;
            /*
                AM/PM notation
             */
            typedef reg_t<0x4000281c, 0x00000001, 22, rw_t> PM;
            /*
                Hour tens in BCD format
             */
            typedef reg_t<0x4000281c, 0x00000003, 20, rw_t> HT;
            /*
                Hour units in BCD format
             */
            typedef reg_t<0x4000281c, 0x0000000f, 16, rw_t> HU;
            /*
                Alarm A minutes mask
             */
            typedef reg_t<0x4000281c, 0x00000001, 15, rw_t> MSK2;
            /*
                Minute tens in BCD format
             */
            typedef reg_t<0x4000281c, 0x00000007, 12, rw_t> MNT;
            /*
                Minute units in BCD format
             */
            typedef reg_t<0x4000281c, 0x0000000f, 8, rw_t> MNU;
            /*
                Alarm A seconds mask
             */
            typedef reg_t<0x4000281c, 0x00000001, 7, rw_t> MSK1;
            /*
                Second tens in BCD format
             */
            typedef reg_t<0x4000281c, 0x00000007, 4, rw_t> ST;
            /*
                Second units in BCD format
             */
            typedef reg_t<0x4000281c, 0x0000000f, 0, rw_t> SU;
        };
        /*
            alarm B register
         */
        namespace ALRMBR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002820, 0xffffffff, 0, rw_t> ALRMBR_REG;
            /*
                Alarm B date mask
             */
            typedef reg_t<0x40002820, 0x00000001, 31, rw_t> MSK4;
            /*
                Week day selection
             */
            typedef reg_t<0x40002820, 0x00000001, 30, rw_t> WDSEL;
            /*
                Date tens in BCD format
             */
            typedef reg_t<0x40002820, 0x00000003, 28, rw_t> DT;
            /*
                Date units or day in BCD
              format
             */
            typedef reg_t<0x40002820, 0x0000000f, 24, rw_t> DU;
            /*
                Alarm B hours mask
             */
            typedef reg_t<0x40002820, 0x00000001, 23, rw_t> MSK3;
            /*
                AM/PM notation
             */
            typedef reg_t<0x40002820, 0x00000001, 22, rw_t> PM;
            /*
                Hour tens in BCD format
             */
            typedef reg_t<0x40002820, 0x00000003, 20, rw_t> HT;
            /*
                Hour units in BCD format
             */
            typedef reg_t<0x40002820, 0x0000000f, 16, rw_t> HU;
            /*
                Alarm B minutes mask
             */
            typedef reg_t<0x40002820, 0x00000001, 15, rw_t> MSK2;
            /*
                Minute tens in BCD format
             */
            typedef reg_t<0x40002820, 0x00000007, 12, rw_t> MNT;
            /*
                Minute units in BCD format
             */
            typedef reg_t<0x40002820, 0x0000000f, 8, rw_t> MNU;
            /*
                Alarm B seconds mask
             */
            typedef reg_t<0x40002820, 0x00000001, 7, rw_t> MSK1;
            /*
                Second tens in BCD format
             */
            typedef reg_t<0x40002820, 0x00000007, 4, rw_t> ST;
            /*
                Second units in BCD format
             */
            typedef reg_t<0x40002820, 0x0000000f, 0, rw_t> SU;
        };
        /*
            write protection register
         */
        namespace WPR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002824, 0xffffffff, 0, wo_t> WPR_REG;
            /*
                Write protection key
             */
            typedef reg_t<0x40002824, 0x000000ff, 0, wo_t> KEY;
        };
        /*
            sub second register
         */
        namespace SSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002828, 0xffffffff, 0, ro_t> SSR_REG;
            /*
                Sub second value
             */
            typedef reg_t<0x40002828, 0x0000ffff, 0, ro_t> SS;
        };
        /*
            shift control register
         */
        namespace SHIFTR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000282c, 0xffffffff, 0, wo_t> SHIFTR_REG;
            /*
                Add one second
             */
            typedef reg_t<0x4000282c, 0x00000001, 31, wo_t> ADD1S;
            /*
                Subtract a fraction of a
              second
             */
            typedef reg_t<0x4000282c, 0x00007fff, 0, wo_t> SUBFS;
        };
        /*
            time stamp time register
         */
        namespace TSTR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002830, 0xffffffff, 0, ro_t> TSTR_REG;
            /*
                Second units in BCD format
             */
            typedef reg_t<0x40002830, 0x0000000f, 0, ro_t> SU;
            /*
                Second tens in BCD format
             */
            typedef reg_t<0x40002830, 0x00000007, 4, ro_t> ST;
            /*
                Minute units in BCD format
             */
            typedef reg_t<0x40002830, 0x0000000f, 8, ro_t> MNU;
            /*
                Minute tens in BCD format
             */
            typedef reg_t<0x40002830, 0x00000007, 12, ro_t> MNT;
            /*
                Hour units in BCD format
             */
            typedef reg_t<0x40002830, 0x0000000f, 16, ro_t> HU;
            /*
                Hour tens in BCD format
             */
            typedef reg_t<0x40002830, 0x00000003, 20, ro_t> HT;
            /*
                AM/PM notation
             */
            typedef reg_t<0x40002830, 0x00000001, 22, ro_t> PM;
        };
        /*
            time stamp date register
         */
        namespace TSDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002834, 0xffffffff, 0, ro_t> TSDR_REG;
            /*
                Week day units
             */
            typedef reg_t<0x40002834, 0x00000007, 13, ro_t> WDU;
            /*
                Month tens in BCD format
             */
            typedef reg_t<0x40002834, 0x00000001, 12, ro_t> MT;
            /*
                Month units in BCD format
             */
            typedef reg_t<0x40002834, 0x0000000f, 8, ro_t> MU;
            /*
                Date tens in BCD format
             */
            typedef reg_t<0x40002834, 0x00000003, 4, ro_t> DT;
            /*
                Date units in BCD format
             */
            typedef reg_t<0x40002834, 0x0000000f, 0, ro_t> DU;
        };
        /*
            timestamp sub second register
         */
        namespace TSSSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002838, 0xffffffff, 0, ro_t> TSSSR_REG;
            /*
                Sub second value
             */
            typedef reg_t<0x40002838, 0x0000ffff, 0, ro_t> SS;
        };
        /*
            calibration register
         */
        namespace CALR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000283c, 0xffffffff, 0, rw_t> CALR_REG;
            /*
                Increase frequency of RTC by 488.5
              ppm
             */
            typedef reg_t<0x4000283c, 0x00000001, 15, rw_t> CALP;
            /*
                Use an 8-second calibration cycle
              period
             */
            typedef reg_t<0x4000283c, 0x00000001, 14, rw_t> CALW8;
            /*
                Use a 16-second calibration cycle
              period
             */
            typedef reg_t<0x4000283c, 0x00000001, 13, rw_t> CALW16;
            /*
                Calibration minus
             */
            typedef reg_t<0x4000283c, 0x000001ff, 0, rw_t> CALM;
        };
        /*
            tamper and alternate function configuration
          register
         */
        namespace TAFCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002840, 0xffffffff, 0, rw_t> TAFCR_REG;
            /*
                Tamper 1 detection enable
             */
            typedef reg_t<0x40002840, 0x00000001, 0, rw_t> TAMP1E;
            /*
                Active level for tamper 1
             */
            typedef reg_t<0x40002840, 0x00000001, 1, rw_t> TAMP1TRG;
            /*
                Tamper interrupt enable
             */
            typedef reg_t<0x40002840, 0x00000001, 2, rw_t> TAMPIE;
            /*
                Tamper 2 detection enable
             */
            typedef reg_t<0x40002840, 0x00000001, 3, rw_t> TAMP2E;
            /*
                Active level for tamper 2
             */
            typedef reg_t<0x40002840, 0x00000001, 4, rw_t> TAMP2TRG;
            /*
                Tamper 3 detection enable
             */
            typedef reg_t<0x40002840, 0x00000001, 5, rw_t> TAMP3E;
            /*
                Active level for tamper 3
             */
            typedef reg_t<0x40002840, 0x00000001, 6, rw_t> TAMP3TRG;
            /*
                Activate timestamp on tamper detection
              event
             */
            typedef reg_t<0x40002840, 0x00000001, 7, rw_t> TAMPTS;
            /*
                Tamper sampling frequency
             */
            typedef reg_t<0x40002840, 0x00000007, 8, rw_t> TAMPFREQ;
            /*
                Tamper filter count
             */
            typedef reg_t<0x40002840, 0x00000003, 11, rw_t> TAMPFLT;
            /*
                Tamper precharge duration
             */
            typedef reg_t<0x40002840, 0x00000003, 13, rw_t> TAMPPRCH;
            /*
                TAMPER pull-up disable
             */
            typedef reg_t<0x40002840, 0x00000001, 15, rw_t> TAMPPUDIS;
            /*
                PC13 value
             */
            typedef reg_t<0x40002840, 0x00000001, 18, rw_t> PC13VALUE;
            /*
                PC13 mode
             */
            typedef reg_t<0x40002840, 0x00000001, 19, rw_t> PC13MODE;
            /*
                PC14 value
             */
            typedef reg_t<0x40002840, 0x00000001, 20, rw_t> PC14VALUE;
            /*
                PC 14 mode
             */
            typedef reg_t<0x40002840, 0x00000001, 21, rw_t> PC14MODE;
            /*
                PC15 value
             */
            typedef reg_t<0x40002840, 0x00000001, 22, rw_t> PC15VALUE;
            /*
                PC15 mode
             */
            typedef reg_t<0x40002840, 0x00000001, 23, rw_t> PC15MODE;
        };
        /*
            alarm A sub second register
         */
        namespace ALRMASSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002844, 0xffffffff, 0, rw_t> ALRMASSR_REG;
            /*
                Mask the most-significant bits starting
              at this bit
             */
            typedef reg_t<0x40002844, 0x0000000f, 24, rw_t> MASKSS;
            /*
                Sub seconds value
             */
            typedef reg_t<0x40002844, 0x00007fff, 0, rw_t> SS;
        };
        /*
            alarm B sub second register
         */
        namespace ALRMBSSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002848, 0xffffffff, 0, rw_t> ALRMBSSR_REG;
            /*
                Mask the most-significant bits starting
              at this bit
             */
            typedef reg_t<0x40002848, 0x0000000f, 24, rw_t> MASKSS;
            /*
                Sub seconds value
             */
            typedef reg_t<0x40002848, 0x00007fff, 0, rw_t> SS;
        };
        /*
            backup register
         */
        namespace BKP0R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002850, 0xffffffff, 0, rw_t> BKP0R_REG;
            /*
                BKP
             */
            typedef reg_t<0x40002850, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP1R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002854, 0xffffffff, 0, rw_t> BKP1R_REG;
            /*
                BKP
             */
            typedef reg_t<0x40002854, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP2R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002858, 0xffffffff, 0, rw_t> BKP2R_REG;
            /*
                BKP
             */
            typedef reg_t<0x40002858, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP3R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000285c, 0xffffffff, 0, rw_t> BKP3R_REG;
            /*
                BKP
             */
            typedef reg_t<0x4000285c, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP4R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002860, 0xffffffff, 0, rw_t> BKP4R_REG;
            /*
                BKP
             */
            typedef reg_t<0x40002860, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP5R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002864, 0xffffffff, 0, rw_t> BKP5R_REG;
            /*
                BKP
             */
            typedef reg_t<0x40002864, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP6R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002868, 0xffffffff, 0, rw_t> BKP6R_REG;
            /*
                BKP
             */
            typedef reg_t<0x40002868, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP7R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000286c, 0xffffffff, 0, rw_t> BKP7R_REG;
            /*
                BKP
             */
            typedef reg_t<0x4000286c, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP8R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002870, 0xffffffff, 0, rw_t> BKP8R_REG;
            /*
                BKP
             */
            typedef reg_t<0x40002870, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP9R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002874, 0xffffffff, 0, rw_t> BKP9R_REG;
            /*
                BKP
             */
            typedef reg_t<0x40002874, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP10R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002878, 0xffffffff, 0, rw_t> BKP10R_REG;
            /*
                BKP
             */
            typedef reg_t<0x40002878, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP11R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000287c, 0xffffffff, 0, rw_t> BKP11R_REG;
            /*
                BKP
             */
            typedef reg_t<0x4000287c, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP12R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002880, 0xffffffff, 0, rw_t> BKP12R_REG;
            /*
                BKP
             */
            typedef reg_t<0x40002880, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP13R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002884, 0xffffffff, 0, rw_t> BKP13R_REG;
            /*
                BKP
             */
            typedef reg_t<0x40002884, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP14R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002888, 0xffffffff, 0, rw_t> BKP14R_REG;
            /*
                BKP
             */
            typedef reg_t<0x40002888, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP15R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000288c, 0xffffffff, 0, rw_t> BKP15R_REG;
            /*
                BKP
             */
            typedef reg_t<0x4000288c, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP16R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002890, 0xffffffff, 0, rw_t> BKP16R_REG;
            /*
                BKP
             */
            typedef reg_t<0x40002890, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP17R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002894, 0xffffffff, 0, rw_t> BKP17R_REG;
            /*
                BKP
             */
            typedef reg_t<0x40002894, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP18R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40002898, 0xffffffff, 0, rw_t> BKP18R_REG;
            /*
                BKP
             */
            typedef reg_t<0x40002898, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP19R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000289c, 0xffffffff, 0, rw_t> BKP19R_REG;
            /*
                BKP
             */
            typedef reg_t<0x4000289c, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP20R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400028a0, 0xffffffff, 0, rw_t> BKP20R_REG;
            /*
                BKP
             */
            typedef reg_t<0x400028a0, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP21R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400028a4, 0xffffffff, 0, rw_t> BKP21R_REG;
            /*
                BKP
             */
            typedef reg_t<0x400028a4, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP22R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400028a8, 0xffffffff, 0, rw_t> BKP22R_REG;
            /*
                BKP
             */
            typedef reg_t<0x400028a8, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP23R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400028ac, 0xffffffff, 0, rw_t> BKP23R_REG;
            /*
                BKP
             */
            typedef reg_t<0x400028ac, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP24R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400028b0, 0xffffffff, 0, rw_t> BKP24R_REG;
            /*
                BKP
             */
            typedef reg_t<0x400028b0, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP25R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400028b4, 0xffffffff, 0, rw_t> BKP25R_REG;
            /*
                BKP
             */
            typedef reg_t<0x400028b4, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP26R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400028b8, 0xffffffff, 0, rw_t> BKP26R_REG;
            /*
                BKP
             */
            typedef reg_t<0x400028b8, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP27R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400028bc, 0xffffffff, 0, rw_t> BKP27R_REG;
            /*
                BKP
             */
            typedef reg_t<0x400028bc, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP28R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400028c0, 0xffffffff, 0, rw_t> BKP28R_REG;
            /*
                BKP
             */
            typedef reg_t<0x400028c0, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP29R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400028c4, 0xffffffff, 0, rw_t> BKP29R_REG;
            /*
                BKP
             */
            typedef reg_t<0x400028c4, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP30R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400028c8, 0xffffffff, 0, rw_t> BKP30R_REG;
            /*
                BKP
             */
            typedef reg_t<0x400028c8, 0xffffffff, 0, rw_t> BKP;
        };
        /*
            backup register
         */
        namespace BKP31R {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x400028cc, 0xffffffff, 0, rw_t> BKP31R_REG;
            /*
                BKP
             */
            typedef reg_t<0x400028cc, 0xffffffff, 0, rw_t> BKP;
        };
    };
    /*
        Basic timers
     */
    namespace TIM6 {
        /*
            control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40001000, 0xffffffff, 0, rw_t> CR1_REG;
            /*
                Counter enable
             */
            typedef reg_t<0x40001000, 0x00000001, 0, rw_t> CEN;
            /*
                Update disable
             */
            typedef reg_t<0x40001000, 0x00000001, 1, rw_t> UDIS;
            /*
                Update request source
             */
            typedef reg_t<0x40001000, 0x00000001, 2, rw_t> URS;
            /*
                One-pulse mode
             */
            typedef reg_t<0x40001000, 0x00000001, 3, rw_t> OPM;
            /*
                Auto-reload preload enable
             */
            typedef reg_t<0x40001000, 0x00000001, 7, rw_t> ARPE;
            /*
                UIF status bit remapping
             */
            typedef reg_t<0x40001000, 0x00000001, 11, rw_t> UIFREMAP;
        };
        /*
            control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40001004, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                Master mode selection
             */
            typedef reg_t<0x40001004, 0x00000007, 4, rw_t> MMS;
        };
        /*
            DMA/Interrupt enable register
         */
        namespace DIER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000100c, 0xffffffff, 0, rw_t> DIER_REG;
            /*
                Update DMA request enable
             */
            typedef reg_t<0x4000100c, 0x00000001, 8, rw_t> UDE;
            /*
                Update interrupt enable
             */
            typedef reg_t<0x4000100c, 0x00000001, 0, rw_t> UIE;
        };
        /*
            status register
         */
        namespace SR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40001010, 0xffffffff, 0, rw_t> SR_REG;
            /*
                Update interrupt flag
             */
            typedef reg_t<0x40001010, 0x00000001, 0, rw_t> UIF;
        };
        /*
            event generation register
         */
        namespace EGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40001014, 0xffffffff, 0, wo_t> EGR_REG;
            /*
                Update generation
             */
            typedef reg_t<0x40001014, 0x00000001, 0, wo_t> UG;
        };
        /*
            counter
         */
        namespace CNT {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Low counter value
             */
            typedef reg_t<0x40001024, 0x0000ffff, 0, rw_t> CNT;
            /*
                UIF Copy
             */
            typedef reg_t<0x40001024, 0x00000001, 31, ro_t> UIFCPY;
        };
        /*
            prescaler
         */
        namespace PSC {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40001028, 0xffffffff, 0, rw_t> PSC_REG;
            /*
                Prescaler value
             */
            typedef reg_t<0x40001028, 0x0000ffff, 0, rw_t> PSC;
        };
        /*
            auto-reload register
         */
        namespace ARR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000102c, 0xffffffff, 0, rw_t> ARR_REG;
            /*
                Low Auto-reload value
             */
            typedef reg_t<0x4000102c, 0x0000ffff, 0, rw_t> ARR;
        };
    };
    /*
        Basic timers
     */
    namespace TIM7 {
        /*
            control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40001400, 0xffffffff, 0, rw_t> CR1_REG;
            /*
                Counter enable
             */
            typedef reg_t<0x40001400, 0x00000001, 0, rw_t> CEN;
            /*
                Update disable
             */
            typedef reg_t<0x40001400, 0x00000001, 1, rw_t> UDIS;
            /*
                Update request source
             */
            typedef reg_t<0x40001400, 0x00000001, 2, rw_t> URS;
            /*
                One-pulse mode
             */
            typedef reg_t<0x40001400, 0x00000001, 3, rw_t> OPM;
            /*
                Auto-reload preload enable
             */
            typedef reg_t<0x40001400, 0x00000001, 7, rw_t> ARPE;
            /*
                UIF status bit remapping
             */
            typedef reg_t<0x40001400, 0x00000001, 11, rw_t> UIFREMAP;
        };
        /*
            control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40001404, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                Master mode selection
             */
            typedef reg_t<0x40001404, 0x00000007, 4, rw_t> MMS;
        };
        /*
            DMA/Interrupt enable register
         */
        namespace DIER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000140c, 0xffffffff, 0, rw_t> DIER_REG;
            /*
                Update DMA request enable
             */
            typedef reg_t<0x4000140c, 0x00000001, 8, rw_t> UDE;
            /*
                Update interrupt enable
             */
            typedef reg_t<0x4000140c, 0x00000001, 0, rw_t> UIE;
        };
        /*
            status register
         */
        namespace SR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40001410, 0xffffffff, 0, rw_t> SR_REG;
            /*
                Update interrupt flag
             */
            typedef reg_t<0x40001410, 0x00000001, 0, rw_t> UIF;
        };
        /*
            event generation register
         */
        namespace EGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40001414, 0xffffffff, 0, wo_t> EGR_REG;
            /*
                Update generation
             */
            typedef reg_t<0x40001414, 0x00000001, 0, wo_t> UG;
        };
        /*
            counter
         */
        namespace CNT {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Low counter value
             */
            typedef reg_t<0x40001424, 0x0000ffff, 0, rw_t> CNT;
            /*
                UIF Copy
             */
            typedef reg_t<0x40001424, 0x00000001, 31, ro_t> UIFCPY;
        };
        /*
            prescaler
         */
        namespace PSC {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40001428, 0xffffffff, 0, rw_t> PSC_REG;
            /*
                Prescaler value
             */
            typedef reg_t<0x40001428, 0x0000ffff, 0, rw_t> PSC;
        };
        /*
            auto-reload register
         */
        namespace ARR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000142c, 0xffffffff, 0, rw_t> ARR_REG;
            /*
                Low Auto-reload value
             */
            typedef reg_t<0x4000142c, 0x0000ffff, 0, rw_t> ARR;
        };
    };
    /*
        Digital-to-analog converter
     */
    namespace DAC {
        /*
            control register
         */
        namespace CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40007400, 0xffffffff, 0, rw_t> CR_REG;
            /*
                DAC channel2 DMA underrun interrupt
              enable
             */
            typedef reg_t<0x40007400, 0x00000001, 29, rw_t> DMAUDRIE2;
            /*
                DAC channel2 DMA enable
             */
            typedef reg_t<0x40007400, 0x00000001, 28, rw_t> DMAEN2;
            /*
                DAC channel2 mask/amplitude
              selector
             */
            typedef reg_t<0x40007400, 0x0000000f, 24, rw_t> MAMP2;
            /*
                DAC channel2 noise/triangle wave
              generation enable
             */
            typedef reg_t<0x40007400, 0x00000003, 22, rw_t> WAVE2;
            /*
                DAC channel2 trigger
              selection
             */
            typedef reg_t<0x40007400, 0x00000007, 19, rw_t> TSEL2;
            /*
                DAC channel2 trigger
              enable
             */
            typedef reg_t<0x40007400, 0x00000001, 18, rw_t> TEN2;
            /*
                DAC channel2 output buffer
              disable
             */
            typedef reg_t<0x40007400, 0x00000001, 17, rw_t> BOFF2;
            /*
                DAC channel2 enable
             */
            typedef reg_t<0x40007400, 0x00000001, 16, rw_t> EN2;
            /*
                DAC channel1 DMA Underrun Interrupt
              enable
             */
            typedef reg_t<0x40007400, 0x00000001, 13, rw_t> DMAUDRIE1;
            /*
                DAC channel1 DMA enable
             */
            typedef reg_t<0x40007400, 0x00000001, 12, rw_t> DMAEN1;
            /*
                DAC channel1 mask/amplitude
              selector
             */
            typedef reg_t<0x40007400, 0x0000000f, 8, rw_t> MAMP1;
            /*
                DAC channel1 noise/triangle wave
              generation enable
             */
            typedef reg_t<0x40007400, 0x00000003, 6, rw_t> WAVE1;
            /*
                DAC channel1 trigger
              selection
             */
            typedef reg_t<0x40007400, 0x00000007, 3, rw_t> TSEL1;
            /*
                DAC channel1 trigger
              enable
             */
            typedef reg_t<0x40007400, 0x00000001, 2, rw_t> TEN1;
            /*
                DAC channel1 output buffer
              disable
             */
            typedef reg_t<0x40007400, 0x00000001, 1, rw_t> BOFF1;
            /*
                DAC channel1 enable
             */
            typedef reg_t<0x40007400, 0x00000001, 0, rw_t> EN1;
        };
        /*
            software trigger register
         */
        namespace SWTRIGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40007404, 0xffffffff, 0, wo_t> SWTRIGR_REG;
            /*
                DAC channel2 software
              trigger
             */
            typedef reg_t<0x40007404, 0x00000001, 1, wo_t> SWTRIG2;
            /*
                DAC channel1 software
              trigger
             */
            typedef reg_t<0x40007404, 0x00000001, 0, wo_t> SWTRIG1;
        };
        /*
            channel1 12-bit right-aligned data holding
          register
         */
        namespace DHR12R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40007408, 0xffffffff, 0, rw_t> DHR12R1_REG;
            /*
                DAC channel1 12-bit right-aligned
              data
             */
            typedef reg_t<0x40007408, 0x00000fff, 0, rw_t> DACC1DHR;
        };
        /*
            channel1 12-bit left aligned data holding
          register
         */
        namespace DHR12L1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000740c, 0xffffffff, 0, rw_t> DHR12L1_REG;
            /*
                DAC channel1 12-bit left-aligned
              data
             */
            typedef reg_t<0x4000740c, 0x00000fff, 4, rw_t> DACC1DHR;
        };
        /*
            channel1 8-bit right aligned data holding
          register
         */
        namespace DHR8R1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40007410, 0xffffffff, 0, rw_t> DHR8R1_REG;
            /*
                DAC channel1 8-bit right-aligned
              data
             */
            typedef reg_t<0x40007410, 0x000000ff, 0, rw_t> DACC1DHR;
        };
        /*
            channel2 12-bit right aligned data holding
          register
         */
        namespace DHR12R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40007414, 0xffffffff, 0, rw_t> DHR12R2_REG;
            /*
                DAC channel2 12-bit right-aligned
              data
             */
            typedef reg_t<0x40007414, 0x00000fff, 0, rw_t> DACC2DHR;
        };
        /*
            channel2 12-bit left aligned data holding
          register
         */
        namespace DHR12L2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40007418, 0xffffffff, 0, rw_t> DHR12L2_REG;
            /*
                DAC channel2 12-bit left-aligned
              data
             */
            typedef reg_t<0x40007418, 0x00000fff, 4, rw_t> DACC2DHR;
        };
        /*
            channel2 8-bit right-aligned data holding
          register
         */
        namespace DHR8R2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000741c, 0xffffffff, 0, rw_t> DHR8R2_REG;
            /*
                DAC channel2 8-bit right-aligned
              data
             */
            typedef reg_t<0x4000741c, 0x000000ff, 0, rw_t> DACC2DHR;
        };
        /*
            Dual DAC 12-bit right-aligned data holding
          register
         */
        namespace DHR12RD {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40007420, 0xffffffff, 0, rw_t> DHR12RD_REG;
            /*
                DAC channel2 12-bit right-aligned
              data
             */
            typedef reg_t<0x40007420, 0x00000fff, 16, rw_t> DACC2DHR;
            /*
                DAC channel1 12-bit right-aligned
              data
             */
            typedef reg_t<0x40007420, 0x00000fff, 0, rw_t> DACC1DHR;
        };
        /*
            DUAL DAC 12-bit left aligned data holding
          register
         */
        namespace DHR12LD {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40007424, 0xffffffff, 0, rw_t> DHR12LD_REG;
            /*
                DAC channel2 12-bit left-aligned
              data
             */
            typedef reg_t<0x40007424, 0x00000fff, 20, rw_t> DACC2DHR;
            /*
                DAC channel1 12-bit left-aligned
              data
             */
            typedef reg_t<0x40007424, 0x00000fff, 4, rw_t> DACC1DHR;
        };
        /*
            DUAL DAC 8-bit right aligned data holding
          register
         */
        namespace DHR8RD {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40007428, 0xffffffff, 0, rw_t> DHR8RD_REG;
            /*
                DAC channel2 8-bit right-aligned
              data
             */
            typedef reg_t<0x40007428, 0x000000ff, 8, rw_t> DACC2DHR;
            /*
                DAC channel1 8-bit right-aligned
              data
             */
            typedef reg_t<0x40007428, 0x000000ff, 0, rw_t> DACC1DHR;
        };
        /*
            channel1 data output register
         */
        namespace DOR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4000742c, 0xffffffff, 0, ro_t> DOR1_REG;
            /*
                DAC channel1 data output
             */
            typedef reg_t<0x4000742c, 0x00000fff, 0, ro_t> DACC1DOR;
        };
        /*
            channel2 data output register
         */
        namespace DOR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40007430, 0xffffffff, 0, ro_t> DOR2_REG;
            /*
                DAC channel2 data output
             */
            typedef reg_t<0x40007430, 0x00000fff, 0, ro_t> DACC2DOR;
        };
        /*
            status register
         */
        namespace SR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40007434, 0xffffffff, 0, rw_t> SR_REG;
            /*
                DAC channel2 DMA underrun
              flag
             */
            typedef reg_t<0x40007434, 0x00000001, 29, rw_t> DMAUDR2;
            /*
                DAC channel1 DMA underrun
              flag
             */
            typedef reg_t<0x40007434, 0x00000001, 13, rw_t> DMAUDR1;
        };
    };
    /*
        Debug support
     */
    namespace DBGMCU {
        /*
            MCU Device ID Code Register
         */
        namespace IDCODE {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe0042000, 0xffffffff, 0, ro_t> IDCODE_REG;
            /*
                Device Identifier
             */
            typedef reg_t<0xe0042000, 0x00000fff, 0, ro_t> DEV_ID;
            /*
                Revision Identifier
             */
            typedef reg_t<0xe0042000, 0x0000ffff, 16, ro_t> REV_ID;
        };
        /*
            Debug MCU Configuration
          Register
         */
        namespace CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe0042004, 0xffffffff, 0, rw_t> CR_REG;
            /*
                Debug Sleep mode
             */
            typedef reg_t<0xe0042004, 0x00000001, 0, rw_t> DBG_SLEEP;
            /*
                Debug Stop Mode
             */
            typedef reg_t<0xe0042004, 0x00000001, 1, rw_t> DBG_STOP;
            /*
                Debug Standby Mode
             */
            typedef reg_t<0xe0042004, 0x00000001, 2, rw_t> DBG_STANDBY;
            /*
                Trace pin assignment
              control
             */
            typedef reg_t<0xe0042004, 0x00000001, 5, rw_t> TRACE_IOEN;
            /*
                Trace pin assignment
              control
             */
            typedef reg_t<0xe0042004, 0x00000003, 6, rw_t> TRACE_MODE;
        };
        /*
            APB Low Freeze Register
         */
        namespace APB1FZ {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe0042008, 0xffffffff, 0, rw_t> APB1FZ_REG;
            /*
                Debug Timer 2 stopped when Core is
              halted
             */
            typedef reg_t<0xe0042008, 0x00000001, 0, rw_t> DBG_TIM2_STOP;
            /*
                Debug Timer 3 stopped when Core is
              halted
             */
            typedef reg_t<0xe0042008, 0x00000001, 1, rw_t> DBG_TIM3_STOP;
            /*
                Debug Timer 4 stopped when Core is
              halted
             */
            typedef reg_t<0xe0042008, 0x00000001, 2, rw_t> DBG_TIM4_STOP;
            /*
                Debug Timer 5 stopped when Core is
              halted
             */
            typedef reg_t<0xe0042008, 0x00000001, 3, rw_t> DBG_TIM5_STOP;
            /*
                Debug Timer 6 stopped when Core is
              halted
             */
            typedef reg_t<0xe0042008, 0x00000001, 4, rw_t> DBG_TIM6_STOP;
            /*
                Debug Timer 7 stopped when Core is
              halted
             */
            typedef reg_t<0xe0042008, 0x00000001, 5, rw_t> DBG_TIM7_STOP;
            /*
                Debug Timer 12 stopped when Core is
              halted
             */
            typedef reg_t<0xe0042008, 0x00000001, 6, rw_t> DBG_TIM12_STOP;
            /*
                Debug Timer 13 stopped when Core is
              halted
             */
            typedef reg_t<0xe0042008, 0x00000001, 7, rw_t> DBG_TIM13_STOP;
            /*
                Debug Timer 14 stopped when Core is
              halted
             */
            typedef reg_t<0xe0042008, 0x00000001, 8, rw_t> DBG_TIMER14_STOP;
            /*
                Debug Timer 18 stopped when Core is
              halted
             */
            typedef reg_t<0xe0042008, 0x00000001, 9, rw_t> DBG_TIM18_STOP;
            /*
                Debug RTC stopped when Core is
              halted
             */
            typedef reg_t<0xe0042008, 0x00000001, 10, rw_t> DBG_RTC_STOP;
            /*
                Debug Window Wachdog stopped when Core
              is halted
             */
            typedef reg_t<0xe0042008, 0x00000001, 11, rw_t> DBG_WWDG_STOP;
            /*
                Debug Independent Wachdog stopped when
              Core is halted
             */
            typedef reg_t<0xe0042008, 0x00000001, 12, rw_t> DBG_IWDG_STOP;
            /*
                SMBUS timeout mode stopped when Core is
              halted
             */
            typedef reg_t<0xe0042008, 0x00000001, 21, rw_t> I2C1_SMBUS_TIMEOUT;
            /*
                SMBUS timeout mode stopped when Core is
              halted
             */
            typedef reg_t<0xe0042008, 0x00000001, 22, rw_t> I2C2_SMBUS_TIMEOUT;
            /*
                Debug CAN stopped when core is
              halted
             */
            typedef reg_t<0xe0042008, 0x00000001, 25, rw_t> DBG_CAN_STOP;
        };
        /*
            APB High Freeze Register
         */
        namespace APB2FZ {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe004200c, 0xffffffff, 0, rw_t> APB2FZ_REG;
            /*
                Debug Timer 15 stopped when Core is
              halted
             */
            typedef reg_t<0xe004200c, 0x00000001, 2, rw_t> DBG_TIM15_STOP;
            /*
                Debug Timer 16 stopped when Core is
              halted
             */
            typedef reg_t<0xe004200c, 0x00000001, 3, rw_t> DBG_TIM16_STOP;
            /*
                Debug Timer 17 stopped when Core is
              halted
             */
            typedef reg_t<0xe004200c, 0x00000001, 4, rw_t> DBG_TIM17_STO;
            /*
                Debug Timer 19 stopped when Core is
              halted
             */
            typedef reg_t<0xe004200c, 0x00000001, 5, rw_t> DBG_TIM19_STOP;
        };
    };
    /*
        Advanced timer
     */
    namespace TIM1 {
        /*
            control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c00, 0xffffffff, 0, rw_t> CR1_REG;
            /*
                Counter enable
             */
            typedef reg_t<0x40012c00, 0x00000001, 0, rw_t> CEN;
            /*
                Update disable
             */
            typedef reg_t<0x40012c00, 0x00000001, 1, rw_t> UDIS;
            /*
                Update request source
             */
            typedef reg_t<0x40012c00, 0x00000001, 2, rw_t> URS;
            /*
                One-pulse mode
             */
            typedef reg_t<0x40012c00, 0x00000001, 3, rw_t> OPM;
            /*
                Direction
             */
            typedef reg_t<0x40012c00, 0x00000001, 4, rw_t> DIR;
            /*
                Center-aligned mode
              selection
             */
            typedef reg_t<0x40012c00, 0x00000003, 5, rw_t> CMS;
            /*
                Auto-reload preload enable
             */
            typedef reg_t<0x40012c00, 0x00000001, 7, rw_t> ARPE;
            /*
                Clock division
             */
            typedef reg_t<0x40012c00, 0x00000003, 8, rw_t> CKD;
            /*
                UIF status bit remapping
             */
            typedef reg_t<0x40012c00, 0x00000001, 11, rw_t> UIFREMAP;
        };
        /*
            control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c04, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                Capture/compare preloaded
              control
             */
            typedef reg_t<0x40012c04, 0x00000001, 0, rw_t> CCPC;
            /*
                Capture/compare control update
              selection
             */
            typedef reg_t<0x40012c04, 0x00000001, 2, rw_t> CCUS;
            /*
                Capture/compare DMA
              selection
             */
            typedef reg_t<0x40012c04, 0x00000001, 3, rw_t> CCDS;
            /*
                Master mode selection
             */
            typedef reg_t<0x40012c04, 0x00000007, 4, rw_t> MMS;
            /*
                TI1 selection
             */
            typedef reg_t<0x40012c04, 0x00000001, 7, rw_t> TI1S;
            /*
                Output Idle state 1
             */
            typedef reg_t<0x40012c04, 0x00000001, 8, rw_t> OIS1;
            /*
                Output Idle state 1
             */
            typedef reg_t<0x40012c04, 0x00000001, 9, rw_t> OIS1N;
            /*
                Output Idle state 2
             */
            typedef reg_t<0x40012c04, 0x00000001, 10, rw_t> OIS2;
            /*
                Output Idle state 2
             */
            typedef reg_t<0x40012c04, 0x00000001, 11, rw_t> OIS2N;
            /*
                Output Idle state 3
             */
            typedef reg_t<0x40012c04, 0x00000001, 12, rw_t> OIS3;
            /*
                Output Idle state 3
             */
            typedef reg_t<0x40012c04, 0x00000001, 13, rw_t> OIS3N;
            /*
                Output Idle state 4
             */
            typedef reg_t<0x40012c04, 0x00000001, 14, rw_t> OIS4;
            /*
                Output Idle state 5
             */
            typedef reg_t<0x40012c04, 0x00000001, 16, rw_t> OIS5;
            /*
                Output Idle state 6
             */
            typedef reg_t<0x40012c04, 0x00000001, 18, rw_t> OIS6;
            /*
                Master mode selection 2
             */
            typedef reg_t<0x40012c04, 0x0000000f, 20, rw_t> MMS2;
        };
        /*
            slave mode control register
         */
        namespace SMCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c08, 0xffffffff, 0, rw_t> SMCR_REG;
            /*
                Slave mode selection
             */
            typedef reg_t<0x40012c08, 0x00000007, 0, rw_t> SMS;
            /*
                OCREF clear selection
             */
            typedef reg_t<0x40012c08, 0x00000001, 3, rw_t> OCCS;
            /*
                Trigger selection
             */
            typedef reg_t<0x40012c08, 0x00000007, 4, rw_t> TS;
            /*
                Master/Slave mode
             */
            typedef reg_t<0x40012c08, 0x00000001, 7, rw_t> MSM;
            /*
                External trigger filter
             */
            typedef reg_t<0x40012c08, 0x0000000f, 8, rw_t> ETF;
            /*
                External trigger prescaler
             */
            typedef reg_t<0x40012c08, 0x00000003, 12, rw_t> ETPS;
            /*
                External clock enable
             */
            typedef reg_t<0x40012c08, 0x00000001, 14, rw_t> ECE;
            /*
                External trigger polarity
             */
            typedef reg_t<0x40012c08, 0x00000001, 15, rw_t> ETP;
            /*
                Slave mode selection bit 3
             */
            typedef reg_t<0x40012c08, 0x00000001, 16, rw_t> SMS3;
        };
        /*
            DMA/Interrupt enable register
         */
        namespace DIER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c0c, 0xffffffff, 0, rw_t> DIER_REG;
            /*
                Trigger DMA request enable
             */
            typedef reg_t<0x40012c0c, 0x00000001, 14, rw_t> TDE;
            /*
                COM DMA request enable
             */
            typedef reg_t<0x40012c0c, 0x00000001, 13, rw_t> COMDE;
            /*
                Capture/Compare 4 DMA request
              enable
             */
            typedef reg_t<0x40012c0c, 0x00000001, 12, rw_t> CC4DE;
            /*
                Capture/Compare 3 DMA request
              enable
             */
            typedef reg_t<0x40012c0c, 0x00000001, 11, rw_t> CC3DE;
            /*
                Capture/Compare 2 DMA request
              enable
             */
            typedef reg_t<0x40012c0c, 0x00000001, 10, rw_t> CC2DE;
            /*
                Capture/Compare 1 DMA request
              enable
             */
            typedef reg_t<0x40012c0c, 0x00000001, 9, rw_t> CC1DE;
            /*
                Update DMA request enable
             */
            typedef reg_t<0x40012c0c, 0x00000001, 8, rw_t> UDE;
            /*
                Break interrupt enable
             */
            typedef reg_t<0x40012c0c, 0x00000001, 7, rw_t> BIE;
            /*
                Trigger interrupt enable
             */
            typedef reg_t<0x40012c0c, 0x00000001, 6, rw_t> TIE;
            /*
                COM interrupt enable
             */
            typedef reg_t<0x40012c0c, 0x00000001, 5, rw_t> COMIE;
            /*
                Capture/Compare 4 interrupt
              enable
             */
            typedef reg_t<0x40012c0c, 0x00000001, 4, rw_t> CC4IE;
            /*
                Capture/Compare 3 interrupt
              enable
             */
            typedef reg_t<0x40012c0c, 0x00000001, 3, rw_t> CC3IE;
            /*
                Capture/Compare 2 interrupt
              enable
             */
            typedef reg_t<0x40012c0c, 0x00000001, 2, rw_t> CC2IE;
            /*
                Capture/Compare 1 interrupt
              enable
             */
            typedef reg_t<0x40012c0c, 0x00000001, 1, rw_t> CC1IE;
            /*
                Update interrupt enable
             */
            typedef reg_t<0x40012c0c, 0x00000001, 0, rw_t> UIE;
        };
        /*
            status register
         */
        namespace SR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c10, 0xffffffff, 0, rw_t> SR_REG;
            /*
                Update interrupt flag
             */
            typedef reg_t<0x40012c10, 0x00000001, 0, rw_t> UIF;
            /*
                Capture/compare 1 interrupt
              flag
             */
            typedef reg_t<0x40012c10, 0x00000001, 1, rw_t> CC1IF;
            /*
                Capture/Compare 2 interrupt
              flag
             */
            typedef reg_t<0x40012c10, 0x00000001, 2, rw_t> CC2IF;
            /*
                Capture/Compare 3 interrupt
              flag
             */
            typedef reg_t<0x40012c10, 0x00000001, 3, rw_t> CC3IF;
            /*
                Capture/Compare 4 interrupt
              flag
             */
            typedef reg_t<0x40012c10, 0x00000001, 4, rw_t> CC4IF;
            /*
                COM interrupt flag
             */
            typedef reg_t<0x40012c10, 0x00000001, 5, rw_t> COMIF;
            /*
                Trigger interrupt flag
             */
            typedef reg_t<0x40012c10, 0x00000001, 6, rw_t> TIF;
            /*
                Break interrupt flag
             */
            typedef reg_t<0x40012c10, 0x00000001, 7, rw_t> BIF;
            /*
                Break 2 interrupt flag
             */
            typedef reg_t<0x40012c10, 0x00000001, 8, rw_t> B2IF;
            /*
                Capture/Compare 1 overcapture
              flag
             */
            typedef reg_t<0x40012c10, 0x00000001, 9, rw_t> CC1OF;
            /*
                Capture/compare 2 overcapture
              flag
             */
            typedef reg_t<0x40012c10, 0x00000001, 10, rw_t> CC2OF;
            /*
                Capture/Compare 3 overcapture
              flag
             */
            typedef reg_t<0x40012c10, 0x00000001, 11, rw_t> CC3OF;
            /*
                Capture/Compare 4 overcapture
              flag
             */
            typedef reg_t<0x40012c10, 0x00000001, 12, rw_t> CC4OF;
            /*
                Capture/Compare 5 interrupt
              flag
             */
            typedef reg_t<0x40012c10, 0x00000001, 16, rw_t> C5IF;
            /*
                Capture/Compare 6 interrupt
              flag
             */
            typedef reg_t<0x40012c10, 0x00000001, 17, rw_t> C6IF;
        };
        /*
            event generation register
         */
        namespace EGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c14, 0xffffffff, 0, wo_t> EGR_REG;
            /*
                Update generation
             */
            typedef reg_t<0x40012c14, 0x00000001, 0, wo_t> UG;
            /*
                Capture/compare 1
              generation
             */
            typedef reg_t<0x40012c14, 0x00000001, 1, wo_t> CC1G;
            /*
                Capture/compare 2
              generation
             */
            typedef reg_t<0x40012c14, 0x00000001, 2, wo_t> CC2G;
            /*
                Capture/compare 3
              generation
             */
            typedef reg_t<0x40012c14, 0x00000001, 3, wo_t> CC3G;
            /*
                Capture/compare 4
              generation
             */
            typedef reg_t<0x40012c14, 0x00000001, 4, wo_t> CC4G;
            /*
                Capture/Compare control update
              generation
             */
            typedef reg_t<0x40012c14, 0x00000001, 5, wo_t> COMG;
            /*
                Trigger generation
             */
            typedef reg_t<0x40012c14, 0x00000001, 6, wo_t> TG;
            /*
                Break generation
             */
            typedef reg_t<0x40012c14, 0x00000001, 7, wo_t> BG;
            /*
                Break 2 generation
             */
            typedef reg_t<0x40012c14, 0x00000001, 8, wo_t> B2G;
        };
        /*
            capture/compare mode register (output
          mode)
         */
        namespace CCMR1_Output {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c18, 0xffffffff, 0, rw_t> CCMR1_Output_REG;
            /*
                Output Compare 2 clear
              enable
             */
            typedef reg_t<0x40012c18, 0x00000001, 15, rw_t> OC2CE;
            /*
                Output Compare 2 mode
             */
            typedef reg_t<0x40012c18, 0x00000007, 12, rw_t> OC2M;
            /*
                Output Compare 2 preload
              enable
             */
            typedef reg_t<0x40012c18, 0x00000001, 11, rw_t> OC2PE;
            /*
                Output Compare 2 fast
              enable
             */
            typedef reg_t<0x40012c18, 0x00000001, 10, rw_t> OC2FE;
            /*
                Capture/Compare 2
              selection
             */
            typedef reg_t<0x40012c18, 0x00000003, 8, rw_t> CC2S;
            /*
                Output Compare 1 clear
              enable
             */
            typedef reg_t<0x40012c18, 0x00000001, 7, rw_t> OC1CE;
            /*
                Output Compare 1 mode
             */
            typedef reg_t<0x40012c18, 0x00000007, 4, rw_t> OC1M;
            /*
                Output Compare 1 preload
              enable
             */
            typedef reg_t<0x40012c18, 0x00000001, 3, rw_t> OC1PE;
            /*
                Output Compare 1 fast
              enable
             */
            typedef reg_t<0x40012c18, 0x00000001, 2, rw_t> OC1FE;
            /*
                Capture/Compare 1
              selection
             */
            typedef reg_t<0x40012c18, 0x00000003, 0, rw_t> CC1S;
            /*
                Output Compare 1 mode bit
              3
             */
            typedef reg_t<0x40012c18, 0x00000001, 16, rw_t> OC1M_3;
            /*
                Output Compare 2 mode bit
              3
             */
            typedef reg_t<0x40012c18, 0x00000001, 24, rw_t> OC2M_3;
        };
        /*
            capture/compare mode register 1 (input
          mode)
         */
        namespace CCMR1_Input {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c18, 0xffffffff, 0, rw_t> CCMR1_Input_REG;
            /*
                Input capture 2 filter
             */
            typedef reg_t<0x40012c18, 0x0000000f, 12, rw_t> IC2F;
            /*
                Input capture 2 prescaler
             */
            typedef reg_t<0x40012c18, 0x00000003, 10, rw_t> IC2PCS;
            /*
                Capture/Compare 2
              selection
             */
            typedef reg_t<0x40012c18, 0x00000003, 8, rw_t> CC2S;
            /*
                Input capture 1 filter
             */
            typedef reg_t<0x40012c18, 0x0000000f, 4, rw_t> IC1F;
            /*
                Input capture 1 prescaler
             */
            typedef reg_t<0x40012c18, 0x00000003, 2, rw_t> IC1PCS;
            /*
                Capture/Compare 1
              selection
             */
            typedef reg_t<0x40012c18, 0x00000003, 0, rw_t> CC1S;
        };
        /*
            capture/compare mode register (output
          mode)
         */
        namespace CCMR2_Output {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c1c, 0xffffffff, 0, rw_t> CCMR2_Output_REG;
            /*
                Output compare 4 clear
              enable
             */
            typedef reg_t<0x40012c1c, 0x00000001, 15, rw_t> OC4CE;
            /*
                Output compare 4 mode
             */
            typedef reg_t<0x40012c1c, 0x00000007, 12, rw_t> OC4M;
            /*
                Output compare 4 preload
              enable
             */
            typedef reg_t<0x40012c1c, 0x00000001, 11, rw_t> OC4PE;
            /*
                Output compare 4 fast
              enable
             */
            typedef reg_t<0x40012c1c, 0x00000001, 10, rw_t> OC4FE;
            /*
                Capture/Compare 4
              selection
             */
            typedef reg_t<0x40012c1c, 0x00000003, 8, rw_t> CC4S;
            /*
                Output compare 3 clear
              enable
             */
            typedef reg_t<0x40012c1c, 0x00000001, 7, rw_t> OC3CE;
            /*
                Output compare 3 mode
             */
            typedef reg_t<0x40012c1c, 0x00000007, 4, rw_t> OC3M;
            /*
                Output compare 3 preload
              enable
             */
            typedef reg_t<0x40012c1c, 0x00000001, 3, rw_t> OC3PE;
            /*
                Output compare 3 fast
              enable
             */
            typedef reg_t<0x40012c1c, 0x00000001, 2, rw_t> OC3FE;
            /*
                Capture/Compare 3
              selection
             */
            typedef reg_t<0x40012c1c, 0x00000003, 0, rw_t> CC3S;
            /*
                Output Compare 3 mode bit
              3
             */
            typedef reg_t<0x40012c1c, 0x00000001, 16, rw_t> OC3M_3;
            /*
                Output Compare 4 mode bit
              3
             */
            typedef reg_t<0x40012c1c, 0x00000001, 24, rw_t> OC4M_3;
        };
        /*
            capture/compare mode register 2 (input
          mode)
         */
        namespace CCMR2_Input {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c1c, 0xffffffff, 0, rw_t> CCMR2_Input_REG;
            /*
                Input capture 4 filter
             */
            typedef reg_t<0x40012c1c, 0x0000000f, 12, rw_t> IC4F;
            /*
                Input capture 4 prescaler
             */
            typedef reg_t<0x40012c1c, 0x00000003, 10, rw_t> IC4PSC;
            /*
                Capture/Compare 4
              selection
             */
            typedef reg_t<0x40012c1c, 0x00000003, 8, rw_t> CC4S;
            /*
                Input capture 3 filter
             */
            typedef reg_t<0x40012c1c, 0x0000000f, 4, rw_t> IC3F;
            /*
                Input capture 3 prescaler
             */
            typedef reg_t<0x40012c1c, 0x00000003, 2, rw_t> IC3PSC;
            /*
                Capture/compare 3
              selection
             */
            typedef reg_t<0x40012c1c, 0x00000003, 0, rw_t> CC3S;
        };
        /*
            capture/compare enable
          register
         */
        namespace CCER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c20, 0xffffffff, 0, rw_t> CCER_REG;
            /*
                Capture/Compare 1 output
              enable
             */
            typedef reg_t<0x40012c20, 0x00000001, 0, rw_t> CC1E;
            /*
                Capture/Compare 1 output
              Polarity
             */
            typedef reg_t<0x40012c20, 0x00000001, 1, rw_t> CC1P;
            /*
                Capture/Compare 1 complementary output
              enable
             */
            typedef reg_t<0x40012c20, 0x00000001, 2, rw_t> CC1NE;
            /*
                Capture/Compare 1 output
              Polarity
             */
            typedef reg_t<0x40012c20, 0x00000001, 3, rw_t> CC1NP;
            /*
                Capture/Compare 2 output
              enable
             */
            typedef reg_t<0x40012c20, 0x00000001, 4, rw_t> CC2E;
            /*
                Capture/Compare 2 output
              Polarity
             */
            typedef reg_t<0x40012c20, 0x00000001, 5, rw_t> CC2P;
            /*
                Capture/Compare 2 complementary output
              enable
             */
            typedef reg_t<0x40012c20, 0x00000001, 6, rw_t> CC2NE;
            /*
                Capture/Compare 2 output
              Polarity
             */
            typedef reg_t<0x40012c20, 0x00000001, 7, rw_t> CC2NP;
            /*
                Capture/Compare 3 output
              enable
             */
            typedef reg_t<0x40012c20, 0x00000001, 8, rw_t> CC3E;
            /*
                Capture/Compare 3 output
              Polarity
             */
            typedef reg_t<0x40012c20, 0x00000001, 9, rw_t> CC3P;
            /*
                Capture/Compare 3 complementary output
              enable
             */
            typedef reg_t<0x40012c20, 0x00000001, 10, rw_t> CC3NE;
            /*
                Capture/Compare 3 output
              Polarity
             */
            typedef reg_t<0x40012c20, 0x00000001, 11, rw_t> CC3NP;
            /*
                Capture/Compare 4 output
              enable
             */
            typedef reg_t<0x40012c20, 0x00000001, 12, rw_t> CC4E;
            /*
                Capture/Compare 3 output
              Polarity
             */
            typedef reg_t<0x40012c20, 0x00000001, 13, rw_t> CC4P;
            /*
                Capture/Compare 4 output
              Polarity
             */
            typedef reg_t<0x40012c20, 0x00000001, 15, rw_t> CC4NP;
            /*
                Capture/Compare 5 output
              enable
             */
            typedef reg_t<0x40012c20, 0x00000001, 16, rw_t> CC5E;
            /*
                Capture/Compare 5 output
              Polarity
             */
            typedef reg_t<0x40012c20, 0x00000001, 17, rw_t> CC5P;
            /*
                Capture/Compare 6 output
              enable
             */
            typedef reg_t<0x40012c20, 0x00000001, 20, rw_t> CC6E;
            /*
                Capture/Compare 6 output
              Polarity
             */
            typedef reg_t<0x40012c20, 0x00000001, 21, rw_t> CC6P;
        };
        /*
            counter
         */
        namespace CNT {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                counter value
             */
            typedef reg_t<0x40012c24, 0x0000ffff, 0, rw_t> CNT;
            /*
                UIF copy
             */
            typedef reg_t<0x40012c24, 0x00000001, 31, ro_t> UIFCPY;
        };
        /*
            prescaler
         */
        namespace PSC {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c28, 0xffffffff, 0, rw_t> PSC_REG;
            /*
                Prescaler value
             */
            typedef reg_t<0x40012c28, 0x0000ffff, 0, rw_t> PSC;
        };
        /*
            auto-reload register
         */
        namespace ARR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c2c, 0xffffffff, 0, rw_t> ARR_REG;
            /*
                Auto-reload value
             */
            typedef reg_t<0x40012c2c, 0x0000ffff, 0, rw_t> ARR;
        };
        /*
            repetition counter register
         */
        namespace RCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c30, 0xffffffff, 0, rw_t> RCR_REG;
            /*
                Repetition counter value
             */
            typedef reg_t<0x40012c30, 0x0000ffff, 0, rw_t> REP;
        };
        /*
            capture/compare register 1
         */
        namespace CCR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c34, 0xffffffff, 0, rw_t> CCR1_REG;
            /*
                Capture/Compare 1 value
             */
            typedef reg_t<0x40012c34, 0x0000ffff, 0, rw_t> CCR1;
        };
        /*
            capture/compare register 2
         */
        namespace CCR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c38, 0xffffffff, 0, rw_t> CCR2_REG;
            /*
                Capture/Compare 2 value
             */
            typedef reg_t<0x40012c38, 0x0000ffff, 0, rw_t> CCR2;
        };
        /*
            capture/compare register 3
         */
        namespace CCR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c3c, 0xffffffff, 0, rw_t> CCR3_REG;
            /*
                Capture/Compare 3 value
             */
            typedef reg_t<0x40012c3c, 0x0000ffff, 0, rw_t> CCR3;
        };
        /*
            capture/compare register 4
         */
        namespace CCR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c40, 0xffffffff, 0, rw_t> CCR4_REG;
            /*
                Capture/Compare 3 value
             */
            typedef reg_t<0x40012c40, 0x0000ffff, 0, rw_t> CCR4;
        };
        /*
            break and dead-time register
         */
        namespace BDTR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c44, 0xffffffff, 0, rw_t> BDTR_REG;
            /*
                Dead-time generator setup
             */
            typedef reg_t<0x40012c44, 0x000000ff, 0, rw_t> DTG;
            /*
                Lock configuration
             */
            typedef reg_t<0x40012c44, 0x00000003, 8, rw_t> LOCK;
            /*
                Off-state selection for Idle
              mode
             */
            typedef reg_t<0x40012c44, 0x00000001, 10, rw_t> OSSI;
            /*
                Off-state selection for Run
              mode
             */
            typedef reg_t<0x40012c44, 0x00000001, 11, rw_t> OSSR;
            /*
                Break enable
             */
            typedef reg_t<0x40012c44, 0x00000001, 12, rw_t> BKE;
            /*
                Break polarity
             */
            typedef reg_t<0x40012c44, 0x00000001, 13, rw_t> BKP;
            /*
                Automatic output enable
             */
            typedef reg_t<0x40012c44, 0x00000001, 14, rw_t> AOE;
            /*
                Main output enable
             */
            typedef reg_t<0x40012c44, 0x00000001, 15, rw_t> MOE;
            /*
                Break filter
             */
            typedef reg_t<0x40012c44, 0x0000000f, 16, rw_t> BKF;
            /*
                Break 2 filter
             */
            typedef reg_t<0x40012c44, 0x0000000f, 20, rw_t> BK2F;
            /*
                Break 2 enable
             */
            typedef reg_t<0x40012c44, 0x00000001, 24, rw_t> BK2E;
            /*
                Break 2 polarity
             */
            typedef reg_t<0x40012c44, 0x00000001, 25, rw_t> BK2P;
        };
        /*
            DMA control register
         */
        namespace DCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c48, 0xffffffff, 0, rw_t> DCR_REG;
            /*
                DMA burst length
             */
            typedef reg_t<0x40012c48, 0x0000001f, 8, rw_t> DBL;
            /*
                DMA base address
             */
            typedef reg_t<0x40012c48, 0x0000001f, 0, rw_t> DBA;
        };
        /*
            DMA address for full transfer
         */
        namespace DMAR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c4c, 0xffffffff, 0, rw_t> DMAR_REG;
            /*
                DMA register for burst
              accesses
             */
            typedef reg_t<0x40012c4c, 0x0000ffff, 0, rw_t> DMAB;
        };
        /*
            capture/compare mode register 3 (output
          mode)
         */
        namespace CCMR3_Output {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c54, 0xffffffff, 0, rw_t> CCMR3_Output_REG;
            /*
                Output compare 5 fast
              enable
             */
            typedef reg_t<0x40012c54, 0x00000001, 2, rw_t> OC5FE;
            /*
                Output compare 5 preload
              enable
             */
            typedef reg_t<0x40012c54, 0x00000001, 3, rw_t> OC5PE;
            /*
                Output compare 5 mode
             */
            typedef reg_t<0x40012c54, 0x00000007, 4, rw_t> OC5M;
            /*
                Output compare 5 clear
              enable
             */
            typedef reg_t<0x40012c54, 0x00000001, 7, rw_t> OC5CE;
            /*
                Output compare 6 fast
              enable
             */
            typedef reg_t<0x40012c54, 0x00000001, 10, rw_t> OC6FE;
            /*
                Output compare 6 preload
              enable
             */
            typedef reg_t<0x40012c54, 0x00000001, 11, rw_t> OC6PE;
            /*
                Output compare 6 mode
             */
            typedef reg_t<0x40012c54, 0x00000007, 12, rw_t> OC6M;
            /*
                Output compare 6 clear
              enable
             */
            typedef reg_t<0x40012c54, 0x00000001, 15, rw_t> OC6CE;
            /*
                Outout Compare 5 mode bit
              3
             */
            typedef reg_t<0x40012c54, 0x00000001, 16, rw_t> OC5M_3;
            /*
                Outout Compare 6 mode bit
              3
             */
            typedef reg_t<0x40012c54, 0x00000001, 24, rw_t> OC6M_3;
        };
        /*
            capture/compare register 5
         */
        namespace CCR5 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c58, 0xffffffff, 0, rw_t> CCR5_REG;
            /*
                Capture/Compare 5 value
             */
            typedef reg_t<0x40012c58, 0x0000ffff, 0, rw_t> CCR5;
            /*
                Group Channel 5 and Channel
              1
             */
            typedef reg_t<0x40012c58, 0x00000001, 29, rw_t> GC5C1;
            /*
                Group Channel 5 and Channel
              2
             */
            typedef reg_t<0x40012c58, 0x00000001, 30, rw_t> GC5C2;
            /*
                Group Channel 5 and Channel
              3
             */
            typedef reg_t<0x40012c58, 0x00000001, 31, rw_t> GC5C3;
        };
        /*
            capture/compare register 6
         */
        namespace CCR6 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c5c, 0xffffffff, 0, rw_t> CCR6_REG;
            /*
                Capture/Compare 6 value
             */
            typedef reg_t<0x40012c5c, 0x0000ffff, 0, rw_t> CCR6;
        };
        /*
            option registers
         */
        namespace OR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40012c60, 0xffffffff, 0, rw_t> OR_REG;
            /*
                TIM1_ETR_ADC1 remapping
              capability
             */
            typedef reg_t<0x40012c60, 0x00000003, 0, rw_t> TIM1_ETR_ADC1_RMP;
            /*
                TIM1_ETR_ADC4 remapping
              capability
             */
            typedef reg_t<0x40012c60, 0x00000003, 2, rw_t> TIM1_ETR_ADC4_RMP;
        };
    };
    /*
        Advanced timer
     */
    namespace TIM20 {
        /*
            control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40015000, 0xffffffff, 0, rw_t> CR1_REG;
            /*
                Counter enable
             */
            typedef reg_t<0x40015000, 0x00000001, 0, rw_t> CEN;
            /*
                Update disable
             */
            typedef reg_t<0x40015000, 0x00000001, 1, rw_t> UDIS;
            /*
                Update request source
             */
            typedef reg_t<0x40015000, 0x00000001, 2, rw_t> URS;
            /*
                One-pulse mode
             */
            typedef reg_t<0x40015000, 0x00000001, 3, rw_t> OPM;
            /*
                Direction
             */
            typedef reg_t<0x40015000, 0x00000001, 4, rw_t> DIR;
            /*
                Center-aligned mode
              selection
             */
            typedef reg_t<0x40015000, 0x00000003, 5, rw_t> CMS;
            /*
                Auto-reload preload enable
             */
            typedef reg_t<0x40015000, 0x00000001, 7, rw_t> ARPE;
            /*
                Clock division
             */
            typedef reg_t<0x40015000, 0x00000003, 8, rw_t> CKD;
            /*
                UIF status bit remapping
             */
            typedef reg_t<0x40015000, 0x00000001, 11, rw_t> UIFREMAP;
        };
        /*
            control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40015004, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                Capture/compare preloaded
              control
             */
            typedef reg_t<0x40015004, 0x00000001, 0, rw_t> CCPC;
            /*
                Capture/compare control update
              selection
             */
            typedef reg_t<0x40015004, 0x00000001, 2, rw_t> CCUS;
            /*
                Capture/compare DMA
              selection
             */
            typedef reg_t<0x40015004, 0x00000001, 3, rw_t> CCDS;
            /*
                Master mode selection
             */
            typedef reg_t<0x40015004, 0x00000007, 4, rw_t> MMS;
            /*
                TI1 selection
             */
            typedef reg_t<0x40015004, 0x00000001, 7, rw_t> TI1S;
            /*
                Output Idle state 1
             */
            typedef reg_t<0x40015004, 0x00000001, 8, rw_t> OIS1;
            /*
                Output Idle state 1
             */
            typedef reg_t<0x40015004, 0x00000001, 9, rw_t> OIS1N;
            /*
                Output Idle state 2
             */
            typedef reg_t<0x40015004, 0x00000001, 10, rw_t> OIS2;
            /*
                Output Idle state 2
             */
            typedef reg_t<0x40015004, 0x00000001, 11, rw_t> OIS2N;
            /*
                Output Idle state 3
             */
            typedef reg_t<0x40015004, 0x00000001, 12, rw_t> OIS3;
            /*
                Output Idle state 3
             */
            typedef reg_t<0x40015004, 0x00000001, 13, rw_t> OIS3N;
            /*
                Output Idle state 4
             */
            typedef reg_t<0x40015004, 0x00000001, 14, rw_t> OIS4;
            /*
                Output Idle state 5
             */
            typedef reg_t<0x40015004, 0x00000001, 16, rw_t> OIS5;
            /*
                Output Idle state 6
             */
            typedef reg_t<0x40015004, 0x00000001, 18, rw_t> OIS6;
            /*
                Master mode selection 2
             */
            typedef reg_t<0x40015004, 0x0000000f, 20, rw_t> MMS2;
        };
        /*
            slave mode control register
         */
        namespace SMCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40015008, 0xffffffff, 0, rw_t> SMCR_REG;
            /*
                Slave mode selection
             */
            typedef reg_t<0x40015008, 0x00000007, 0, rw_t> SMS;
            /*
                OCREF clear selection
             */
            typedef reg_t<0x40015008, 0x00000001, 3, rw_t> OCCS;
            /*
                Trigger selection
             */
            typedef reg_t<0x40015008, 0x00000007, 4, rw_t> TS;
            /*
                Master/Slave mode
             */
            typedef reg_t<0x40015008, 0x00000001, 7, rw_t> MSM;
            /*
                External trigger filter
             */
            typedef reg_t<0x40015008, 0x0000000f, 8, rw_t> ETF;
            /*
                External trigger prescaler
             */
            typedef reg_t<0x40015008, 0x00000003, 12, rw_t> ETPS;
            /*
                External clock enable
             */
            typedef reg_t<0x40015008, 0x00000001, 14, rw_t> ECE;
            /*
                External trigger polarity
             */
            typedef reg_t<0x40015008, 0x00000001, 15, rw_t> ETP;
            /*
                Slave mode selection bit 3
             */
            typedef reg_t<0x40015008, 0x00000001, 16, rw_t> SMS3;
        };
        /*
            DMA/Interrupt enable register
         */
        namespace DIER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001500c, 0xffffffff, 0, rw_t> DIER_REG;
            /*
                Trigger DMA request enable
             */
            typedef reg_t<0x4001500c, 0x00000001, 14, rw_t> TDE;
            /*
                COM DMA request enable
             */
            typedef reg_t<0x4001500c, 0x00000001, 13, rw_t> COMDE;
            /*
                Capture/Compare 4 DMA request
              enable
             */
            typedef reg_t<0x4001500c, 0x00000001, 12, rw_t> CC4DE;
            /*
                Capture/Compare 3 DMA request
              enable
             */
            typedef reg_t<0x4001500c, 0x00000001, 11, rw_t> CC3DE;
            /*
                Capture/Compare 2 DMA request
              enable
             */
            typedef reg_t<0x4001500c, 0x00000001, 10, rw_t> CC2DE;
            /*
                Capture/Compare 1 DMA request
              enable
             */
            typedef reg_t<0x4001500c, 0x00000001, 9, rw_t> CC1DE;
            /*
                Update DMA request enable
             */
            typedef reg_t<0x4001500c, 0x00000001, 8, rw_t> UDE;
            /*
                Break interrupt enable
             */
            typedef reg_t<0x4001500c, 0x00000001, 7, rw_t> BIE;
            /*
                Trigger interrupt enable
             */
            typedef reg_t<0x4001500c, 0x00000001, 6, rw_t> TIE;
            /*
                COM interrupt enable
             */
            typedef reg_t<0x4001500c, 0x00000001, 5, rw_t> COMIE;
            /*
                Capture/Compare 4 interrupt
              enable
             */
            typedef reg_t<0x4001500c, 0x00000001, 4, rw_t> CC4IE;
            /*
                Capture/Compare 3 interrupt
              enable
             */
            typedef reg_t<0x4001500c, 0x00000001, 3, rw_t> CC3IE;
            /*
                Capture/Compare 2 interrupt
              enable
             */
            typedef reg_t<0x4001500c, 0x00000001, 2, rw_t> CC2IE;
            /*
                Capture/Compare 1 interrupt
              enable
             */
            typedef reg_t<0x4001500c, 0x00000001, 1, rw_t> CC1IE;
            /*
                Update interrupt enable
             */
            typedef reg_t<0x4001500c, 0x00000001, 0, rw_t> UIE;
        };
        /*
            status register
         */
        namespace SR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40015010, 0xffffffff, 0, rw_t> SR_REG;
            /*
                Update interrupt flag
             */
            typedef reg_t<0x40015010, 0x00000001, 0, rw_t> UIF;
            /*
                Capture/compare 1 interrupt
              flag
             */
            typedef reg_t<0x40015010, 0x00000001, 1, rw_t> CC1IF;
            /*
                Capture/Compare 2 interrupt
              flag
             */
            typedef reg_t<0x40015010, 0x00000001, 2, rw_t> CC2IF;
            /*
                Capture/Compare 3 interrupt
              flag
             */
            typedef reg_t<0x40015010, 0x00000001, 3, rw_t> CC3IF;
            /*
                Capture/Compare 4 interrupt
              flag
             */
            typedef reg_t<0x40015010, 0x00000001, 4, rw_t> CC4IF;
            /*
                COM interrupt flag
             */
            typedef reg_t<0x40015010, 0x00000001, 5, rw_t> COMIF;
            /*
                Trigger interrupt flag
             */
            typedef reg_t<0x40015010, 0x00000001, 6, rw_t> TIF;
            /*
                Break interrupt flag
             */
            typedef reg_t<0x40015010, 0x00000001, 7, rw_t> BIF;
            /*
                Break 2 interrupt flag
             */
            typedef reg_t<0x40015010, 0x00000001, 8, rw_t> B2IF;
            /*
                Capture/Compare 1 overcapture
              flag
             */
            typedef reg_t<0x40015010, 0x00000001, 9, rw_t> CC1OF;
            /*
                Capture/compare 2 overcapture
              flag
             */
            typedef reg_t<0x40015010, 0x00000001, 10, rw_t> CC2OF;
            /*
                Capture/Compare 3 overcapture
              flag
             */
            typedef reg_t<0x40015010, 0x00000001, 11, rw_t> CC3OF;
            /*
                Capture/Compare 4 overcapture
              flag
             */
            typedef reg_t<0x40015010, 0x00000001, 12, rw_t> CC4OF;
            /*
                Capture/Compare 5 interrupt
              flag
             */
            typedef reg_t<0x40015010, 0x00000001, 16, rw_t> C5IF;
            /*
                Capture/Compare 6 interrupt
              flag
             */
            typedef reg_t<0x40015010, 0x00000001, 17, rw_t> C6IF;
        };
        /*
            event generation register
         */
        namespace EGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40015014, 0xffffffff, 0, wo_t> EGR_REG;
            /*
                Update generation
             */
            typedef reg_t<0x40015014, 0x00000001, 0, wo_t> UG;
            /*
                Capture/compare 1
              generation
             */
            typedef reg_t<0x40015014, 0x00000001, 1, wo_t> CC1G;
            /*
                Capture/compare 2
              generation
             */
            typedef reg_t<0x40015014, 0x00000001, 2, wo_t> CC2G;
            /*
                Capture/compare 3
              generation
             */
            typedef reg_t<0x40015014, 0x00000001, 3, wo_t> CC3G;
            /*
                Capture/compare 4
              generation
             */
            typedef reg_t<0x40015014, 0x00000001, 4, wo_t> CC4G;
            /*
                Capture/Compare control update
              generation
             */
            typedef reg_t<0x40015014, 0x00000001, 5, wo_t> COMG;
            /*
                Trigger generation
             */
            typedef reg_t<0x40015014, 0x00000001, 6, wo_t> TG;
            /*
                Break generation
             */
            typedef reg_t<0x40015014, 0x00000001, 7, wo_t> BG;
            /*
                Break 2 generation
             */
            typedef reg_t<0x40015014, 0x00000001, 8, wo_t> B2G;
        };
        /*
            capture/compare mode register (output
          mode)
         */
        namespace CCMR1_Output {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40015018, 0xffffffff, 0, rw_t> CCMR1_Output_REG;
            /*
                Output Compare 2 clear
              enable
             */
            typedef reg_t<0x40015018, 0x00000001, 15, rw_t> OC2CE;
            /*
                Output Compare 2 mode
             */
            typedef reg_t<0x40015018, 0x00000007, 12, rw_t> OC2M;
            /*
                Output Compare 2 preload
              enable
             */
            typedef reg_t<0x40015018, 0x00000001, 11, rw_t> OC2PE;
            /*
                Output Compare 2 fast
              enable
             */
            typedef reg_t<0x40015018, 0x00000001, 10, rw_t> OC2FE;
            /*
                Capture/Compare 2
              selection
             */
            typedef reg_t<0x40015018, 0x00000003, 8, rw_t> CC2S;
            /*
                Output Compare 1 clear
              enable
             */
            typedef reg_t<0x40015018, 0x00000001, 7, rw_t> OC1CE;
            /*
                Output Compare 1 mode
             */
            typedef reg_t<0x40015018, 0x00000007, 4, rw_t> OC1M;
            /*
                Output Compare 1 preload
              enable
             */
            typedef reg_t<0x40015018, 0x00000001, 3, rw_t> OC1PE;
            /*
                Output Compare 1 fast
              enable
             */
            typedef reg_t<0x40015018, 0x00000001, 2, rw_t> OC1FE;
            /*
                Capture/Compare 1
              selection
             */
            typedef reg_t<0x40015018, 0x00000003, 0, rw_t> CC1S;
            /*
                Output Compare 1 mode bit
              3
             */
            typedef reg_t<0x40015018, 0x00000001, 16, rw_t> OC1M_3;
            /*
                Output Compare 2 mode bit
              3
             */
            typedef reg_t<0x40015018, 0x00000001, 24, rw_t> OC2M_3;
        };
        /*
            capture/compare mode register 1 (input
          mode)
         */
        namespace CCMR1_Input {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40015018, 0xffffffff, 0, rw_t> CCMR1_Input_REG;
            /*
                Input capture 2 filter
             */
            typedef reg_t<0x40015018, 0x0000000f, 12, rw_t> IC2F;
            /*
                Input capture 2 prescaler
             */
            typedef reg_t<0x40015018, 0x00000003, 10, rw_t> IC2PCS;
            /*
                Capture/Compare 2
              selection
             */
            typedef reg_t<0x40015018, 0x00000003, 8, rw_t> CC2S;
            /*
                Input capture 1 filter
             */
            typedef reg_t<0x40015018, 0x0000000f, 4, rw_t> IC1F;
            /*
                Input capture 1 prescaler
             */
            typedef reg_t<0x40015018, 0x00000003, 2, rw_t> IC1PCS;
            /*
                Capture/Compare 1
              selection
             */
            typedef reg_t<0x40015018, 0x00000003, 0, rw_t> CC1S;
        };
        /*
            capture/compare mode register (output
          mode)
         */
        namespace CCMR2_Output {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001501c, 0xffffffff, 0, rw_t> CCMR2_Output_REG;
            /*
                Output compare 4 clear
              enable
             */
            typedef reg_t<0x4001501c, 0x00000001, 15, rw_t> OC4CE;
            /*
                Output compare 4 mode
             */
            typedef reg_t<0x4001501c, 0x00000007, 12, rw_t> OC4M;
            /*
                Output compare 4 preload
              enable
             */
            typedef reg_t<0x4001501c, 0x00000001, 11, rw_t> OC4PE;
            /*
                Output compare 4 fast
              enable
             */
            typedef reg_t<0x4001501c, 0x00000001, 10, rw_t> OC4FE;
            /*
                Capture/Compare 4
              selection
             */
            typedef reg_t<0x4001501c, 0x00000003, 8, rw_t> CC4S;
            /*
                Output compare 3 clear
              enable
             */
            typedef reg_t<0x4001501c, 0x00000001, 7, rw_t> OC3CE;
            /*
                Output compare 3 mode
             */
            typedef reg_t<0x4001501c, 0x00000007, 4, rw_t> OC3M;
            /*
                Output compare 3 preload
              enable
             */
            typedef reg_t<0x4001501c, 0x00000001, 3, rw_t> OC3PE;
            /*
                Output compare 3 fast
              enable
             */
            typedef reg_t<0x4001501c, 0x00000001, 2, rw_t> OC3FE;
            /*
                Capture/Compare 3
              selection
             */
            typedef reg_t<0x4001501c, 0x00000003, 0, rw_t> CC3S;
            /*
                Output Compare 3 mode bit
              3
             */
            typedef reg_t<0x4001501c, 0x00000001, 16, rw_t> OC3M_3;
            /*
                Output Compare 4 mode bit
              3
             */
            typedef reg_t<0x4001501c, 0x00000001, 24, rw_t> OC4M_3;
        };
        /*
            capture/compare mode register 2 (input
          mode)
         */
        namespace CCMR2_Input {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001501c, 0xffffffff, 0, rw_t> CCMR2_Input_REG;
            /*
                Input capture 4 filter
             */
            typedef reg_t<0x4001501c, 0x0000000f, 12, rw_t> IC4F;
            /*
                Input capture 4 prescaler
             */
            typedef reg_t<0x4001501c, 0x00000003, 10, rw_t> IC4PSC;
            /*
                Capture/Compare 4
              selection
             */
            typedef reg_t<0x4001501c, 0x00000003, 8, rw_t> CC4S;
            /*
                Input capture 3 filter
             */
            typedef reg_t<0x4001501c, 0x0000000f, 4, rw_t> IC3F;
            /*
                Input capture 3 prescaler
             */
            typedef reg_t<0x4001501c, 0x00000003, 2, rw_t> IC3PSC;
            /*
                Capture/compare 3
              selection
             */
            typedef reg_t<0x4001501c, 0x00000003, 0, rw_t> CC3S;
        };
        /*
            capture/compare enable
          register
         */
        namespace CCER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40015020, 0xffffffff, 0, rw_t> CCER_REG;
            /*
                Capture/Compare 1 output
              enable
             */
            typedef reg_t<0x40015020, 0x00000001, 0, rw_t> CC1E;
            /*
                Capture/Compare 1 output
              Polarity
             */
            typedef reg_t<0x40015020, 0x00000001, 1, rw_t> CC1P;
            /*
                Capture/Compare 1 complementary output
              enable
             */
            typedef reg_t<0x40015020, 0x00000001, 2, rw_t> CC1NE;
            /*
                Capture/Compare 1 output
              Polarity
             */
            typedef reg_t<0x40015020, 0x00000001, 3, rw_t> CC1NP;
            /*
                Capture/Compare 2 output
              enable
             */
            typedef reg_t<0x40015020, 0x00000001, 4, rw_t> CC2E;
            /*
                Capture/Compare 2 output
              Polarity
             */
            typedef reg_t<0x40015020, 0x00000001, 5, rw_t> CC2P;
            /*
                Capture/Compare 2 complementary output
              enable
             */
            typedef reg_t<0x40015020, 0x00000001, 6, rw_t> CC2NE;
            /*
                Capture/Compare 2 output
              Polarity
             */
            typedef reg_t<0x40015020, 0x00000001, 7, rw_t> CC2NP;
            /*
                Capture/Compare 3 output
              enable
             */
            typedef reg_t<0x40015020, 0x00000001, 8, rw_t> CC3E;
            /*
                Capture/Compare 3 output
              Polarity
             */
            typedef reg_t<0x40015020, 0x00000001, 9, rw_t> CC3P;
            /*
                Capture/Compare 3 complementary output
              enable
             */
            typedef reg_t<0x40015020, 0x00000001, 10, rw_t> CC3NE;
            /*
                Capture/Compare 3 output
              Polarity
             */
            typedef reg_t<0x40015020, 0x00000001, 11, rw_t> CC3NP;
            /*
                Capture/Compare 4 output
              enable
             */
            typedef reg_t<0x40015020, 0x00000001, 12, rw_t> CC4E;
            /*
                Capture/Compare 3 output
              Polarity
             */
            typedef reg_t<0x40015020, 0x00000001, 13, rw_t> CC4P;
            /*
                Capture/Compare 4 output
              Polarity
             */
            typedef reg_t<0x40015020, 0x00000001, 15, rw_t> CC4NP;
            /*
                Capture/Compare 5 output
              enable
             */
            typedef reg_t<0x40015020, 0x00000001, 16, rw_t> CC5E;
            /*
                Capture/Compare 5 output
              Polarity
             */
            typedef reg_t<0x40015020, 0x00000001, 17, rw_t> CC5P;
            /*
                Capture/Compare 6 output
              enable
             */
            typedef reg_t<0x40015020, 0x00000001, 20, rw_t> CC6E;
            /*
                Capture/Compare 6 output
              Polarity
             */
            typedef reg_t<0x40015020, 0x00000001, 21, rw_t> CC6P;
        };
        /*
            counter
         */
        namespace CNT {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                counter value
             */
            typedef reg_t<0x40015024, 0x0000ffff, 0, rw_t> CNT;
            /*
                UIF copy
             */
            typedef reg_t<0x40015024, 0x00000001, 31, ro_t> UIFCPY;
        };
        /*
            prescaler
         */
        namespace PSC {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40015028, 0xffffffff, 0, rw_t> PSC_REG;
            /*
                Prescaler value
             */
            typedef reg_t<0x40015028, 0x0000ffff, 0, rw_t> PSC;
        };
        /*
            auto-reload register
         */
        namespace ARR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001502c, 0xffffffff, 0, rw_t> ARR_REG;
            /*
                Auto-reload value
             */
            typedef reg_t<0x4001502c, 0x0000ffff, 0, rw_t> ARR;
        };
        /*
            repetition counter register
         */
        namespace RCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40015030, 0xffffffff, 0, rw_t> RCR_REG;
            /*
                Repetition counter value
             */
            typedef reg_t<0x40015030, 0x0000ffff, 0, rw_t> REP;
        };
        /*
            capture/compare register 1
         */
        namespace CCR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40015034, 0xffffffff, 0, rw_t> CCR1_REG;
            /*
                Capture/Compare 1 value
             */
            typedef reg_t<0x40015034, 0x0000ffff, 0, rw_t> CCR1;
        };
        /*
            capture/compare register 2
         */
        namespace CCR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40015038, 0xffffffff, 0, rw_t> CCR2_REG;
            /*
                Capture/Compare 2 value
             */
            typedef reg_t<0x40015038, 0x0000ffff, 0, rw_t> CCR2;
        };
        /*
            capture/compare register 3
         */
        namespace CCR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001503c, 0xffffffff, 0, rw_t> CCR3_REG;
            /*
                Capture/Compare 3 value
             */
            typedef reg_t<0x4001503c, 0x0000ffff, 0, rw_t> CCR3;
        };
        /*
            capture/compare register 4
         */
        namespace CCR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40015040, 0xffffffff, 0, rw_t> CCR4_REG;
            /*
                Capture/Compare 3 value
             */
            typedef reg_t<0x40015040, 0x0000ffff, 0, rw_t> CCR4;
        };
        /*
            break and dead-time register
         */
        namespace BDTR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40015044, 0xffffffff, 0, rw_t> BDTR_REG;
            /*
                Dead-time generator setup
             */
            typedef reg_t<0x40015044, 0x000000ff, 0, rw_t> DTG;
            /*
                Lock configuration
             */
            typedef reg_t<0x40015044, 0x00000003, 8, rw_t> LOCK;
            /*
                Off-state selection for Idle
              mode
             */
            typedef reg_t<0x40015044, 0x00000001, 10, rw_t> OSSI;
            /*
                Off-state selection for Run
              mode
             */
            typedef reg_t<0x40015044, 0x00000001, 11, rw_t> OSSR;
            /*
                Break enable
             */
            typedef reg_t<0x40015044, 0x00000001, 12, rw_t> BKE;
            /*
                Break polarity
             */
            typedef reg_t<0x40015044, 0x00000001, 13, rw_t> BKP;
            /*
                Automatic output enable
             */
            typedef reg_t<0x40015044, 0x00000001, 14, rw_t> AOE;
            /*
                Main output enable
             */
            typedef reg_t<0x40015044, 0x00000001, 15, rw_t> MOE;
            /*
                Break filter
             */
            typedef reg_t<0x40015044, 0x0000000f, 16, rw_t> BKF;
            /*
                Break 2 filter
             */
            typedef reg_t<0x40015044, 0x0000000f, 20, rw_t> BK2F;
            /*
                Break 2 enable
             */
            typedef reg_t<0x40015044, 0x00000001, 24, rw_t> BK2E;
            /*
                Break 2 polarity
             */
            typedef reg_t<0x40015044, 0x00000001, 25, rw_t> BK2P;
        };
        /*
            DMA control register
         */
        namespace DCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40015048, 0xffffffff, 0, rw_t> DCR_REG;
            /*
                DMA burst length
             */
            typedef reg_t<0x40015048, 0x0000001f, 8, rw_t> DBL;
            /*
                DMA base address
             */
            typedef reg_t<0x40015048, 0x0000001f, 0, rw_t> DBA;
        };
        /*
            DMA address for full transfer
         */
        namespace DMAR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001504c, 0xffffffff, 0, rw_t> DMAR_REG;
            /*
                DMA register for burst
              accesses
             */
            typedef reg_t<0x4001504c, 0x0000ffff, 0, rw_t> DMAB;
        };
        /*
            capture/compare mode register 3 (output
          mode)
         */
        namespace CCMR3_Output {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40015054, 0xffffffff, 0, rw_t> CCMR3_Output_REG;
            /*
                Output compare 5 fast
              enable
             */
            typedef reg_t<0x40015054, 0x00000001, 2, rw_t> OC5FE;
            /*
                Output compare 5 preload
              enable
             */
            typedef reg_t<0x40015054, 0x00000001, 3, rw_t> OC5PE;
            /*
                Output compare 5 mode
             */
            typedef reg_t<0x40015054, 0x00000007, 4, rw_t> OC5M;
            /*
                Output compare 5 clear
              enable
             */
            typedef reg_t<0x40015054, 0x00000001, 7, rw_t> OC5CE;
            /*
                Output compare 6 fast
              enable
             */
            typedef reg_t<0x40015054, 0x00000001, 10, rw_t> OC6FE;
            /*
                Output compare 6 preload
              enable
             */
            typedef reg_t<0x40015054, 0x00000001, 11, rw_t> OC6PE;
            /*
                Output compare 6 mode
             */
            typedef reg_t<0x40015054, 0x00000007, 12, rw_t> OC6M;
            /*
                Output compare 6 clear
              enable
             */
            typedef reg_t<0x40015054, 0x00000001, 15, rw_t> OC6CE;
            /*
                Outout Compare 5 mode bit
              3
             */
            typedef reg_t<0x40015054, 0x00000001, 16, rw_t> OC5M_3;
            /*
                Outout Compare 6 mode bit
              3
             */
            typedef reg_t<0x40015054, 0x00000001, 24, rw_t> OC6M_3;
        };
        /*
            capture/compare register 5
         */
        namespace CCR5 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40015058, 0xffffffff, 0, rw_t> CCR5_REG;
            /*
                Capture/Compare 5 value
             */
            typedef reg_t<0x40015058, 0x0000ffff, 0, rw_t> CCR5;
            /*
                Group Channel 5 and Channel
              1
             */
            typedef reg_t<0x40015058, 0x00000001, 29, rw_t> GC5C1;
            /*
                Group Channel 5 and Channel
              2
             */
            typedef reg_t<0x40015058, 0x00000001, 30, rw_t> GC5C2;
            /*
                Group Channel 5 and Channel
              3
             */
            typedef reg_t<0x40015058, 0x00000001, 31, rw_t> GC5C3;
        };
        /*
            capture/compare register 6
         */
        namespace CCR6 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001505c, 0xffffffff, 0, rw_t> CCR6_REG;
            /*
                Capture/Compare 6 value
             */
            typedef reg_t<0x4001505c, 0x0000ffff, 0, rw_t> CCR6;
        };
        /*
            option registers
         */
        namespace OR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40015060, 0xffffffff, 0, rw_t> OR_REG;
            /*
                TIM1_ETR_ADC1 remapping
              capability
             */
            typedef reg_t<0x40015060, 0x00000003, 0, rw_t> TIM1_ETR_ADC1_RMP;
            /*
                TIM1_ETR_ADC4 remapping
              capability
             */
            typedef reg_t<0x40015060, 0x00000003, 2, rw_t> TIM1_ETR_ADC4_RMP;
        };
    };
    /*
        Advanced-timers
     */
    namespace TIM8 {
        /*
            control register 1
         */
        namespace CR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013400, 0xffffffff, 0, rw_t> CR1_REG;
            /*
                Counter enable
             */
            typedef reg_t<0x40013400, 0x00000001, 0, rw_t> CEN;
            /*
                Update disable
             */
            typedef reg_t<0x40013400, 0x00000001, 1, rw_t> UDIS;
            /*
                Update request source
             */
            typedef reg_t<0x40013400, 0x00000001, 2, rw_t> URS;
            /*
                One-pulse mode
             */
            typedef reg_t<0x40013400, 0x00000001, 3, rw_t> OPM;
            /*
                Direction
             */
            typedef reg_t<0x40013400, 0x00000001, 4, rw_t> DIR;
            /*
                Center-aligned mode
              selection
             */
            typedef reg_t<0x40013400, 0x00000003, 5, rw_t> CMS;
            /*
                Auto-reload preload enable
             */
            typedef reg_t<0x40013400, 0x00000001, 7, rw_t> ARPE;
            /*
                Clock division
             */
            typedef reg_t<0x40013400, 0x00000003, 8, rw_t> CKD;
            /*
                UIF status bit remapping
             */
            typedef reg_t<0x40013400, 0x00000001, 11, rw_t> UIFREMAP;
        };
        /*
            control register 2
         */
        namespace CR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013404, 0xffffffff, 0, rw_t> CR2_REG;
            /*
                Capture/compare preloaded
              control
             */
            typedef reg_t<0x40013404, 0x00000001, 0, rw_t> CCPC;
            /*
                Capture/compare control update
              selection
             */
            typedef reg_t<0x40013404, 0x00000001, 2, rw_t> CCUS;
            /*
                Capture/compare DMA
              selection
             */
            typedef reg_t<0x40013404, 0x00000001, 3, rw_t> CCDS;
            /*
                Master mode selection
             */
            typedef reg_t<0x40013404, 0x00000007, 4, rw_t> MMS;
            /*
                TI1 selection
             */
            typedef reg_t<0x40013404, 0x00000001, 7, rw_t> TI1S;
            /*
                Output Idle state 1
             */
            typedef reg_t<0x40013404, 0x00000001, 8, rw_t> OIS1;
            /*
                Output Idle state 1
             */
            typedef reg_t<0x40013404, 0x00000001, 9, rw_t> OIS1N;
            /*
                Output Idle state 2
             */
            typedef reg_t<0x40013404, 0x00000001, 10, rw_t> OIS2;
            /*
                Output Idle state 2
             */
            typedef reg_t<0x40013404, 0x00000001, 11, rw_t> OIS2N;
            /*
                Output Idle state 3
             */
            typedef reg_t<0x40013404, 0x00000001, 12, rw_t> OIS3;
            /*
                Output Idle state 3
             */
            typedef reg_t<0x40013404, 0x00000001, 13, rw_t> OIS3N;
            /*
                Output Idle state 4
             */
            typedef reg_t<0x40013404, 0x00000001, 14, rw_t> OIS4;
            /*
                Output Idle state 5
             */
            typedef reg_t<0x40013404, 0x00000001, 16, rw_t> OIS5;
            /*
                Output Idle state 6
             */
            typedef reg_t<0x40013404, 0x00000001, 18, rw_t> OIS6;
            /*
                Master mode selection 2
             */
            typedef reg_t<0x40013404, 0x0000000f, 20, rw_t> MMS2;
        };
        /*
            slave mode control register
         */
        namespace SMCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013408, 0xffffffff, 0, rw_t> SMCR_REG;
            /*
                Slave mode selection
             */
            typedef reg_t<0x40013408, 0x00000007, 0, rw_t> SMS;
            /*
                OCREF clear selection
             */
            typedef reg_t<0x40013408, 0x00000001, 3, rw_t> OCCS;
            /*
                Trigger selection
             */
            typedef reg_t<0x40013408, 0x00000007, 4, rw_t> TS;
            /*
                Master/Slave mode
             */
            typedef reg_t<0x40013408, 0x00000001, 7, rw_t> MSM;
            /*
                External trigger filter
             */
            typedef reg_t<0x40013408, 0x0000000f, 8, rw_t> ETF;
            /*
                External trigger prescaler
             */
            typedef reg_t<0x40013408, 0x00000003, 12, rw_t> ETPS;
            /*
                External clock enable
             */
            typedef reg_t<0x40013408, 0x00000001, 14, rw_t> ECE;
            /*
                External trigger polarity
             */
            typedef reg_t<0x40013408, 0x00000001, 15, rw_t> ETP;
            /*
                Slave mode selection bit 3
             */
            typedef reg_t<0x40013408, 0x00000001, 16, rw_t> SMS3;
        };
        /*
            DMA/Interrupt enable register
         */
        namespace DIER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001340c, 0xffffffff, 0, rw_t> DIER_REG;
            /*
                Trigger DMA request enable
             */
            typedef reg_t<0x4001340c, 0x00000001, 14, rw_t> TDE;
            /*
                COM DMA request enable
             */
            typedef reg_t<0x4001340c, 0x00000001, 13, rw_t> COMDE;
            /*
                Capture/Compare 4 DMA request
              enable
             */
            typedef reg_t<0x4001340c, 0x00000001, 12, rw_t> CC4DE;
            /*
                Capture/Compare 3 DMA request
              enable
             */
            typedef reg_t<0x4001340c, 0x00000001, 11, rw_t> CC3DE;
            /*
                Capture/Compare 2 DMA request
              enable
             */
            typedef reg_t<0x4001340c, 0x00000001, 10, rw_t> CC2DE;
            /*
                Capture/Compare 1 DMA request
              enable
             */
            typedef reg_t<0x4001340c, 0x00000001, 9, rw_t> CC1DE;
            /*
                Update DMA request enable
             */
            typedef reg_t<0x4001340c, 0x00000001, 8, rw_t> UDE;
            /*
                Break interrupt enable
             */
            typedef reg_t<0x4001340c, 0x00000001, 7, rw_t> BIE;
            /*
                Trigger interrupt enable
             */
            typedef reg_t<0x4001340c, 0x00000001, 6, rw_t> TIE;
            /*
                COM interrupt enable
             */
            typedef reg_t<0x4001340c, 0x00000001, 5, rw_t> COMIE;
            /*
                Capture/Compare 4 interrupt
              enable
             */
            typedef reg_t<0x4001340c, 0x00000001, 4, rw_t> CC4IE;
            /*
                Capture/Compare 3 interrupt
              enable
             */
            typedef reg_t<0x4001340c, 0x00000001, 3, rw_t> CC3IE;
            /*
                Capture/Compare 2 interrupt
              enable
             */
            typedef reg_t<0x4001340c, 0x00000001, 2, rw_t> CC2IE;
            /*
                Capture/Compare 1 interrupt
              enable
             */
            typedef reg_t<0x4001340c, 0x00000001, 1, rw_t> CC1IE;
            /*
                Update interrupt enable
             */
            typedef reg_t<0x4001340c, 0x00000001, 0, rw_t> UIE;
        };
        /*
            status register
         */
        namespace SR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013410, 0xffffffff, 0, rw_t> SR_REG;
            /*
                Update interrupt flag
             */
            typedef reg_t<0x40013410, 0x00000001, 0, rw_t> UIF;
            /*
                Capture/compare 1 interrupt
              flag
             */
            typedef reg_t<0x40013410, 0x00000001, 1, rw_t> CC1IF;
            /*
                Capture/Compare 2 interrupt
              flag
             */
            typedef reg_t<0x40013410, 0x00000001, 2, rw_t> CC2IF;
            /*
                Capture/Compare 3 interrupt
              flag
             */
            typedef reg_t<0x40013410, 0x00000001, 3, rw_t> CC3IF;
            /*
                Capture/Compare 4 interrupt
              flag
             */
            typedef reg_t<0x40013410, 0x00000001, 4, rw_t> CC4IF;
            /*
                COM interrupt flag
             */
            typedef reg_t<0x40013410, 0x00000001, 5, rw_t> COMIF;
            /*
                Trigger interrupt flag
             */
            typedef reg_t<0x40013410, 0x00000001, 6, rw_t> TIF;
            /*
                Break interrupt flag
             */
            typedef reg_t<0x40013410, 0x00000001, 7, rw_t> BIF;
            /*
                Break 2 interrupt flag
             */
            typedef reg_t<0x40013410, 0x00000001, 8, rw_t> B2IF;
            /*
                Capture/Compare 1 overcapture
              flag
             */
            typedef reg_t<0x40013410, 0x00000001, 9, rw_t> CC1OF;
            /*
                Capture/compare 2 overcapture
              flag
             */
            typedef reg_t<0x40013410, 0x00000001, 10, rw_t> CC2OF;
            /*
                Capture/Compare 3 overcapture
              flag
             */
            typedef reg_t<0x40013410, 0x00000001, 11, rw_t> CC3OF;
            /*
                Capture/Compare 4 overcapture
              flag
             */
            typedef reg_t<0x40013410, 0x00000001, 12, rw_t> CC4OF;
            /*
                Capture/Compare 5 interrupt
              flag
             */
            typedef reg_t<0x40013410, 0x00000001, 16, rw_t> C5IF;
            /*
                Capture/Compare 6 interrupt
              flag
             */
            typedef reg_t<0x40013410, 0x00000001, 17, rw_t> C6IF;
        };
        /*
            event generation register
         */
        namespace EGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013414, 0xffffffff, 0, wo_t> EGR_REG;
            /*
                Update generation
             */
            typedef reg_t<0x40013414, 0x00000001, 0, wo_t> UG;
            /*
                Capture/compare 1
              generation
             */
            typedef reg_t<0x40013414, 0x00000001, 1, wo_t> CC1G;
            /*
                Capture/compare 2
              generation
             */
            typedef reg_t<0x40013414, 0x00000001, 2, wo_t> CC2G;
            /*
                Capture/compare 3
              generation
             */
            typedef reg_t<0x40013414, 0x00000001, 3, wo_t> CC3G;
            /*
                Capture/compare 4
              generation
             */
            typedef reg_t<0x40013414, 0x00000001, 4, wo_t> CC4G;
            /*
                Capture/Compare control update
              generation
             */
            typedef reg_t<0x40013414, 0x00000001, 5, wo_t> COMG;
            /*
                Trigger generation
             */
            typedef reg_t<0x40013414, 0x00000001, 6, wo_t> TG;
            /*
                Break generation
             */
            typedef reg_t<0x40013414, 0x00000001, 7, wo_t> BG;
            /*
                Break 2 generation
             */
            typedef reg_t<0x40013414, 0x00000001, 8, wo_t> B2G;
        };
        /*
            capture/compare mode register (output
          mode)
         */
        namespace CCMR1_Output {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013418, 0xffffffff, 0, rw_t> CCMR1_Output_REG;
            /*
                Output Compare 2 clear
              enable
             */
            typedef reg_t<0x40013418, 0x00000001, 15, rw_t> OC2CE;
            /*
                Output Compare 2 mode
             */
            typedef reg_t<0x40013418, 0x00000007, 12, rw_t> OC2M;
            /*
                Output Compare 2 preload
              enable
             */
            typedef reg_t<0x40013418, 0x00000001, 11, rw_t> OC2PE;
            /*
                Output Compare 2 fast
              enable
             */
            typedef reg_t<0x40013418, 0x00000001, 10, rw_t> OC2FE;
            /*
                Capture/Compare 2
              selection
             */
            typedef reg_t<0x40013418, 0x00000003, 8, rw_t> CC2S;
            /*
                Output Compare 1 clear
              enable
             */
            typedef reg_t<0x40013418, 0x00000001, 7, rw_t> OC1CE;
            /*
                Output Compare 1 mode
             */
            typedef reg_t<0x40013418, 0x00000007, 4, rw_t> OC1M;
            /*
                Output Compare 1 preload
              enable
             */
            typedef reg_t<0x40013418, 0x00000001, 3, rw_t> OC1PE;
            /*
                Output Compare 1 fast
              enable
             */
            typedef reg_t<0x40013418, 0x00000001, 2, rw_t> OC1FE;
            /*
                Capture/Compare 1
              selection
             */
            typedef reg_t<0x40013418, 0x00000003, 0, rw_t> CC1S;
            /*
                Output Compare 1 mode bit
              3
             */
            typedef reg_t<0x40013418, 0x00000001, 16, rw_t> OC1M_3;
            /*
                Output Compare 2 mode bit
              3
             */
            typedef reg_t<0x40013418, 0x00000001, 24, rw_t> OC2M_3;
        };
        /*
            capture/compare mode register 1 (input
          mode)
         */
        namespace CCMR1_Input {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013418, 0xffffffff, 0, rw_t> CCMR1_Input_REG;
            /*
                Input capture 2 filter
             */
            typedef reg_t<0x40013418, 0x0000000f, 12, rw_t> IC2F;
            /*
                Input capture 2 prescaler
             */
            typedef reg_t<0x40013418, 0x00000003, 10, rw_t> IC2PCS;
            /*
                Capture/Compare 2
              selection
             */
            typedef reg_t<0x40013418, 0x00000003, 8, rw_t> CC2S;
            /*
                Input capture 1 filter
             */
            typedef reg_t<0x40013418, 0x0000000f, 4, rw_t> IC1F;
            /*
                Input capture 1 prescaler
             */
            typedef reg_t<0x40013418, 0x00000003, 2, rw_t> IC1PCS;
            /*
                Capture/Compare 1
              selection
             */
            typedef reg_t<0x40013418, 0x00000003, 0, rw_t> CC1S;
        };
        /*
            capture/compare mode register (output
          mode)
         */
        namespace CCMR2_Output {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001341c, 0xffffffff, 0, rw_t> CCMR2_Output_REG;
            /*
                Output compare 4 clear
              enable
             */
            typedef reg_t<0x4001341c, 0x00000001, 15, rw_t> OC4CE;
            /*
                Output compare 4 mode
             */
            typedef reg_t<0x4001341c, 0x00000007, 12, rw_t> OC4M;
            /*
                Output compare 4 preload
              enable
             */
            typedef reg_t<0x4001341c, 0x00000001, 11, rw_t> OC4PE;
            /*
                Output compare 4 fast
              enable
             */
            typedef reg_t<0x4001341c, 0x00000001, 10, rw_t> OC4FE;
            /*
                Capture/Compare 4
              selection
             */
            typedef reg_t<0x4001341c, 0x00000003, 8, rw_t> CC4S;
            /*
                Output compare 3 clear
              enable
             */
            typedef reg_t<0x4001341c, 0x00000001, 7, rw_t> OC3CE;
            /*
                Output compare 3 mode
             */
            typedef reg_t<0x4001341c, 0x00000007, 4, rw_t> OC3M;
            /*
                Output compare 3 preload
              enable
             */
            typedef reg_t<0x4001341c, 0x00000001, 3, rw_t> OC3PE;
            /*
                Output compare 3 fast
              enable
             */
            typedef reg_t<0x4001341c, 0x00000001, 2, rw_t> OC3FE;
            /*
                Capture/Compare 3
              selection
             */
            typedef reg_t<0x4001341c, 0x00000003, 0, rw_t> CC3S;
            /*
                Output Compare 3 mode bit
              3
             */
            typedef reg_t<0x4001341c, 0x00000001, 16, rw_t> OC3M_3;
            /*
                Output Compare 4 mode bit
              3
             */
            typedef reg_t<0x4001341c, 0x00000001, 24, rw_t> OC4M_3;
        };
        /*
            capture/compare mode register 2 (input
          mode)
         */
        namespace CCMR2_Input {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001341c, 0xffffffff, 0, rw_t> CCMR2_Input_REG;
            /*
                Input capture 4 filter
             */
            typedef reg_t<0x4001341c, 0x0000000f, 12, rw_t> IC4F;
            /*
                Input capture 4 prescaler
             */
            typedef reg_t<0x4001341c, 0x00000003, 10, rw_t> IC4PSC;
            /*
                Capture/Compare 4
              selection
             */
            typedef reg_t<0x4001341c, 0x00000003, 8, rw_t> CC4S;
            /*
                Input capture 3 filter
             */
            typedef reg_t<0x4001341c, 0x0000000f, 4, rw_t> IC3F;
            /*
                Input capture 3 prescaler
             */
            typedef reg_t<0x4001341c, 0x00000003, 2, rw_t> IC3PSC;
            /*
                Capture/compare 3
              selection
             */
            typedef reg_t<0x4001341c, 0x00000003, 0, rw_t> CC3S;
        };
        /*
            capture/compare enable
          register
         */
        namespace CCER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013420, 0xffffffff, 0, rw_t> CCER_REG;
            /*
                Capture/Compare 1 output
              enable
             */
            typedef reg_t<0x40013420, 0x00000001, 0, rw_t> CC1E;
            /*
                Capture/Compare 1 output
              Polarity
             */
            typedef reg_t<0x40013420, 0x00000001, 1, rw_t> CC1P;
            /*
                Capture/Compare 1 complementary output
              enable
             */
            typedef reg_t<0x40013420, 0x00000001, 2, rw_t> CC1NE;
            /*
                Capture/Compare 1 output
              Polarity
             */
            typedef reg_t<0x40013420, 0x00000001, 3, rw_t> CC1NP;
            /*
                Capture/Compare 2 output
              enable
             */
            typedef reg_t<0x40013420, 0x00000001, 4, rw_t> CC2E;
            /*
                Capture/Compare 2 output
              Polarity
             */
            typedef reg_t<0x40013420, 0x00000001, 5, rw_t> CC2P;
            /*
                Capture/Compare 2 complementary output
              enable
             */
            typedef reg_t<0x40013420, 0x00000001, 6, rw_t> CC2NE;
            /*
                Capture/Compare 2 output
              Polarity
             */
            typedef reg_t<0x40013420, 0x00000001, 7, rw_t> CC2NP;
            /*
                Capture/Compare 3 output
              enable
             */
            typedef reg_t<0x40013420, 0x00000001, 8, rw_t> CC3E;
            /*
                Capture/Compare 3 output
              Polarity
             */
            typedef reg_t<0x40013420, 0x00000001, 9, rw_t> CC3P;
            /*
                Capture/Compare 3 complementary output
              enable
             */
            typedef reg_t<0x40013420, 0x00000001, 10, rw_t> CC3NE;
            /*
                Capture/Compare 3 output
              Polarity
             */
            typedef reg_t<0x40013420, 0x00000001, 11, rw_t> CC3NP;
            /*
                Capture/Compare 4 output
              enable
             */
            typedef reg_t<0x40013420, 0x00000001, 12, rw_t> CC4E;
            /*
                Capture/Compare 3 output
              Polarity
             */
            typedef reg_t<0x40013420, 0x00000001, 13, rw_t> CC4P;
            /*
                Capture/Compare 4 output
              Polarity
             */
            typedef reg_t<0x40013420, 0x00000001, 15, rw_t> CC4NP;
            /*
                Capture/Compare 5 output
              enable
             */
            typedef reg_t<0x40013420, 0x00000001, 16, rw_t> CC5E;
            /*
                Capture/Compare 5 output
              Polarity
             */
            typedef reg_t<0x40013420, 0x00000001, 17, rw_t> CC5P;
            /*
                Capture/Compare 6 output
              enable
             */
            typedef reg_t<0x40013420, 0x00000001, 20, rw_t> CC6E;
            /*
                Capture/Compare 6 output
              Polarity
             */
            typedef reg_t<0x40013420, 0x00000001, 21, rw_t> CC6P;
        };
        /*
            counter
         */
        namespace CNT {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                counter value
             */
            typedef reg_t<0x40013424, 0x0000ffff, 0, rw_t> CNT;
            /*
                UIF copy
             */
            typedef reg_t<0x40013424, 0x00000001, 31, ro_t> UIFCPY;
        };
        /*
            prescaler
         */
        namespace PSC {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013428, 0xffffffff, 0, rw_t> PSC_REG;
            /*
                Prescaler value
             */
            typedef reg_t<0x40013428, 0x0000ffff, 0, rw_t> PSC;
        };
        /*
            auto-reload register
         */
        namespace ARR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001342c, 0xffffffff, 0, rw_t> ARR_REG;
            /*
                Auto-reload value
             */
            typedef reg_t<0x4001342c, 0x0000ffff, 0, rw_t> ARR;
        };
        /*
            repetition counter register
         */
        namespace RCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013430, 0xffffffff, 0, rw_t> RCR_REG;
            /*
                Repetition counter value
             */
            typedef reg_t<0x40013430, 0x0000ffff, 0, rw_t> REP;
        };
        /*
            capture/compare register 1
         */
        namespace CCR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013434, 0xffffffff, 0, rw_t> CCR1_REG;
            /*
                Capture/Compare 1 value
             */
            typedef reg_t<0x40013434, 0x0000ffff, 0, rw_t> CCR1;
        };
        /*
            capture/compare register 2
         */
        namespace CCR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013438, 0xffffffff, 0, rw_t> CCR2_REG;
            /*
                Capture/Compare 2 value
             */
            typedef reg_t<0x40013438, 0x0000ffff, 0, rw_t> CCR2;
        };
        /*
            capture/compare register 3
         */
        namespace CCR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001343c, 0xffffffff, 0, rw_t> CCR3_REG;
            /*
                Capture/Compare 3 value
             */
            typedef reg_t<0x4001343c, 0x0000ffff, 0, rw_t> CCR3;
        };
        /*
            capture/compare register 4
         */
        namespace CCR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013440, 0xffffffff, 0, rw_t> CCR4_REG;
            /*
                Capture/Compare 3 value
             */
            typedef reg_t<0x40013440, 0x0000ffff, 0, rw_t> CCR4;
        };
        /*
            break and dead-time register
         */
        namespace BDTR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013444, 0xffffffff, 0, rw_t> BDTR_REG;
            /*
                Dead-time generator setup
             */
            typedef reg_t<0x40013444, 0x000000ff, 0, rw_t> DTG;
            /*
                Lock configuration
             */
            typedef reg_t<0x40013444, 0x00000003, 8, rw_t> LOCK;
            /*
                Off-state selection for Idle
              mode
             */
            typedef reg_t<0x40013444, 0x00000001, 10, rw_t> OSSI;
            /*
                Off-state selection for Run
              mode
             */
            typedef reg_t<0x40013444, 0x00000001, 11, rw_t> OSSR;
            /*
                Break enable
             */
            typedef reg_t<0x40013444, 0x00000001, 12, rw_t> BKE;
            /*
                Break polarity
             */
            typedef reg_t<0x40013444, 0x00000001, 13, rw_t> BKP;
            /*
                Automatic output enable
             */
            typedef reg_t<0x40013444, 0x00000001, 14, rw_t> AOE;
            /*
                Main output enable
             */
            typedef reg_t<0x40013444, 0x00000001, 15, rw_t> MOE;
            /*
                Break filter
             */
            typedef reg_t<0x40013444, 0x0000000f, 16, rw_t> BKF;
            /*
                Break 2 filter
             */
            typedef reg_t<0x40013444, 0x0000000f, 20, rw_t> BK2F;
            /*
                Break 2 enable
             */
            typedef reg_t<0x40013444, 0x00000001, 24, rw_t> BK2E;
            /*
                Break 2 polarity
             */
            typedef reg_t<0x40013444, 0x00000001, 25, rw_t> BK2P;
        };
        /*
            DMA control register
         */
        namespace DCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013448, 0xffffffff, 0, rw_t> DCR_REG;
            /*
                DMA burst length
             */
            typedef reg_t<0x40013448, 0x0000001f, 8, rw_t> DBL;
            /*
                DMA base address
             */
            typedef reg_t<0x40013448, 0x0000001f, 0, rw_t> DBA;
        };
        /*
            DMA address for full transfer
         */
        namespace DMAR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001344c, 0xffffffff, 0, rw_t> DMAR_REG;
            /*
                DMA register for burst
              accesses
             */
            typedef reg_t<0x4001344c, 0x0000ffff, 0, rw_t> DMAB;
        };
        /*
            capture/compare mode register 3 (output
          mode)
         */
        namespace CCMR3_Output {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013454, 0xffffffff, 0, rw_t> CCMR3_Output_REG;
            /*
                Output compare 5 fast
              enable
             */
            typedef reg_t<0x40013454, 0x00000001, 2, rw_t> OC5FE;
            /*
                Output compare 5 preload
              enable
             */
            typedef reg_t<0x40013454, 0x00000001, 3, rw_t> OC5PE;
            /*
                Output compare 5 mode
             */
            typedef reg_t<0x40013454, 0x00000007, 4, rw_t> OC5M;
            /*
                Output compare 5 clear
              enable
             */
            typedef reg_t<0x40013454, 0x00000001, 7, rw_t> OC5CE;
            /*
                Output compare 6 fast
              enable
             */
            typedef reg_t<0x40013454, 0x00000001, 10, rw_t> OC6FE;
            /*
                Output compare 6 preload
              enable
             */
            typedef reg_t<0x40013454, 0x00000001, 11, rw_t> OC6PE;
            /*
                Output compare 6 mode
             */
            typedef reg_t<0x40013454, 0x00000007, 12, rw_t> OC6M;
            /*
                Output compare 6 clear
              enable
             */
            typedef reg_t<0x40013454, 0x00000001, 15, rw_t> OC6CE;
            /*
                Outout Compare 5 mode bit
              3
             */
            typedef reg_t<0x40013454, 0x00000001, 16, rw_t> OC5M_3;
            /*
                Outout Compare 6 mode bit
              3
             */
            typedef reg_t<0x40013454, 0x00000001, 24, rw_t> OC6M_3;
        };
        /*
            capture/compare register 5
         */
        namespace CCR5 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013458, 0xffffffff, 0, rw_t> CCR5_REG;
            /*
                Capture/Compare 5 value
             */
            typedef reg_t<0x40013458, 0x0000ffff, 0, rw_t> CCR5;
            /*
                Group Channel 5 and Channel
              1
             */
            typedef reg_t<0x40013458, 0x00000001, 29, rw_t> GC5C1;
            /*
                Group Channel 5 and Channel
              2
             */
            typedef reg_t<0x40013458, 0x00000001, 30, rw_t> GC5C2;
            /*
                Group Channel 5 and Channel
              3
             */
            typedef reg_t<0x40013458, 0x00000001, 31, rw_t> GC5C3;
        };
        /*
            capture/compare register 6
         */
        namespace CCR6 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001345c, 0xffffffff, 0, rw_t> CCR6_REG;
            /*
                Capture/Compare 6 value
             */
            typedef reg_t<0x4001345c, 0x0000ffff, 0, rw_t> CCR6;
        };
        /*
            option registers
         */
        namespace OR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40013460, 0xffffffff, 0, rw_t> OR_REG;
            /*
                TIM8_ETR_ADC2 remapping
              capability
             */
            typedef reg_t<0x40013460, 0x00000003, 0, rw_t> TIM8_ETR_ADC2_RMP;
            /*
                TIM8_ETR_ADC3 remapping
              capability
             */
            typedef reg_t<0x40013460, 0x00000003, 2, rw_t> TIM8_ETR_ADC3_RMP;
        };
    };
    /*
        Analog-to-Digital Converter
     */
    namespace ADC1 {
        /*
            interrupt and status register
         */
        namespace ISR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000000, 0xffffffff, 0, rw_t> ISR_REG;
            /*
                JQOVF
             */
            typedef reg_t<0x50000000, 0x00000001, 10, rw_t> JQOVF;
            /*
                AWD3
             */
            typedef reg_t<0x50000000, 0x00000001, 9, rw_t> AWD3;
            /*
                AWD2
             */
            typedef reg_t<0x50000000, 0x00000001, 8, rw_t> AWD2;
            /*
                AWD1
             */
            typedef reg_t<0x50000000, 0x00000001, 7, rw_t> AWD1;
            /*
                JEOS
             */
            typedef reg_t<0x50000000, 0x00000001, 6, rw_t> JEOS;
            /*
                JEOC
             */
            typedef reg_t<0x50000000, 0x00000001, 5, rw_t> JEOC;
            /*
                OVR
             */
            typedef reg_t<0x50000000, 0x00000001, 4, rw_t> OVR;
            /*
                EOS
             */
            typedef reg_t<0x50000000, 0x00000001, 3, rw_t> EOS;
            /*
                EOC
             */
            typedef reg_t<0x50000000, 0x00000001, 2, rw_t> EOC;
            /*
                EOSMP
             */
            typedef reg_t<0x50000000, 0x00000001, 1, rw_t> EOSMP;
            /*
                ADRDY
             */
            typedef reg_t<0x50000000, 0x00000001, 0, rw_t> ADRDY;
        };
        /*
            interrupt enable register
         */
        namespace IER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000004, 0xffffffff, 0, rw_t> IER_REG;
            /*
                JQOVFIE
             */
            typedef reg_t<0x50000004, 0x00000001, 10, rw_t> JQOVFIE;
            /*
                AWD3IE
             */
            typedef reg_t<0x50000004, 0x00000001, 9, rw_t> AWD3IE;
            /*
                AWD2IE
             */
            typedef reg_t<0x50000004, 0x00000001, 8, rw_t> AWD2IE;
            /*
                AWD1IE
             */
            typedef reg_t<0x50000004, 0x00000001, 7, rw_t> AWD1IE;
            /*
                JEOSIE
             */
            typedef reg_t<0x50000004, 0x00000001, 6, rw_t> JEOSIE;
            /*
                JEOCIE
             */
            typedef reg_t<0x50000004, 0x00000001, 5, rw_t> JEOCIE;
            /*
                OVRIE
             */
            typedef reg_t<0x50000004, 0x00000001, 4, rw_t> OVRIE;
            /*
                EOSIE
             */
            typedef reg_t<0x50000004, 0x00000001, 3, rw_t> EOSIE;
            /*
                EOCIE
             */
            typedef reg_t<0x50000004, 0x00000001, 2, rw_t> EOCIE;
            /*
                EOSMPIE
             */
            typedef reg_t<0x50000004, 0x00000001, 1, rw_t> EOSMPIE;
            /*
                ADRDYIE
             */
            typedef reg_t<0x50000004, 0x00000001, 0, rw_t> ADRDYIE;
        };
        /*
            control register
         */
        namespace CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000008, 0xffffffff, 0, rw_t> CR_REG;
            /*
                ADCAL
             */
            typedef reg_t<0x50000008, 0x00000001, 31, rw_t> ADCAL;
            /*
                ADCALDIF
             */
            typedef reg_t<0x50000008, 0x00000001, 30, rw_t> ADCALDIF;
            /*
                DEEPPWD
             */
            typedef reg_t<0x50000008, 0x00000001, 29, rw_t> DEEPPWD;
            /*
                ADVREGEN
             */
            typedef reg_t<0x50000008, 0x00000001, 28, rw_t> ADVREGEN;
            /*
                JADSTP
             */
            typedef reg_t<0x50000008, 0x00000001, 5, rw_t> JADSTP;
            /*
                ADSTP
             */
            typedef reg_t<0x50000008, 0x00000001, 4, rw_t> ADSTP;
            /*
                JADSTART
             */
            typedef reg_t<0x50000008, 0x00000001, 3, rw_t> JADSTART;
            /*
                ADSTART
             */
            typedef reg_t<0x50000008, 0x00000001, 2, rw_t> ADSTART;
            /*
                ADDIS
             */
            typedef reg_t<0x50000008, 0x00000001, 1, rw_t> ADDIS;
            /*
                ADEN
             */
            typedef reg_t<0x50000008, 0x00000001, 0, rw_t> ADEN;
        };
        /*
            configuration register
         */
        namespace CFGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x5000000c, 0xffffffff, 0, rw_t> CFGR_REG;
            /*
                AWDCH1CH
             */
            typedef reg_t<0x5000000c, 0x0000001f, 26, rw_t> AWDCH1CH;
            /*
                JAUTO
             */
            typedef reg_t<0x5000000c, 0x00000001, 25, rw_t> JAUTO;
            /*
                JAWD1EN
             */
            typedef reg_t<0x5000000c, 0x00000001, 24, rw_t> JAWD1EN;
            /*
                AWD1EN
             */
            typedef reg_t<0x5000000c, 0x00000001, 23, rw_t> AWD1EN;
            /*
                AWD1SGL
             */
            typedef reg_t<0x5000000c, 0x00000001, 22, rw_t> AWD1SGL;
            /*
                JQM
             */
            typedef reg_t<0x5000000c, 0x00000001, 21, rw_t> JQM;
            /*
                JDISCEN
             */
            typedef reg_t<0x5000000c, 0x00000001, 20, rw_t> JDISCEN;
            /*
                DISCNUM
             */
            typedef reg_t<0x5000000c, 0x00000007, 17, rw_t> DISCNUM;
            /*
                DISCEN
             */
            typedef reg_t<0x5000000c, 0x00000001, 16, rw_t> DISCEN;
            /*
                AUTOFF
             */
            typedef reg_t<0x5000000c, 0x00000001, 15, rw_t> AUTOFF;
            /*
                AUTDLY
             */
            typedef reg_t<0x5000000c, 0x00000001, 14, rw_t> AUTDLY;
            /*
                CONT
             */
            typedef reg_t<0x5000000c, 0x00000001, 13, rw_t> CONT;
            /*
                OVRMOD
             */
            typedef reg_t<0x5000000c, 0x00000001, 12, rw_t> OVRMOD;
            /*
                EXTEN
             */
            typedef reg_t<0x5000000c, 0x00000003, 10, rw_t> EXTEN;
            /*
                EXTSEL
             */
            typedef reg_t<0x5000000c, 0x0000000f, 6, rw_t> EXTSEL;
            /*
                ALIGN
             */
            typedef reg_t<0x5000000c, 0x00000001, 5, rw_t> ALIGN;
            /*
                RES
             */
            typedef reg_t<0x5000000c, 0x00000003, 3, rw_t> RES;
            /*
                DMACFG
             */
            typedef reg_t<0x5000000c, 0x00000001, 1, rw_t> DMACFG;
            /*
                DMAEN
             */
            typedef reg_t<0x5000000c, 0x00000001, 0, rw_t> DMAEN;
        };
        /*
            sample time register 1
         */
        namespace SMPR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000014, 0xffffffff, 0, rw_t> SMPR1_REG;
            /*
                SMP9
             */
            typedef reg_t<0x50000014, 0x00000007, 27, rw_t> SMP9;
            /*
                SMP8
             */
            typedef reg_t<0x50000014, 0x00000007, 24, rw_t> SMP8;
            /*
                SMP7
             */
            typedef reg_t<0x50000014, 0x00000007, 21, rw_t> SMP7;
            /*
                SMP6
             */
            typedef reg_t<0x50000014, 0x00000007, 18, rw_t> SMP6;
            /*
                SMP5
             */
            typedef reg_t<0x50000014, 0x00000007, 15, rw_t> SMP5;
            /*
                SMP4
             */
            typedef reg_t<0x50000014, 0x00000007, 12, rw_t> SMP4;
            /*
                SMP3
             */
            typedef reg_t<0x50000014, 0x00000007, 9, rw_t> SMP3;
            /*
                SMP2
             */
            typedef reg_t<0x50000014, 0x00000007, 6, rw_t> SMP2;
            /*
                SMP1
             */
            typedef reg_t<0x50000014, 0x00000007, 3, rw_t> SMP1;
        };
        /*
            sample time register 2
         */
        namespace SMPR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000018, 0xffffffff, 0, rw_t> SMPR2_REG;
            /*
                SMP18
             */
            typedef reg_t<0x50000018, 0x00000007, 24, rw_t> SMP18;
            /*
                SMP17
             */
            typedef reg_t<0x50000018, 0x00000007, 21, rw_t> SMP17;
            /*
                SMP16
             */
            typedef reg_t<0x50000018, 0x00000007, 18, rw_t> SMP16;
            /*
                SMP15
             */
            typedef reg_t<0x50000018, 0x00000007, 15, rw_t> SMP15;
            /*
                SMP14
             */
            typedef reg_t<0x50000018, 0x00000007, 12, rw_t> SMP14;
            /*
                SMP13
             */
            typedef reg_t<0x50000018, 0x00000007, 9, rw_t> SMP13;
            /*
                SMP12
             */
            typedef reg_t<0x50000018, 0x00000007, 6, rw_t> SMP12;
            /*
                SMP11
             */
            typedef reg_t<0x50000018, 0x00000007, 3, rw_t> SMP11;
            /*
                SMP10
             */
            typedef reg_t<0x50000018, 0x00000007, 0, rw_t> SMP10;
        };
        /*
            watchdog threshold register 1
         */
        namespace TR1 {

            static constexpr uint32_t RESETVALUE = 0x0fff0000;
            typedef reg_t<0x50000020, 0xffffffff, 0, rw_t> TR1_REG;
            /*
                HT1
             */
            typedef reg_t<0x50000020, 0x00000fff, 16, rw_t> HT1;
            /*
                LT1
             */
            typedef reg_t<0x50000020, 0x00000fff, 0, rw_t> LT1;
        };
        /*
            watchdog threshold register
         */
        namespace TR2 {

            static constexpr uint32_t RESETVALUE = 0x0fff0000;
            typedef reg_t<0x50000024, 0xffffffff, 0, rw_t> TR2_REG;
            /*
                HT2
             */
            typedef reg_t<0x50000024, 0x000000ff, 16, rw_t> HT2;
            /*
                LT2
             */
            typedef reg_t<0x50000024, 0x000000ff, 0, rw_t> LT2;
        };
        /*
            watchdog threshold register 3
         */
        namespace TR3 {

            static constexpr uint32_t RESETVALUE = 0x0fff0000;
            typedef reg_t<0x50000028, 0xffffffff, 0, rw_t> TR3_REG;
            /*
                HT3
             */
            typedef reg_t<0x50000028, 0x000000ff, 16, rw_t> HT3;
            /*
                LT3
             */
            typedef reg_t<0x50000028, 0x000000ff, 0, rw_t> LT3;
        };
        /*
            regular sequence register 1
         */
        namespace SQR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000030, 0xffffffff, 0, rw_t> SQR1_REG;
            /*
                SQ4
             */
            typedef reg_t<0x50000030, 0x0000001f, 24, rw_t> SQ4;
            /*
                SQ3
             */
            typedef reg_t<0x50000030, 0x0000001f, 18, rw_t> SQ3;
            /*
                SQ2
             */
            typedef reg_t<0x50000030, 0x0000001f, 12, rw_t> SQ2;
            /*
                SQ1
             */
            typedef reg_t<0x50000030, 0x0000001f, 6, rw_t> SQ1;
            /*
                L3
             */
            typedef reg_t<0x50000030, 0x0000000f, 0, rw_t> L3;
        };
        /*
            regular sequence register 2
         */
        namespace SQR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000034, 0xffffffff, 0, rw_t> SQR2_REG;
            /*
                SQ9
             */
            typedef reg_t<0x50000034, 0x0000001f, 24, rw_t> SQ9;
            /*
                SQ8
             */
            typedef reg_t<0x50000034, 0x0000001f, 18, rw_t> SQ8;
            /*
                SQ7
             */
            typedef reg_t<0x50000034, 0x0000001f, 12, rw_t> SQ7;
            /*
                SQ6
             */
            typedef reg_t<0x50000034, 0x0000001f, 6, rw_t> SQ6;
            /*
                SQ5
             */
            typedef reg_t<0x50000034, 0x0000001f, 0, rw_t> SQ5;
        };
        /*
            regular sequence register 3
         */
        namespace SQR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000038, 0xffffffff, 0, rw_t> SQR3_REG;
            /*
                SQ14
             */
            typedef reg_t<0x50000038, 0x0000001f, 24, rw_t> SQ14;
            /*
                SQ13
             */
            typedef reg_t<0x50000038, 0x0000001f, 18, rw_t> SQ13;
            /*
                SQ12
             */
            typedef reg_t<0x50000038, 0x0000001f, 12, rw_t> SQ12;
            /*
                SQ11
             */
            typedef reg_t<0x50000038, 0x0000001f, 6, rw_t> SQ11;
            /*
                SQ10
             */
            typedef reg_t<0x50000038, 0x0000001f, 0, rw_t> SQ10;
        };
        /*
            regular sequence register 4
         */
        namespace SQR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x5000003c, 0xffffffff, 0, rw_t> SQR4_REG;
            /*
                SQ16
             */
            typedef reg_t<0x5000003c, 0x0000001f, 6, rw_t> SQ16;
            /*
                SQ15
             */
            typedef reg_t<0x5000003c, 0x0000001f, 0, rw_t> SQ15;
        };
        /*
            regular Data Register
         */
        namespace DR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000040, 0xffffffff, 0, ro_t> DR_REG;
            /*
                regularDATA
             */
            typedef reg_t<0x50000040, 0x0000ffff, 0, ro_t> regularDATA;
        };
        /*
            injected sequence register
         */
        namespace JSQR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x5000004c, 0xffffffff, 0, rw_t> JSQR_REG;
            /*
                JSQ4
             */
            typedef reg_t<0x5000004c, 0x0000001f, 26, rw_t> JSQ4;
            /*
                JSQ3
             */
            typedef reg_t<0x5000004c, 0x0000001f, 20, rw_t> JSQ3;
            /*
                JSQ2
             */
            typedef reg_t<0x5000004c, 0x0000001f, 14, rw_t> JSQ2;
            /*
                JSQ1
             */
            typedef reg_t<0x5000004c, 0x0000001f, 8, rw_t> JSQ1;
            /*
                JEXTEN
             */
            typedef reg_t<0x5000004c, 0x00000003, 6, rw_t> JEXTEN;
            /*
                JEXTSEL
             */
            typedef reg_t<0x5000004c, 0x0000000f, 2, rw_t> JEXTSEL;
            /*
                JL
             */
            typedef reg_t<0x5000004c, 0x00000003, 0, rw_t> JL;
        };
        /*
            offset register 1
         */
        namespace OFR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000060, 0xffffffff, 0, rw_t> OFR1_REG;
            /*
                OFFSET1_EN
             */
            typedef reg_t<0x50000060, 0x00000001, 31, rw_t> OFFSET1_EN;
            /*
                OFFSET1_CH
             */
            typedef reg_t<0x50000060, 0x0000001f, 26, rw_t> OFFSET1_CH;
            /*
                OFFSET1
             */
            typedef reg_t<0x50000060, 0x00000fff, 0, rw_t> OFFSET1;
        };
        /*
            offset register 2
         */
        namespace OFR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000064, 0xffffffff, 0, rw_t> OFR2_REG;
            /*
                OFFSET2_EN
             */
            typedef reg_t<0x50000064, 0x00000001, 31, rw_t> OFFSET2_EN;
            /*
                OFFSET2_CH
             */
            typedef reg_t<0x50000064, 0x0000001f, 26, rw_t> OFFSET2_CH;
            /*
                OFFSET2
             */
            typedef reg_t<0x50000064, 0x00000fff, 0, rw_t> OFFSET2;
        };
        /*
            offset register 3
         */
        namespace OFR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000068, 0xffffffff, 0, rw_t> OFR3_REG;
            /*
                OFFSET3_EN
             */
            typedef reg_t<0x50000068, 0x00000001, 31, rw_t> OFFSET3_EN;
            /*
                OFFSET3_CH
             */
            typedef reg_t<0x50000068, 0x0000001f, 26, rw_t> OFFSET3_CH;
            /*
                OFFSET3
             */
            typedef reg_t<0x50000068, 0x00000fff, 0, rw_t> OFFSET3;
        };
        /*
            offset register 4
         */
        namespace OFR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x5000006c, 0xffffffff, 0, rw_t> OFR4_REG;
            /*
                OFFSET4_EN
             */
            typedef reg_t<0x5000006c, 0x00000001, 31, rw_t> OFFSET4_EN;
            /*
                OFFSET4_CH
             */
            typedef reg_t<0x5000006c, 0x0000001f, 26, rw_t> OFFSET4_CH;
            /*
                OFFSET4
             */
            typedef reg_t<0x5000006c, 0x00000fff, 0, rw_t> OFFSET4;
        };
        /*
            injected data register 1
         */
        namespace JDR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000080, 0xffffffff, 0, ro_t> JDR1_REG;
            /*
                JDATA1
             */
            typedef reg_t<0x50000080, 0x0000ffff, 0, ro_t> JDATA1;
        };
        /*
            injected data register 2
         */
        namespace JDR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000084, 0xffffffff, 0, ro_t> JDR2_REG;
            /*
                JDATA2
             */
            typedef reg_t<0x50000084, 0x0000ffff, 0, ro_t> JDATA2;
        };
        /*
            injected data register 3
         */
        namespace JDR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000088, 0xffffffff, 0, ro_t> JDR3_REG;
            /*
                JDATA3
             */
            typedef reg_t<0x50000088, 0x0000ffff, 0, ro_t> JDATA3;
        };
        /*
            injected data register 4
         */
        namespace JDR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x5000008c, 0xffffffff, 0, ro_t> JDR4_REG;
            /*
                JDATA4
             */
            typedef reg_t<0x5000008c, 0x0000ffff, 0, ro_t> JDATA4;
        };
        /*
            Analog Watchdog 2 Configuration
          Register
         */
        namespace AWD2CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x500000a0, 0xffffffff, 0, rw_t> AWD2CR_REG;
            /*
                AWD2CH
             */
            typedef reg_t<0x500000a0, 0x0003ffff, 1, rw_t> AWD2CH;
        };
        /*
            Analog Watchdog 3 Configuration
          Register
         */
        namespace AWD3CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x500000a4, 0xffffffff, 0, rw_t> AWD3CR_REG;
            /*
                AWD3CH
             */
            typedef reg_t<0x500000a4, 0x0003ffff, 1, rw_t> AWD3CH;
        };
        /*
            Differential Mode Selection Register
          2
         */
        namespace DIFSEL {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Differential mode for channels 15 to
              1
             */
            typedef reg_t<0x500000b0, 0x00007fff, 1, rw_t> DIFSEL_1_15;
            /*
                Differential mode for channels 18 to
              16
             */
            typedef reg_t<0x500000b0, 0x00000007, 16, ro_t> DIFSEL_16_18;
        };
        /*
            Calibration Factors
         */
        namespace CALFACT {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x500000b4, 0xffffffff, 0, rw_t> CALFACT_REG;
            /*
                CALFACT_D
             */
            typedef reg_t<0x500000b4, 0x0000007f, 16, rw_t> CALFACT_D;
            /*
                CALFACT_S
             */
            typedef reg_t<0x500000b4, 0x0000007f, 0, rw_t> CALFACT_S;
        };
    };
    /*
        Analog-to-Digital Converter
     */
    namespace ADC2 {
        /*
            interrupt and status register
         */
        namespace ISR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000100, 0xffffffff, 0, rw_t> ISR_REG;
            /*
                JQOVF
             */
            typedef reg_t<0x50000100, 0x00000001, 10, rw_t> JQOVF;
            /*
                AWD3
             */
            typedef reg_t<0x50000100, 0x00000001, 9, rw_t> AWD3;
            /*
                AWD2
             */
            typedef reg_t<0x50000100, 0x00000001, 8, rw_t> AWD2;
            /*
                AWD1
             */
            typedef reg_t<0x50000100, 0x00000001, 7, rw_t> AWD1;
            /*
                JEOS
             */
            typedef reg_t<0x50000100, 0x00000001, 6, rw_t> JEOS;
            /*
                JEOC
             */
            typedef reg_t<0x50000100, 0x00000001, 5, rw_t> JEOC;
            /*
                OVR
             */
            typedef reg_t<0x50000100, 0x00000001, 4, rw_t> OVR;
            /*
                EOS
             */
            typedef reg_t<0x50000100, 0x00000001, 3, rw_t> EOS;
            /*
                EOC
             */
            typedef reg_t<0x50000100, 0x00000001, 2, rw_t> EOC;
            /*
                EOSMP
             */
            typedef reg_t<0x50000100, 0x00000001, 1, rw_t> EOSMP;
            /*
                ADRDY
             */
            typedef reg_t<0x50000100, 0x00000001, 0, rw_t> ADRDY;
        };
        /*
            interrupt enable register
         */
        namespace IER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000104, 0xffffffff, 0, rw_t> IER_REG;
            /*
                JQOVFIE
             */
            typedef reg_t<0x50000104, 0x00000001, 10, rw_t> JQOVFIE;
            /*
                AWD3IE
             */
            typedef reg_t<0x50000104, 0x00000001, 9, rw_t> AWD3IE;
            /*
                AWD2IE
             */
            typedef reg_t<0x50000104, 0x00000001, 8, rw_t> AWD2IE;
            /*
                AWD1IE
             */
            typedef reg_t<0x50000104, 0x00000001, 7, rw_t> AWD1IE;
            /*
                JEOSIE
             */
            typedef reg_t<0x50000104, 0x00000001, 6, rw_t> JEOSIE;
            /*
                JEOCIE
             */
            typedef reg_t<0x50000104, 0x00000001, 5, rw_t> JEOCIE;
            /*
                OVRIE
             */
            typedef reg_t<0x50000104, 0x00000001, 4, rw_t> OVRIE;
            /*
                EOSIE
             */
            typedef reg_t<0x50000104, 0x00000001, 3, rw_t> EOSIE;
            /*
                EOCIE
             */
            typedef reg_t<0x50000104, 0x00000001, 2, rw_t> EOCIE;
            /*
                EOSMPIE
             */
            typedef reg_t<0x50000104, 0x00000001, 1, rw_t> EOSMPIE;
            /*
                ADRDYIE
             */
            typedef reg_t<0x50000104, 0x00000001, 0, rw_t> ADRDYIE;
        };
        /*
            control register
         */
        namespace CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000108, 0xffffffff, 0, rw_t> CR_REG;
            /*
                ADCAL
             */
            typedef reg_t<0x50000108, 0x00000001, 31, rw_t> ADCAL;
            /*
                ADCALDIF
             */
            typedef reg_t<0x50000108, 0x00000001, 30, rw_t> ADCALDIF;
            /*
                DEEPPWD
             */
            typedef reg_t<0x50000108, 0x00000001, 29, rw_t> DEEPPWD;
            /*
                ADVREGEN
             */
            typedef reg_t<0x50000108, 0x00000001, 28, rw_t> ADVREGEN;
            /*
                JADSTP
             */
            typedef reg_t<0x50000108, 0x00000001, 5, rw_t> JADSTP;
            /*
                ADSTP
             */
            typedef reg_t<0x50000108, 0x00000001, 4, rw_t> ADSTP;
            /*
                JADSTART
             */
            typedef reg_t<0x50000108, 0x00000001, 3, rw_t> JADSTART;
            /*
                ADSTART
             */
            typedef reg_t<0x50000108, 0x00000001, 2, rw_t> ADSTART;
            /*
                ADDIS
             */
            typedef reg_t<0x50000108, 0x00000001, 1, rw_t> ADDIS;
            /*
                ADEN
             */
            typedef reg_t<0x50000108, 0x00000001, 0, rw_t> ADEN;
        };
        /*
            configuration register
         */
        namespace CFGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x5000010c, 0xffffffff, 0, rw_t> CFGR_REG;
            /*
                AWDCH1CH
             */
            typedef reg_t<0x5000010c, 0x0000001f, 26, rw_t> AWDCH1CH;
            /*
                JAUTO
             */
            typedef reg_t<0x5000010c, 0x00000001, 25, rw_t> JAUTO;
            /*
                JAWD1EN
             */
            typedef reg_t<0x5000010c, 0x00000001, 24, rw_t> JAWD1EN;
            /*
                AWD1EN
             */
            typedef reg_t<0x5000010c, 0x00000001, 23, rw_t> AWD1EN;
            /*
                AWD1SGL
             */
            typedef reg_t<0x5000010c, 0x00000001, 22, rw_t> AWD1SGL;
            /*
                JQM
             */
            typedef reg_t<0x5000010c, 0x00000001, 21, rw_t> JQM;
            /*
                JDISCEN
             */
            typedef reg_t<0x5000010c, 0x00000001, 20, rw_t> JDISCEN;
            /*
                DISCNUM
             */
            typedef reg_t<0x5000010c, 0x00000007, 17, rw_t> DISCNUM;
            /*
                DISCEN
             */
            typedef reg_t<0x5000010c, 0x00000001, 16, rw_t> DISCEN;
            /*
                AUTOFF
             */
            typedef reg_t<0x5000010c, 0x00000001, 15, rw_t> AUTOFF;
            /*
                AUTDLY
             */
            typedef reg_t<0x5000010c, 0x00000001, 14, rw_t> AUTDLY;
            /*
                CONT
             */
            typedef reg_t<0x5000010c, 0x00000001, 13, rw_t> CONT;
            /*
                OVRMOD
             */
            typedef reg_t<0x5000010c, 0x00000001, 12, rw_t> OVRMOD;
            /*
                EXTEN
             */
            typedef reg_t<0x5000010c, 0x00000003, 10, rw_t> EXTEN;
            /*
                EXTSEL
             */
            typedef reg_t<0x5000010c, 0x0000000f, 6, rw_t> EXTSEL;
            /*
                ALIGN
             */
            typedef reg_t<0x5000010c, 0x00000001, 5, rw_t> ALIGN;
            /*
                RES
             */
            typedef reg_t<0x5000010c, 0x00000003, 3, rw_t> RES;
            /*
                DMACFG
             */
            typedef reg_t<0x5000010c, 0x00000001, 1, rw_t> DMACFG;
            /*
                DMAEN
             */
            typedef reg_t<0x5000010c, 0x00000001, 0, rw_t> DMAEN;
        };
        /*
            sample time register 1
         */
        namespace SMPR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000114, 0xffffffff, 0, rw_t> SMPR1_REG;
            /*
                SMP9
             */
            typedef reg_t<0x50000114, 0x00000007, 27, rw_t> SMP9;
            /*
                SMP8
             */
            typedef reg_t<0x50000114, 0x00000007, 24, rw_t> SMP8;
            /*
                SMP7
             */
            typedef reg_t<0x50000114, 0x00000007, 21, rw_t> SMP7;
            /*
                SMP6
             */
            typedef reg_t<0x50000114, 0x00000007, 18, rw_t> SMP6;
            /*
                SMP5
             */
            typedef reg_t<0x50000114, 0x00000007, 15, rw_t> SMP5;
            /*
                SMP4
             */
            typedef reg_t<0x50000114, 0x00000007, 12, rw_t> SMP4;
            /*
                SMP3
             */
            typedef reg_t<0x50000114, 0x00000007, 9, rw_t> SMP3;
            /*
                SMP2
             */
            typedef reg_t<0x50000114, 0x00000007, 6, rw_t> SMP2;
            /*
                SMP1
             */
            typedef reg_t<0x50000114, 0x00000007, 3, rw_t> SMP1;
        };
        /*
            sample time register 2
         */
        namespace SMPR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000118, 0xffffffff, 0, rw_t> SMPR2_REG;
            /*
                SMP18
             */
            typedef reg_t<0x50000118, 0x00000007, 24, rw_t> SMP18;
            /*
                SMP17
             */
            typedef reg_t<0x50000118, 0x00000007, 21, rw_t> SMP17;
            /*
                SMP16
             */
            typedef reg_t<0x50000118, 0x00000007, 18, rw_t> SMP16;
            /*
                SMP15
             */
            typedef reg_t<0x50000118, 0x00000007, 15, rw_t> SMP15;
            /*
                SMP14
             */
            typedef reg_t<0x50000118, 0x00000007, 12, rw_t> SMP14;
            /*
                SMP13
             */
            typedef reg_t<0x50000118, 0x00000007, 9, rw_t> SMP13;
            /*
                SMP12
             */
            typedef reg_t<0x50000118, 0x00000007, 6, rw_t> SMP12;
            /*
                SMP11
             */
            typedef reg_t<0x50000118, 0x00000007, 3, rw_t> SMP11;
            /*
                SMP10
             */
            typedef reg_t<0x50000118, 0x00000007, 0, rw_t> SMP10;
        };
        /*
            watchdog threshold register 1
         */
        namespace TR1 {

            static constexpr uint32_t RESETVALUE = 0x0fff0000;
            typedef reg_t<0x50000120, 0xffffffff, 0, rw_t> TR1_REG;
            /*
                HT1
             */
            typedef reg_t<0x50000120, 0x00000fff, 16, rw_t> HT1;
            /*
                LT1
             */
            typedef reg_t<0x50000120, 0x00000fff, 0, rw_t> LT1;
        };
        /*
            watchdog threshold register
         */
        namespace TR2 {

            static constexpr uint32_t RESETVALUE = 0x0fff0000;
            typedef reg_t<0x50000124, 0xffffffff, 0, rw_t> TR2_REG;
            /*
                HT2
             */
            typedef reg_t<0x50000124, 0x000000ff, 16, rw_t> HT2;
            /*
                LT2
             */
            typedef reg_t<0x50000124, 0x000000ff, 0, rw_t> LT2;
        };
        /*
            watchdog threshold register 3
         */
        namespace TR3 {

            static constexpr uint32_t RESETVALUE = 0x0fff0000;
            typedef reg_t<0x50000128, 0xffffffff, 0, rw_t> TR3_REG;
            /*
                HT3
             */
            typedef reg_t<0x50000128, 0x000000ff, 16, rw_t> HT3;
            /*
                LT3
             */
            typedef reg_t<0x50000128, 0x000000ff, 0, rw_t> LT3;
        };
        /*
            regular sequence register 1
         */
        namespace SQR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000130, 0xffffffff, 0, rw_t> SQR1_REG;
            /*
                SQ4
             */
            typedef reg_t<0x50000130, 0x0000001f, 24, rw_t> SQ4;
            /*
                SQ3
             */
            typedef reg_t<0x50000130, 0x0000001f, 18, rw_t> SQ3;
            /*
                SQ2
             */
            typedef reg_t<0x50000130, 0x0000001f, 12, rw_t> SQ2;
            /*
                SQ1
             */
            typedef reg_t<0x50000130, 0x0000001f, 6, rw_t> SQ1;
            /*
                L3
             */
            typedef reg_t<0x50000130, 0x0000000f, 0, rw_t> L3;
        };
        /*
            regular sequence register 2
         */
        namespace SQR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000134, 0xffffffff, 0, rw_t> SQR2_REG;
            /*
                SQ9
             */
            typedef reg_t<0x50000134, 0x0000001f, 24, rw_t> SQ9;
            /*
                SQ8
             */
            typedef reg_t<0x50000134, 0x0000001f, 18, rw_t> SQ8;
            /*
                SQ7
             */
            typedef reg_t<0x50000134, 0x0000001f, 12, rw_t> SQ7;
            /*
                SQ6
             */
            typedef reg_t<0x50000134, 0x0000001f, 6, rw_t> SQ6;
            /*
                SQ5
             */
            typedef reg_t<0x50000134, 0x0000001f, 0, rw_t> SQ5;
        };
        /*
            regular sequence register 3
         */
        namespace SQR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000138, 0xffffffff, 0, rw_t> SQR3_REG;
            /*
                SQ14
             */
            typedef reg_t<0x50000138, 0x0000001f, 24, rw_t> SQ14;
            /*
                SQ13
             */
            typedef reg_t<0x50000138, 0x0000001f, 18, rw_t> SQ13;
            /*
                SQ12
             */
            typedef reg_t<0x50000138, 0x0000001f, 12, rw_t> SQ12;
            /*
                SQ11
             */
            typedef reg_t<0x50000138, 0x0000001f, 6, rw_t> SQ11;
            /*
                SQ10
             */
            typedef reg_t<0x50000138, 0x0000001f, 0, rw_t> SQ10;
        };
        /*
            regular sequence register 4
         */
        namespace SQR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x5000013c, 0xffffffff, 0, rw_t> SQR4_REG;
            /*
                SQ16
             */
            typedef reg_t<0x5000013c, 0x0000001f, 6, rw_t> SQ16;
            /*
                SQ15
             */
            typedef reg_t<0x5000013c, 0x0000001f, 0, rw_t> SQ15;
        };
        /*
            regular Data Register
         */
        namespace DR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000140, 0xffffffff, 0, ro_t> DR_REG;
            /*
                regularDATA
             */
            typedef reg_t<0x50000140, 0x0000ffff, 0, ro_t> regularDATA;
        };
        /*
            injected sequence register
         */
        namespace JSQR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x5000014c, 0xffffffff, 0, rw_t> JSQR_REG;
            /*
                JSQ4
             */
            typedef reg_t<0x5000014c, 0x0000001f, 26, rw_t> JSQ4;
            /*
                JSQ3
             */
            typedef reg_t<0x5000014c, 0x0000001f, 20, rw_t> JSQ3;
            /*
                JSQ2
             */
            typedef reg_t<0x5000014c, 0x0000001f, 14, rw_t> JSQ2;
            /*
                JSQ1
             */
            typedef reg_t<0x5000014c, 0x0000001f, 8, rw_t> JSQ1;
            /*
                JEXTEN
             */
            typedef reg_t<0x5000014c, 0x00000003, 6, rw_t> JEXTEN;
            /*
                JEXTSEL
             */
            typedef reg_t<0x5000014c, 0x0000000f, 2, rw_t> JEXTSEL;
            /*
                JL
             */
            typedef reg_t<0x5000014c, 0x00000003, 0, rw_t> JL;
        };
        /*
            offset register 1
         */
        namespace OFR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000160, 0xffffffff, 0, rw_t> OFR1_REG;
            /*
                OFFSET1_EN
             */
            typedef reg_t<0x50000160, 0x00000001, 31, rw_t> OFFSET1_EN;
            /*
                OFFSET1_CH
             */
            typedef reg_t<0x50000160, 0x0000001f, 26, rw_t> OFFSET1_CH;
            /*
                OFFSET1
             */
            typedef reg_t<0x50000160, 0x00000fff, 0, rw_t> OFFSET1;
        };
        /*
            offset register 2
         */
        namespace OFR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000164, 0xffffffff, 0, rw_t> OFR2_REG;
            /*
                OFFSET2_EN
             */
            typedef reg_t<0x50000164, 0x00000001, 31, rw_t> OFFSET2_EN;
            /*
                OFFSET2_CH
             */
            typedef reg_t<0x50000164, 0x0000001f, 26, rw_t> OFFSET2_CH;
            /*
                OFFSET2
             */
            typedef reg_t<0x50000164, 0x00000fff, 0, rw_t> OFFSET2;
        };
        /*
            offset register 3
         */
        namespace OFR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000168, 0xffffffff, 0, rw_t> OFR3_REG;
            /*
                OFFSET3_EN
             */
            typedef reg_t<0x50000168, 0x00000001, 31, rw_t> OFFSET3_EN;
            /*
                OFFSET3_CH
             */
            typedef reg_t<0x50000168, 0x0000001f, 26, rw_t> OFFSET3_CH;
            /*
                OFFSET3
             */
            typedef reg_t<0x50000168, 0x00000fff, 0, rw_t> OFFSET3;
        };
        /*
            offset register 4
         */
        namespace OFR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x5000016c, 0xffffffff, 0, rw_t> OFR4_REG;
            /*
                OFFSET4_EN
             */
            typedef reg_t<0x5000016c, 0x00000001, 31, rw_t> OFFSET4_EN;
            /*
                OFFSET4_CH
             */
            typedef reg_t<0x5000016c, 0x0000001f, 26, rw_t> OFFSET4_CH;
            /*
                OFFSET4
             */
            typedef reg_t<0x5000016c, 0x00000fff, 0, rw_t> OFFSET4;
        };
        /*
            injected data register 1
         */
        namespace JDR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000180, 0xffffffff, 0, ro_t> JDR1_REG;
            /*
                JDATA1
             */
            typedef reg_t<0x50000180, 0x0000ffff, 0, ro_t> JDATA1;
        };
        /*
            injected data register 2
         */
        namespace JDR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000184, 0xffffffff, 0, ro_t> JDR2_REG;
            /*
                JDATA2
             */
            typedef reg_t<0x50000184, 0x0000ffff, 0, ro_t> JDATA2;
        };
        /*
            injected data register 3
         */
        namespace JDR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000188, 0xffffffff, 0, ro_t> JDR3_REG;
            /*
                JDATA3
             */
            typedef reg_t<0x50000188, 0x0000ffff, 0, ro_t> JDATA3;
        };
        /*
            injected data register 4
         */
        namespace JDR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x5000018c, 0xffffffff, 0, ro_t> JDR4_REG;
            /*
                JDATA4
             */
            typedef reg_t<0x5000018c, 0x0000ffff, 0, ro_t> JDATA4;
        };
        /*
            Analog Watchdog 2 Configuration
          Register
         */
        namespace AWD2CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x500001a0, 0xffffffff, 0, rw_t> AWD2CR_REG;
            /*
                AWD2CH
             */
            typedef reg_t<0x500001a0, 0x0003ffff, 1, rw_t> AWD2CH;
        };
        /*
            Analog Watchdog 3 Configuration
          Register
         */
        namespace AWD3CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x500001a4, 0xffffffff, 0, rw_t> AWD3CR_REG;
            /*
                AWD3CH
             */
            typedef reg_t<0x500001a4, 0x0003ffff, 1, rw_t> AWD3CH;
        };
        /*
            Differential Mode Selection Register
          2
         */
        namespace DIFSEL {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Differential mode for channels 15 to
              1
             */
            typedef reg_t<0x500001b0, 0x00007fff, 1, rw_t> DIFSEL_1_15;
            /*
                Differential mode for channels 18 to
              16
             */
            typedef reg_t<0x500001b0, 0x00000007, 16, ro_t> DIFSEL_16_18;
        };
        /*
            Calibration Factors
         */
        namespace CALFACT {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x500001b4, 0xffffffff, 0, rw_t> CALFACT_REG;
            /*
                CALFACT_D
             */
            typedef reg_t<0x500001b4, 0x0000007f, 16, rw_t> CALFACT_D;
            /*
                CALFACT_S
             */
            typedef reg_t<0x500001b4, 0x0000007f, 0, rw_t> CALFACT_S;
        };
    };
    /*
        Analog-to-Digital Converter
     */
    namespace ADC3 {
        /*
            interrupt and status register
         */
        namespace ISR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000400, 0xffffffff, 0, rw_t> ISR_REG;
            /*
                JQOVF
             */
            typedef reg_t<0x50000400, 0x00000001, 10, rw_t> JQOVF;
            /*
                AWD3
             */
            typedef reg_t<0x50000400, 0x00000001, 9, rw_t> AWD3;
            /*
                AWD2
             */
            typedef reg_t<0x50000400, 0x00000001, 8, rw_t> AWD2;
            /*
                AWD1
             */
            typedef reg_t<0x50000400, 0x00000001, 7, rw_t> AWD1;
            /*
                JEOS
             */
            typedef reg_t<0x50000400, 0x00000001, 6, rw_t> JEOS;
            /*
                JEOC
             */
            typedef reg_t<0x50000400, 0x00000001, 5, rw_t> JEOC;
            /*
                OVR
             */
            typedef reg_t<0x50000400, 0x00000001, 4, rw_t> OVR;
            /*
                EOS
             */
            typedef reg_t<0x50000400, 0x00000001, 3, rw_t> EOS;
            /*
                EOC
             */
            typedef reg_t<0x50000400, 0x00000001, 2, rw_t> EOC;
            /*
                EOSMP
             */
            typedef reg_t<0x50000400, 0x00000001, 1, rw_t> EOSMP;
            /*
                ADRDY
             */
            typedef reg_t<0x50000400, 0x00000001, 0, rw_t> ADRDY;
        };
        /*
            interrupt enable register
         */
        namespace IER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000404, 0xffffffff, 0, rw_t> IER_REG;
            /*
                JQOVFIE
             */
            typedef reg_t<0x50000404, 0x00000001, 10, rw_t> JQOVFIE;
            /*
                AWD3IE
             */
            typedef reg_t<0x50000404, 0x00000001, 9, rw_t> AWD3IE;
            /*
                AWD2IE
             */
            typedef reg_t<0x50000404, 0x00000001, 8, rw_t> AWD2IE;
            /*
                AWD1IE
             */
            typedef reg_t<0x50000404, 0x00000001, 7, rw_t> AWD1IE;
            /*
                JEOSIE
             */
            typedef reg_t<0x50000404, 0x00000001, 6, rw_t> JEOSIE;
            /*
                JEOCIE
             */
            typedef reg_t<0x50000404, 0x00000001, 5, rw_t> JEOCIE;
            /*
                OVRIE
             */
            typedef reg_t<0x50000404, 0x00000001, 4, rw_t> OVRIE;
            /*
                EOSIE
             */
            typedef reg_t<0x50000404, 0x00000001, 3, rw_t> EOSIE;
            /*
                EOCIE
             */
            typedef reg_t<0x50000404, 0x00000001, 2, rw_t> EOCIE;
            /*
                EOSMPIE
             */
            typedef reg_t<0x50000404, 0x00000001, 1, rw_t> EOSMPIE;
            /*
                ADRDYIE
             */
            typedef reg_t<0x50000404, 0x00000001, 0, rw_t> ADRDYIE;
        };
        /*
            control register
         */
        namespace CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000408, 0xffffffff, 0, rw_t> CR_REG;
            /*
                ADCAL
             */
            typedef reg_t<0x50000408, 0x00000001, 31, rw_t> ADCAL;
            /*
                ADCALDIF
             */
            typedef reg_t<0x50000408, 0x00000001, 30, rw_t> ADCALDIF;
            /*
                DEEPPWD
             */
            typedef reg_t<0x50000408, 0x00000001, 29, rw_t> DEEPPWD;
            /*
                ADVREGEN
             */
            typedef reg_t<0x50000408, 0x00000001, 28, rw_t> ADVREGEN;
            /*
                JADSTP
             */
            typedef reg_t<0x50000408, 0x00000001, 5, rw_t> JADSTP;
            /*
                ADSTP
             */
            typedef reg_t<0x50000408, 0x00000001, 4, rw_t> ADSTP;
            /*
                JADSTART
             */
            typedef reg_t<0x50000408, 0x00000001, 3, rw_t> JADSTART;
            /*
                ADSTART
             */
            typedef reg_t<0x50000408, 0x00000001, 2, rw_t> ADSTART;
            /*
                ADDIS
             */
            typedef reg_t<0x50000408, 0x00000001, 1, rw_t> ADDIS;
            /*
                ADEN
             */
            typedef reg_t<0x50000408, 0x00000001, 0, rw_t> ADEN;
        };
        /*
            configuration register
         */
        namespace CFGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x5000040c, 0xffffffff, 0, rw_t> CFGR_REG;
            /*
                AWDCH1CH
             */
            typedef reg_t<0x5000040c, 0x0000001f, 26, rw_t> AWDCH1CH;
            /*
                JAUTO
             */
            typedef reg_t<0x5000040c, 0x00000001, 25, rw_t> JAUTO;
            /*
                JAWD1EN
             */
            typedef reg_t<0x5000040c, 0x00000001, 24, rw_t> JAWD1EN;
            /*
                AWD1EN
             */
            typedef reg_t<0x5000040c, 0x00000001, 23, rw_t> AWD1EN;
            /*
                AWD1SGL
             */
            typedef reg_t<0x5000040c, 0x00000001, 22, rw_t> AWD1SGL;
            /*
                JQM
             */
            typedef reg_t<0x5000040c, 0x00000001, 21, rw_t> JQM;
            /*
                JDISCEN
             */
            typedef reg_t<0x5000040c, 0x00000001, 20, rw_t> JDISCEN;
            /*
                DISCNUM
             */
            typedef reg_t<0x5000040c, 0x00000007, 17, rw_t> DISCNUM;
            /*
                DISCEN
             */
            typedef reg_t<0x5000040c, 0x00000001, 16, rw_t> DISCEN;
            /*
                AUTOFF
             */
            typedef reg_t<0x5000040c, 0x00000001, 15, rw_t> AUTOFF;
            /*
                AUTDLY
             */
            typedef reg_t<0x5000040c, 0x00000001, 14, rw_t> AUTDLY;
            /*
                CONT
             */
            typedef reg_t<0x5000040c, 0x00000001, 13, rw_t> CONT;
            /*
                OVRMOD
             */
            typedef reg_t<0x5000040c, 0x00000001, 12, rw_t> OVRMOD;
            /*
                EXTEN
             */
            typedef reg_t<0x5000040c, 0x00000003, 10, rw_t> EXTEN;
            /*
                EXTSEL
             */
            typedef reg_t<0x5000040c, 0x0000000f, 6, rw_t> EXTSEL;
            /*
                ALIGN
             */
            typedef reg_t<0x5000040c, 0x00000001, 5, rw_t> ALIGN;
            /*
                RES
             */
            typedef reg_t<0x5000040c, 0x00000003, 3, rw_t> RES;
            /*
                DMACFG
             */
            typedef reg_t<0x5000040c, 0x00000001, 1, rw_t> DMACFG;
            /*
                DMAEN
             */
            typedef reg_t<0x5000040c, 0x00000001, 0, rw_t> DMAEN;
        };
        /*
            sample time register 1
         */
        namespace SMPR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000414, 0xffffffff, 0, rw_t> SMPR1_REG;
            /*
                SMP9
             */
            typedef reg_t<0x50000414, 0x00000007, 27, rw_t> SMP9;
            /*
                SMP8
             */
            typedef reg_t<0x50000414, 0x00000007, 24, rw_t> SMP8;
            /*
                SMP7
             */
            typedef reg_t<0x50000414, 0x00000007, 21, rw_t> SMP7;
            /*
                SMP6
             */
            typedef reg_t<0x50000414, 0x00000007, 18, rw_t> SMP6;
            /*
                SMP5
             */
            typedef reg_t<0x50000414, 0x00000007, 15, rw_t> SMP5;
            /*
                SMP4
             */
            typedef reg_t<0x50000414, 0x00000007, 12, rw_t> SMP4;
            /*
                SMP3
             */
            typedef reg_t<0x50000414, 0x00000007, 9, rw_t> SMP3;
            /*
                SMP2
             */
            typedef reg_t<0x50000414, 0x00000007, 6, rw_t> SMP2;
            /*
                SMP1
             */
            typedef reg_t<0x50000414, 0x00000007, 3, rw_t> SMP1;
        };
        /*
            sample time register 2
         */
        namespace SMPR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000418, 0xffffffff, 0, rw_t> SMPR2_REG;
            /*
                SMP18
             */
            typedef reg_t<0x50000418, 0x00000007, 24, rw_t> SMP18;
            /*
                SMP17
             */
            typedef reg_t<0x50000418, 0x00000007, 21, rw_t> SMP17;
            /*
                SMP16
             */
            typedef reg_t<0x50000418, 0x00000007, 18, rw_t> SMP16;
            /*
                SMP15
             */
            typedef reg_t<0x50000418, 0x00000007, 15, rw_t> SMP15;
            /*
                SMP14
             */
            typedef reg_t<0x50000418, 0x00000007, 12, rw_t> SMP14;
            /*
                SMP13
             */
            typedef reg_t<0x50000418, 0x00000007, 9, rw_t> SMP13;
            /*
                SMP12
             */
            typedef reg_t<0x50000418, 0x00000007, 6, rw_t> SMP12;
            /*
                SMP11
             */
            typedef reg_t<0x50000418, 0x00000007, 3, rw_t> SMP11;
            /*
                SMP10
             */
            typedef reg_t<0x50000418, 0x00000007, 0, rw_t> SMP10;
        };
        /*
            watchdog threshold register 1
         */
        namespace TR1 {

            static constexpr uint32_t RESETVALUE = 0x0fff0000;
            typedef reg_t<0x50000420, 0xffffffff, 0, rw_t> TR1_REG;
            /*
                HT1
             */
            typedef reg_t<0x50000420, 0x00000fff, 16, rw_t> HT1;
            /*
                LT1
             */
            typedef reg_t<0x50000420, 0x00000fff, 0, rw_t> LT1;
        };
        /*
            watchdog threshold register
         */
        namespace TR2 {

            static constexpr uint32_t RESETVALUE = 0x0fff0000;
            typedef reg_t<0x50000424, 0xffffffff, 0, rw_t> TR2_REG;
            /*
                HT2
             */
            typedef reg_t<0x50000424, 0x000000ff, 16, rw_t> HT2;
            /*
                LT2
             */
            typedef reg_t<0x50000424, 0x000000ff, 0, rw_t> LT2;
        };
        /*
            watchdog threshold register 3
         */
        namespace TR3 {

            static constexpr uint32_t RESETVALUE = 0x0fff0000;
            typedef reg_t<0x50000428, 0xffffffff, 0, rw_t> TR3_REG;
            /*
                HT3
             */
            typedef reg_t<0x50000428, 0x000000ff, 16, rw_t> HT3;
            /*
                LT3
             */
            typedef reg_t<0x50000428, 0x000000ff, 0, rw_t> LT3;
        };
        /*
            regular sequence register 1
         */
        namespace SQR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000430, 0xffffffff, 0, rw_t> SQR1_REG;
            /*
                SQ4
             */
            typedef reg_t<0x50000430, 0x0000001f, 24, rw_t> SQ4;
            /*
                SQ3
             */
            typedef reg_t<0x50000430, 0x0000001f, 18, rw_t> SQ3;
            /*
                SQ2
             */
            typedef reg_t<0x50000430, 0x0000001f, 12, rw_t> SQ2;
            /*
                SQ1
             */
            typedef reg_t<0x50000430, 0x0000001f, 6, rw_t> SQ1;
            /*
                L3
             */
            typedef reg_t<0x50000430, 0x0000000f, 0, rw_t> L3;
        };
        /*
            regular sequence register 2
         */
        namespace SQR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000434, 0xffffffff, 0, rw_t> SQR2_REG;
            /*
                SQ9
             */
            typedef reg_t<0x50000434, 0x0000001f, 24, rw_t> SQ9;
            /*
                SQ8
             */
            typedef reg_t<0x50000434, 0x0000001f, 18, rw_t> SQ8;
            /*
                SQ7
             */
            typedef reg_t<0x50000434, 0x0000001f, 12, rw_t> SQ7;
            /*
                SQ6
             */
            typedef reg_t<0x50000434, 0x0000001f, 6, rw_t> SQ6;
            /*
                SQ5
             */
            typedef reg_t<0x50000434, 0x0000001f, 0, rw_t> SQ5;
        };
        /*
            regular sequence register 3
         */
        namespace SQR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000438, 0xffffffff, 0, rw_t> SQR3_REG;
            /*
                SQ14
             */
            typedef reg_t<0x50000438, 0x0000001f, 24, rw_t> SQ14;
            /*
                SQ13
             */
            typedef reg_t<0x50000438, 0x0000001f, 18, rw_t> SQ13;
            /*
                SQ12
             */
            typedef reg_t<0x50000438, 0x0000001f, 12, rw_t> SQ12;
            /*
                SQ11
             */
            typedef reg_t<0x50000438, 0x0000001f, 6, rw_t> SQ11;
            /*
                SQ10
             */
            typedef reg_t<0x50000438, 0x0000001f, 0, rw_t> SQ10;
        };
        /*
            regular sequence register 4
         */
        namespace SQR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x5000043c, 0xffffffff, 0, rw_t> SQR4_REG;
            /*
                SQ16
             */
            typedef reg_t<0x5000043c, 0x0000001f, 6, rw_t> SQ16;
            /*
                SQ15
             */
            typedef reg_t<0x5000043c, 0x0000001f, 0, rw_t> SQ15;
        };
        /*
            regular Data Register
         */
        namespace DR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000440, 0xffffffff, 0, ro_t> DR_REG;
            /*
                regularDATA
             */
            typedef reg_t<0x50000440, 0x0000ffff, 0, ro_t> regularDATA;
        };
        /*
            injected sequence register
         */
        namespace JSQR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x5000044c, 0xffffffff, 0, rw_t> JSQR_REG;
            /*
                JSQ4
             */
            typedef reg_t<0x5000044c, 0x0000001f, 26, rw_t> JSQ4;
            /*
                JSQ3
             */
            typedef reg_t<0x5000044c, 0x0000001f, 20, rw_t> JSQ3;
            /*
                JSQ2
             */
            typedef reg_t<0x5000044c, 0x0000001f, 14, rw_t> JSQ2;
            /*
                JSQ1
             */
            typedef reg_t<0x5000044c, 0x0000001f, 8, rw_t> JSQ1;
            /*
                JEXTEN
             */
            typedef reg_t<0x5000044c, 0x00000003, 6, rw_t> JEXTEN;
            /*
                JEXTSEL
             */
            typedef reg_t<0x5000044c, 0x0000000f, 2, rw_t> JEXTSEL;
            /*
                JL
             */
            typedef reg_t<0x5000044c, 0x00000003, 0, rw_t> JL;
        };
        /*
            offset register 1
         */
        namespace OFR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000460, 0xffffffff, 0, rw_t> OFR1_REG;
            /*
                OFFSET1_EN
             */
            typedef reg_t<0x50000460, 0x00000001, 31, rw_t> OFFSET1_EN;
            /*
                OFFSET1_CH
             */
            typedef reg_t<0x50000460, 0x0000001f, 26, rw_t> OFFSET1_CH;
            /*
                OFFSET1
             */
            typedef reg_t<0x50000460, 0x00000fff, 0, rw_t> OFFSET1;
        };
        /*
            offset register 2
         */
        namespace OFR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000464, 0xffffffff, 0, rw_t> OFR2_REG;
            /*
                OFFSET2_EN
             */
            typedef reg_t<0x50000464, 0x00000001, 31, rw_t> OFFSET2_EN;
            /*
                OFFSET2_CH
             */
            typedef reg_t<0x50000464, 0x0000001f, 26, rw_t> OFFSET2_CH;
            /*
                OFFSET2
             */
            typedef reg_t<0x50000464, 0x00000fff, 0, rw_t> OFFSET2;
        };
        /*
            offset register 3
         */
        namespace OFR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000468, 0xffffffff, 0, rw_t> OFR3_REG;
            /*
                OFFSET3_EN
             */
            typedef reg_t<0x50000468, 0x00000001, 31, rw_t> OFFSET3_EN;
            /*
                OFFSET3_CH
             */
            typedef reg_t<0x50000468, 0x0000001f, 26, rw_t> OFFSET3_CH;
            /*
                OFFSET3
             */
            typedef reg_t<0x50000468, 0x00000fff, 0, rw_t> OFFSET3;
        };
        /*
            offset register 4
         */
        namespace OFR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x5000046c, 0xffffffff, 0, rw_t> OFR4_REG;
            /*
                OFFSET4_EN
             */
            typedef reg_t<0x5000046c, 0x00000001, 31, rw_t> OFFSET4_EN;
            /*
                OFFSET4_CH
             */
            typedef reg_t<0x5000046c, 0x0000001f, 26, rw_t> OFFSET4_CH;
            /*
                OFFSET4
             */
            typedef reg_t<0x5000046c, 0x00000fff, 0, rw_t> OFFSET4;
        };
        /*
            injected data register 1
         */
        namespace JDR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000480, 0xffffffff, 0, ro_t> JDR1_REG;
            /*
                JDATA1
             */
            typedef reg_t<0x50000480, 0x0000ffff, 0, ro_t> JDATA1;
        };
        /*
            injected data register 2
         */
        namespace JDR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000484, 0xffffffff, 0, ro_t> JDR2_REG;
            /*
                JDATA2
             */
            typedef reg_t<0x50000484, 0x0000ffff, 0, ro_t> JDATA2;
        };
        /*
            injected data register 3
         */
        namespace JDR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000488, 0xffffffff, 0, ro_t> JDR3_REG;
            /*
                JDATA3
             */
            typedef reg_t<0x50000488, 0x0000ffff, 0, ro_t> JDATA3;
        };
        /*
            injected data register 4
         */
        namespace JDR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x5000048c, 0xffffffff, 0, ro_t> JDR4_REG;
            /*
                JDATA4
             */
            typedef reg_t<0x5000048c, 0x0000ffff, 0, ro_t> JDATA4;
        };
        /*
            Analog Watchdog 2 Configuration
          Register
         */
        namespace AWD2CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x500004a0, 0xffffffff, 0, rw_t> AWD2CR_REG;
            /*
                AWD2CH
             */
            typedef reg_t<0x500004a0, 0x0003ffff, 1, rw_t> AWD2CH;
        };
        /*
            Analog Watchdog 3 Configuration
          Register
         */
        namespace AWD3CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x500004a4, 0xffffffff, 0, rw_t> AWD3CR_REG;
            /*
                AWD3CH
             */
            typedef reg_t<0x500004a4, 0x0003ffff, 1, rw_t> AWD3CH;
        };
        /*
            Differential Mode Selection Register
          2
         */
        namespace DIFSEL {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Differential mode for channels 15 to
              1
             */
            typedef reg_t<0x500004b0, 0x00007fff, 1, rw_t> DIFSEL_1_15;
            /*
                Differential mode for channels 18 to
              16
             */
            typedef reg_t<0x500004b0, 0x00000007, 16, ro_t> DIFSEL_16_18;
        };
        /*
            Calibration Factors
         */
        namespace CALFACT {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x500004b4, 0xffffffff, 0, rw_t> CALFACT_REG;
            /*
                CALFACT_D
             */
            typedef reg_t<0x500004b4, 0x0000007f, 16, rw_t> CALFACT_D;
            /*
                CALFACT_S
             */
            typedef reg_t<0x500004b4, 0x0000007f, 0, rw_t> CALFACT_S;
        };
    };
    /*
        Analog-to-Digital Converter
     */
    namespace ADC4 {
        /*
            interrupt and status register
         */
        namespace ISR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000500, 0xffffffff, 0, rw_t> ISR_REG;
            /*
                JQOVF
             */
            typedef reg_t<0x50000500, 0x00000001, 10, rw_t> JQOVF;
            /*
                AWD3
             */
            typedef reg_t<0x50000500, 0x00000001, 9, rw_t> AWD3;
            /*
                AWD2
             */
            typedef reg_t<0x50000500, 0x00000001, 8, rw_t> AWD2;
            /*
                AWD1
             */
            typedef reg_t<0x50000500, 0x00000001, 7, rw_t> AWD1;
            /*
                JEOS
             */
            typedef reg_t<0x50000500, 0x00000001, 6, rw_t> JEOS;
            /*
                JEOC
             */
            typedef reg_t<0x50000500, 0x00000001, 5, rw_t> JEOC;
            /*
                OVR
             */
            typedef reg_t<0x50000500, 0x00000001, 4, rw_t> OVR;
            /*
                EOS
             */
            typedef reg_t<0x50000500, 0x00000001, 3, rw_t> EOS;
            /*
                EOC
             */
            typedef reg_t<0x50000500, 0x00000001, 2, rw_t> EOC;
            /*
                EOSMP
             */
            typedef reg_t<0x50000500, 0x00000001, 1, rw_t> EOSMP;
            /*
                ADRDY
             */
            typedef reg_t<0x50000500, 0x00000001, 0, rw_t> ADRDY;
        };
        /*
            interrupt enable register
         */
        namespace IER {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000504, 0xffffffff, 0, rw_t> IER_REG;
            /*
                JQOVFIE
             */
            typedef reg_t<0x50000504, 0x00000001, 10, rw_t> JQOVFIE;
            /*
                AWD3IE
             */
            typedef reg_t<0x50000504, 0x00000001, 9, rw_t> AWD3IE;
            /*
                AWD2IE
             */
            typedef reg_t<0x50000504, 0x00000001, 8, rw_t> AWD2IE;
            /*
                AWD1IE
             */
            typedef reg_t<0x50000504, 0x00000001, 7, rw_t> AWD1IE;
            /*
                JEOSIE
             */
            typedef reg_t<0x50000504, 0x00000001, 6, rw_t> JEOSIE;
            /*
                JEOCIE
             */
            typedef reg_t<0x50000504, 0x00000001, 5, rw_t> JEOCIE;
            /*
                OVRIE
             */
            typedef reg_t<0x50000504, 0x00000001, 4, rw_t> OVRIE;
            /*
                EOSIE
             */
            typedef reg_t<0x50000504, 0x00000001, 3, rw_t> EOSIE;
            /*
                EOCIE
             */
            typedef reg_t<0x50000504, 0x00000001, 2, rw_t> EOCIE;
            /*
                EOSMPIE
             */
            typedef reg_t<0x50000504, 0x00000001, 1, rw_t> EOSMPIE;
            /*
                ADRDYIE
             */
            typedef reg_t<0x50000504, 0x00000001, 0, rw_t> ADRDYIE;
        };
        /*
            control register
         */
        namespace CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000508, 0xffffffff, 0, rw_t> CR_REG;
            /*
                ADCAL
             */
            typedef reg_t<0x50000508, 0x00000001, 31, rw_t> ADCAL;
            /*
                ADCALDIF
             */
            typedef reg_t<0x50000508, 0x00000001, 30, rw_t> ADCALDIF;
            /*
                DEEPPWD
             */
            typedef reg_t<0x50000508, 0x00000001, 29, rw_t> DEEPPWD;
            /*
                ADVREGEN
             */
            typedef reg_t<0x50000508, 0x00000001, 28, rw_t> ADVREGEN;
            /*
                JADSTP
             */
            typedef reg_t<0x50000508, 0x00000001, 5, rw_t> JADSTP;
            /*
                ADSTP
             */
            typedef reg_t<0x50000508, 0x00000001, 4, rw_t> ADSTP;
            /*
                JADSTART
             */
            typedef reg_t<0x50000508, 0x00000001, 3, rw_t> JADSTART;
            /*
                ADSTART
             */
            typedef reg_t<0x50000508, 0x00000001, 2, rw_t> ADSTART;
            /*
                ADDIS
             */
            typedef reg_t<0x50000508, 0x00000001, 1, rw_t> ADDIS;
            /*
                ADEN
             */
            typedef reg_t<0x50000508, 0x00000001, 0, rw_t> ADEN;
        };
        /*
            configuration register
         */
        namespace CFGR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x5000050c, 0xffffffff, 0, rw_t> CFGR_REG;
            /*
                AWDCH1CH
             */
            typedef reg_t<0x5000050c, 0x0000001f, 26, rw_t> AWDCH1CH;
            /*
                JAUTO
             */
            typedef reg_t<0x5000050c, 0x00000001, 25, rw_t> JAUTO;
            /*
                JAWD1EN
             */
            typedef reg_t<0x5000050c, 0x00000001, 24, rw_t> JAWD1EN;
            /*
                AWD1EN
             */
            typedef reg_t<0x5000050c, 0x00000001, 23, rw_t> AWD1EN;
            /*
                AWD1SGL
             */
            typedef reg_t<0x5000050c, 0x00000001, 22, rw_t> AWD1SGL;
            /*
                JQM
             */
            typedef reg_t<0x5000050c, 0x00000001, 21, rw_t> JQM;
            /*
                JDISCEN
             */
            typedef reg_t<0x5000050c, 0x00000001, 20, rw_t> JDISCEN;
            /*
                DISCNUM
             */
            typedef reg_t<0x5000050c, 0x00000007, 17, rw_t> DISCNUM;
            /*
                DISCEN
             */
            typedef reg_t<0x5000050c, 0x00000001, 16, rw_t> DISCEN;
            /*
                AUTOFF
             */
            typedef reg_t<0x5000050c, 0x00000001, 15, rw_t> AUTOFF;
            /*
                AUTDLY
             */
            typedef reg_t<0x5000050c, 0x00000001, 14, rw_t> AUTDLY;
            /*
                CONT
             */
            typedef reg_t<0x5000050c, 0x00000001, 13, rw_t> CONT;
            /*
                OVRMOD
             */
            typedef reg_t<0x5000050c, 0x00000001, 12, rw_t> OVRMOD;
            /*
                EXTEN
             */
            typedef reg_t<0x5000050c, 0x00000003, 10, rw_t> EXTEN;
            /*
                EXTSEL
             */
            typedef reg_t<0x5000050c, 0x0000000f, 6, rw_t> EXTSEL;
            /*
                ALIGN
             */
            typedef reg_t<0x5000050c, 0x00000001, 5, rw_t> ALIGN;
            /*
                RES
             */
            typedef reg_t<0x5000050c, 0x00000003, 3, rw_t> RES;
            /*
                DMACFG
             */
            typedef reg_t<0x5000050c, 0x00000001, 1, rw_t> DMACFG;
            /*
                DMAEN
             */
            typedef reg_t<0x5000050c, 0x00000001, 0, rw_t> DMAEN;
        };
        /*
            sample time register 1
         */
        namespace SMPR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000514, 0xffffffff, 0, rw_t> SMPR1_REG;
            /*
                SMP9
             */
            typedef reg_t<0x50000514, 0x00000007, 27, rw_t> SMP9;
            /*
                SMP8
             */
            typedef reg_t<0x50000514, 0x00000007, 24, rw_t> SMP8;
            /*
                SMP7
             */
            typedef reg_t<0x50000514, 0x00000007, 21, rw_t> SMP7;
            /*
                SMP6
             */
            typedef reg_t<0x50000514, 0x00000007, 18, rw_t> SMP6;
            /*
                SMP5
             */
            typedef reg_t<0x50000514, 0x00000007, 15, rw_t> SMP5;
            /*
                SMP4
             */
            typedef reg_t<0x50000514, 0x00000007, 12, rw_t> SMP4;
            /*
                SMP3
             */
            typedef reg_t<0x50000514, 0x00000007, 9, rw_t> SMP3;
            /*
                SMP2
             */
            typedef reg_t<0x50000514, 0x00000007, 6, rw_t> SMP2;
            /*
                SMP1
             */
            typedef reg_t<0x50000514, 0x00000007, 3, rw_t> SMP1;
        };
        /*
            sample time register 2
         */
        namespace SMPR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000518, 0xffffffff, 0, rw_t> SMPR2_REG;
            /*
                SMP18
             */
            typedef reg_t<0x50000518, 0x00000007, 24, rw_t> SMP18;
            /*
                SMP17
             */
            typedef reg_t<0x50000518, 0x00000007, 21, rw_t> SMP17;
            /*
                SMP16
             */
            typedef reg_t<0x50000518, 0x00000007, 18, rw_t> SMP16;
            /*
                SMP15
             */
            typedef reg_t<0x50000518, 0x00000007, 15, rw_t> SMP15;
            /*
                SMP14
             */
            typedef reg_t<0x50000518, 0x00000007, 12, rw_t> SMP14;
            /*
                SMP13
             */
            typedef reg_t<0x50000518, 0x00000007, 9, rw_t> SMP13;
            /*
                SMP12
             */
            typedef reg_t<0x50000518, 0x00000007, 6, rw_t> SMP12;
            /*
                SMP11
             */
            typedef reg_t<0x50000518, 0x00000007, 3, rw_t> SMP11;
            /*
                SMP10
             */
            typedef reg_t<0x50000518, 0x00000007, 0, rw_t> SMP10;
        };
        /*
            watchdog threshold register 1
         */
        namespace TR1 {

            static constexpr uint32_t RESETVALUE = 0x0fff0000;
            typedef reg_t<0x50000520, 0xffffffff, 0, rw_t> TR1_REG;
            /*
                HT1
             */
            typedef reg_t<0x50000520, 0x00000fff, 16, rw_t> HT1;
            /*
                LT1
             */
            typedef reg_t<0x50000520, 0x00000fff, 0, rw_t> LT1;
        };
        /*
            watchdog threshold register
         */
        namespace TR2 {

            static constexpr uint32_t RESETVALUE = 0x0fff0000;
            typedef reg_t<0x50000524, 0xffffffff, 0, rw_t> TR2_REG;
            /*
                HT2
             */
            typedef reg_t<0x50000524, 0x000000ff, 16, rw_t> HT2;
            /*
                LT2
             */
            typedef reg_t<0x50000524, 0x000000ff, 0, rw_t> LT2;
        };
        /*
            watchdog threshold register 3
         */
        namespace TR3 {

            static constexpr uint32_t RESETVALUE = 0x0fff0000;
            typedef reg_t<0x50000528, 0xffffffff, 0, rw_t> TR3_REG;
            /*
                HT3
             */
            typedef reg_t<0x50000528, 0x000000ff, 16, rw_t> HT3;
            /*
                LT3
             */
            typedef reg_t<0x50000528, 0x000000ff, 0, rw_t> LT3;
        };
        /*
            regular sequence register 1
         */
        namespace SQR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000530, 0xffffffff, 0, rw_t> SQR1_REG;
            /*
                SQ4
             */
            typedef reg_t<0x50000530, 0x0000001f, 24, rw_t> SQ4;
            /*
                SQ3
             */
            typedef reg_t<0x50000530, 0x0000001f, 18, rw_t> SQ3;
            /*
                SQ2
             */
            typedef reg_t<0x50000530, 0x0000001f, 12, rw_t> SQ2;
            /*
                SQ1
             */
            typedef reg_t<0x50000530, 0x0000001f, 6, rw_t> SQ1;
            /*
                L3
             */
            typedef reg_t<0x50000530, 0x0000000f, 0, rw_t> L3;
        };
        /*
            regular sequence register 2
         */
        namespace SQR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000534, 0xffffffff, 0, rw_t> SQR2_REG;
            /*
                SQ9
             */
            typedef reg_t<0x50000534, 0x0000001f, 24, rw_t> SQ9;
            /*
                SQ8
             */
            typedef reg_t<0x50000534, 0x0000001f, 18, rw_t> SQ8;
            /*
                SQ7
             */
            typedef reg_t<0x50000534, 0x0000001f, 12, rw_t> SQ7;
            /*
                SQ6
             */
            typedef reg_t<0x50000534, 0x0000001f, 6, rw_t> SQ6;
            /*
                SQ5
             */
            typedef reg_t<0x50000534, 0x0000001f, 0, rw_t> SQ5;
        };
        /*
            regular sequence register 3
         */
        namespace SQR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000538, 0xffffffff, 0, rw_t> SQR3_REG;
            /*
                SQ14
             */
            typedef reg_t<0x50000538, 0x0000001f, 24, rw_t> SQ14;
            /*
                SQ13
             */
            typedef reg_t<0x50000538, 0x0000001f, 18, rw_t> SQ13;
            /*
                SQ12
             */
            typedef reg_t<0x50000538, 0x0000001f, 12, rw_t> SQ12;
            /*
                SQ11
             */
            typedef reg_t<0x50000538, 0x0000001f, 6, rw_t> SQ11;
            /*
                SQ10
             */
            typedef reg_t<0x50000538, 0x0000001f, 0, rw_t> SQ10;
        };
        /*
            regular sequence register 4
         */
        namespace SQR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x5000053c, 0xffffffff, 0, rw_t> SQR4_REG;
            /*
                SQ16
             */
            typedef reg_t<0x5000053c, 0x0000001f, 6, rw_t> SQ16;
            /*
                SQ15
             */
            typedef reg_t<0x5000053c, 0x0000001f, 0, rw_t> SQ15;
        };
        /*
            regular Data Register
         */
        namespace DR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000540, 0xffffffff, 0, ro_t> DR_REG;
            /*
                regularDATA
             */
            typedef reg_t<0x50000540, 0x0000ffff, 0, ro_t> regularDATA;
        };
        /*
            injected sequence register
         */
        namespace JSQR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x5000054c, 0xffffffff, 0, rw_t> JSQR_REG;
            /*
                JSQ4
             */
            typedef reg_t<0x5000054c, 0x0000001f, 26, rw_t> JSQ4;
            /*
                JSQ3
             */
            typedef reg_t<0x5000054c, 0x0000001f, 20, rw_t> JSQ3;
            /*
                JSQ2
             */
            typedef reg_t<0x5000054c, 0x0000001f, 14, rw_t> JSQ2;
            /*
                JSQ1
             */
            typedef reg_t<0x5000054c, 0x0000001f, 8, rw_t> JSQ1;
            /*
                JEXTEN
             */
            typedef reg_t<0x5000054c, 0x00000003, 6, rw_t> JEXTEN;
            /*
                JEXTSEL
             */
            typedef reg_t<0x5000054c, 0x0000000f, 2, rw_t> JEXTSEL;
            /*
                JL
             */
            typedef reg_t<0x5000054c, 0x00000003, 0, rw_t> JL;
        };
        /*
            offset register 1
         */
        namespace OFR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000560, 0xffffffff, 0, rw_t> OFR1_REG;
            /*
                OFFSET1_EN
             */
            typedef reg_t<0x50000560, 0x00000001, 31, rw_t> OFFSET1_EN;
            /*
                OFFSET1_CH
             */
            typedef reg_t<0x50000560, 0x0000001f, 26, rw_t> OFFSET1_CH;
            /*
                OFFSET1
             */
            typedef reg_t<0x50000560, 0x00000fff, 0, rw_t> OFFSET1;
        };
        /*
            offset register 2
         */
        namespace OFR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000564, 0xffffffff, 0, rw_t> OFR2_REG;
            /*
                OFFSET2_EN
             */
            typedef reg_t<0x50000564, 0x00000001, 31, rw_t> OFFSET2_EN;
            /*
                OFFSET2_CH
             */
            typedef reg_t<0x50000564, 0x0000001f, 26, rw_t> OFFSET2_CH;
            /*
                OFFSET2
             */
            typedef reg_t<0x50000564, 0x00000fff, 0, rw_t> OFFSET2;
        };
        /*
            offset register 3
         */
        namespace OFR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000568, 0xffffffff, 0, rw_t> OFR3_REG;
            /*
                OFFSET3_EN
             */
            typedef reg_t<0x50000568, 0x00000001, 31, rw_t> OFFSET3_EN;
            /*
                OFFSET3_CH
             */
            typedef reg_t<0x50000568, 0x0000001f, 26, rw_t> OFFSET3_CH;
            /*
                OFFSET3
             */
            typedef reg_t<0x50000568, 0x00000fff, 0, rw_t> OFFSET3;
        };
        /*
            offset register 4
         */
        namespace OFR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x5000056c, 0xffffffff, 0, rw_t> OFR4_REG;
            /*
                OFFSET4_EN
             */
            typedef reg_t<0x5000056c, 0x00000001, 31, rw_t> OFFSET4_EN;
            /*
                OFFSET4_CH
             */
            typedef reg_t<0x5000056c, 0x0000001f, 26, rw_t> OFFSET4_CH;
            /*
                OFFSET4
             */
            typedef reg_t<0x5000056c, 0x00000fff, 0, rw_t> OFFSET4;
        };
        /*
            injected data register 1
         */
        namespace JDR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000580, 0xffffffff, 0, ro_t> JDR1_REG;
            /*
                JDATA1
             */
            typedef reg_t<0x50000580, 0x0000ffff, 0, ro_t> JDATA1;
        };
        /*
            injected data register 2
         */
        namespace JDR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000584, 0xffffffff, 0, ro_t> JDR2_REG;
            /*
                JDATA2
             */
            typedef reg_t<0x50000584, 0x0000ffff, 0, ro_t> JDATA2;
        };
        /*
            injected data register 3
         */
        namespace JDR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000588, 0xffffffff, 0, ro_t> JDR3_REG;
            /*
                JDATA3
             */
            typedef reg_t<0x50000588, 0x0000ffff, 0, ro_t> JDATA3;
        };
        /*
            injected data register 4
         */
        namespace JDR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x5000058c, 0xffffffff, 0, ro_t> JDR4_REG;
            /*
                JDATA4
             */
            typedef reg_t<0x5000058c, 0x0000ffff, 0, ro_t> JDATA4;
        };
        /*
            Analog Watchdog 2 Configuration
          Register
         */
        namespace AWD2CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x500005a0, 0xffffffff, 0, rw_t> AWD2CR_REG;
            /*
                AWD2CH
             */
            typedef reg_t<0x500005a0, 0x0003ffff, 1, rw_t> AWD2CH;
        };
        /*
            Analog Watchdog 3 Configuration
          Register
         */
        namespace AWD3CR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x500005a4, 0xffffffff, 0, rw_t> AWD3CR_REG;
            /*
                AWD3CH
             */
            typedef reg_t<0x500005a4, 0x0003ffff, 1, rw_t> AWD3CH;
        };
        /*
            Differential Mode Selection Register
          2
         */
        namespace DIFSEL {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Differential mode for channels 15 to
              1
             */
            typedef reg_t<0x500005b0, 0x00007fff, 1, rw_t> DIFSEL_1_15;
            /*
                Differential mode for channels 18 to
              16
             */
            typedef reg_t<0x500005b0, 0x00000007, 16, ro_t> DIFSEL_16_18;
        };
        /*
            Calibration Factors
         */
        namespace CALFACT {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x500005b4, 0xffffffff, 0, rw_t> CALFACT_REG;
            /*
                CALFACT_D
             */
            typedef reg_t<0x500005b4, 0x0000007f, 16, rw_t> CALFACT_D;
            /*
                CALFACT_S
             */
            typedef reg_t<0x500005b4, 0x0000007f, 0, rw_t> CALFACT_S;
        };
    };
    /*
        Analog-to-Digital Converter
     */
    namespace ADC1_2 {
        /*
            ADC Common status register
         */
        namespace CSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000300, 0xffffffff, 0, ro_t> CSR_REG;
            /*
                ADDRDY_MST
             */
            typedef reg_t<0x50000300, 0x00000001, 0, ro_t> ADDRDY_MST;
            /*
                EOSMP_MST
             */
            typedef reg_t<0x50000300, 0x00000001, 1, ro_t> EOSMP_MST;
            /*
                EOC_MST
             */
            typedef reg_t<0x50000300, 0x00000001, 2, ro_t> EOC_MST;
            /*
                EOS_MST
             */
            typedef reg_t<0x50000300, 0x00000001, 3, ro_t> EOS_MST;
            /*
                OVR_MST
             */
            typedef reg_t<0x50000300, 0x00000001, 4, ro_t> OVR_MST;
            /*
                JEOC_MST
             */
            typedef reg_t<0x50000300, 0x00000001, 5, ro_t> JEOC_MST;
            /*
                JEOS_MST
             */
            typedef reg_t<0x50000300, 0x00000001, 6, ro_t> JEOS_MST;
            /*
                AWD1_MST
             */
            typedef reg_t<0x50000300, 0x00000001, 7, ro_t> AWD1_MST;
            /*
                AWD2_MST
             */
            typedef reg_t<0x50000300, 0x00000001, 8, ro_t> AWD2_MST;
            /*
                AWD3_MST
             */
            typedef reg_t<0x50000300, 0x00000001, 9, ro_t> AWD3_MST;
            /*
                JQOVF_MST
             */
            typedef reg_t<0x50000300, 0x00000001, 10, ro_t> JQOVF_MST;
            /*
                ADRDY_SLV
             */
            typedef reg_t<0x50000300, 0x00000001, 16, ro_t> ADRDY_SLV;
            /*
                EOSMP_SLV
             */
            typedef reg_t<0x50000300, 0x00000001, 17, ro_t> EOSMP_SLV;
            /*
                End of regular conversion of the slave
              ADC
             */
            typedef reg_t<0x50000300, 0x00000001, 18, ro_t> EOC_SLV;
            /*
                End of regular sequence flag of the
              slave ADC
             */
            typedef reg_t<0x50000300, 0x00000001, 19, ro_t> EOS_SLV;
            /*
                Overrun flag of the slave
              ADC
             */
            typedef reg_t<0x50000300, 0x00000001, 20, ro_t> OVR_SLV;
            /*
                End of injected conversion flag of the
              slave ADC
             */
            typedef reg_t<0x50000300, 0x00000001, 21, ro_t> JEOC_SLV;
            /*
                End of injected sequence flag of the
              slave ADC
             */
            typedef reg_t<0x50000300, 0x00000001, 22, ro_t> JEOS_SLV;
            /*
                Analog watchdog 1 flag of the slave
              ADC
             */
            typedef reg_t<0x50000300, 0x00000001, 23, ro_t> AWD1_SLV;
            /*
                Analog watchdog 2 flag of the slave
              ADC
             */
            typedef reg_t<0x50000300, 0x00000001, 24, ro_t> AWD2_SLV;
            /*
                Analog watchdog 3 flag of the slave
              ADC
             */
            typedef reg_t<0x50000300, 0x00000001, 25, ro_t> AWD3_SLV;
            /*
                Injected Context Queue Overflow flag of
              the slave ADC
             */
            typedef reg_t<0x50000300, 0x00000001, 26, ro_t> JQOVF_SLV;
        };
        /*
            ADC common control register
         */
        namespace CCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000308, 0xffffffff, 0, rw_t> CCR_REG;
            /*
                Multi ADC mode selection
             */
            typedef reg_t<0x50000308, 0x0000001f, 0, rw_t> MULT;
            /*
                Delay between 2 sampling
              phases
             */
            typedef reg_t<0x50000308, 0x0000000f, 8, rw_t> DELAY;
            /*
                DMA configuration (for multi-ADC
              mode)
             */
            typedef reg_t<0x50000308, 0x00000001, 13, rw_t> DMACFG;
            /*
                Direct memory access mode for multi ADC
              mode
             */
            typedef reg_t<0x50000308, 0x00000003, 14, rw_t> MDMA;
            /*
                ADC clock mode
             */
            typedef reg_t<0x50000308, 0x00000003, 16, rw_t> CKMODE;
            /*
                VREFINT enable
             */
            typedef reg_t<0x50000308, 0x00000001, 22, rw_t> VREFEN;
            /*
                Temperature sensor enable
             */
            typedef reg_t<0x50000308, 0x00000001, 23, rw_t> TSEN;
            /*
                VBAT enable
             */
            typedef reg_t<0x50000308, 0x00000001, 24, rw_t> VBATEN;
        };
        /*
            ADC common regular data register for dual
          and triple modes
         */
        namespace CDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x5000030c, 0xffffffff, 0, ro_t> CDR_REG;
            /*
                Regular data of the slave
              ADC
             */
            typedef reg_t<0x5000030c, 0x0000ffff, 16, ro_t> RDATA_SLV;
            /*
                Regular data of the master
              ADC
             */
            typedef reg_t<0x5000030c, 0x0000ffff, 0, ro_t> RDATA_MST;
        };
    };
    /*
        Analog-to-Digital Converter
     */
    namespace ADC3_4 {
        /*
            ADC Common status register
         */
        namespace CSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000700, 0xffffffff, 0, ro_t> CSR_REG;
            /*
                ADDRDY_MST
             */
            typedef reg_t<0x50000700, 0x00000001, 0, ro_t> ADDRDY_MST;
            /*
                EOSMP_MST
             */
            typedef reg_t<0x50000700, 0x00000001, 1, ro_t> EOSMP_MST;
            /*
                EOC_MST
             */
            typedef reg_t<0x50000700, 0x00000001, 2, ro_t> EOC_MST;
            /*
                EOS_MST
             */
            typedef reg_t<0x50000700, 0x00000001, 3, ro_t> EOS_MST;
            /*
                OVR_MST
             */
            typedef reg_t<0x50000700, 0x00000001, 4, ro_t> OVR_MST;
            /*
                JEOC_MST
             */
            typedef reg_t<0x50000700, 0x00000001, 5, ro_t> JEOC_MST;
            /*
                JEOS_MST
             */
            typedef reg_t<0x50000700, 0x00000001, 6, ro_t> JEOS_MST;
            /*
                AWD1_MST
             */
            typedef reg_t<0x50000700, 0x00000001, 7, ro_t> AWD1_MST;
            /*
                AWD2_MST
             */
            typedef reg_t<0x50000700, 0x00000001, 8, ro_t> AWD2_MST;
            /*
                AWD3_MST
             */
            typedef reg_t<0x50000700, 0x00000001, 9, ro_t> AWD3_MST;
            /*
                JQOVF_MST
             */
            typedef reg_t<0x50000700, 0x00000001, 10, ro_t> JQOVF_MST;
            /*
                ADRDY_SLV
             */
            typedef reg_t<0x50000700, 0x00000001, 16, ro_t> ADRDY_SLV;
            /*
                EOSMP_SLV
             */
            typedef reg_t<0x50000700, 0x00000001, 17, ro_t> EOSMP_SLV;
            /*
                End of regular conversion of the slave
              ADC
             */
            typedef reg_t<0x50000700, 0x00000001, 18, ro_t> EOC_SLV;
            /*
                End of regular sequence flag of the
              slave ADC
             */
            typedef reg_t<0x50000700, 0x00000001, 19, ro_t> EOS_SLV;
            /*
                Overrun flag of the slave
              ADC
             */
            typedef reg_t<0x50000700, 0x00000001, 20, ro_t> OVR_SLV;
            /*
                End of injected conversion flag of the
              slave ADC
             */
            typedef reg_t<0x50000700, 0x00000001, 21, ro_t> JEOC_SLV;
            /*
                End of injected sequence flag of the
              slave ADC
             */
            typedef reg_t<0x50000700, 0x00000001, 22, ro_t> JEOS_SLV;
            /*
                Analog watchdog 1 flag of the slave
              ADC
             */
            typedef reg_t<0x50000700, 0x00000001, 23, ro_t> AWD1_SLV;
            /*
                Analog watchdog 2 flag of the slave
              ADC
             */
            typedef reg_t<0x50000700, 0x00000001, 24, ro_t> AWD2_SLV;
            /*
                Analog watchdog 3 flag of the slave
              ADC
             */
            typedef reg_t<0x50000700, 0x00000001, 25, ro_t> AWD3_SLV;
            /*
                Injected Context Queue Overflow flag of
              the slave ADC
             */
            typedef reg_t<0x50000700, 0x00000001, 26, ro_t> JQOVF_SLV;
        };
        /*
            ADC common control register
         */
        namespace CCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x50000708, 0xffffffff, 0, rw_t> CCR_REG;
            /*
                Multi ADC mode selection
             */
            typedef reg_t<0x50000708, 0x0000001f, 0, rw_t> MULT;
            /*
                Delay between 2 sampling
              phases
             */
            typedef reg_t<0x50000708, 0x0000000f, 8, rw_t> DELAY;
            /*
                DMA configuration (for multi-ADC
              mode)
             */
            typedef reg_t<0x50000708, 0x00000001, 13, rw_t> DMACFG;
            /*
                Direct memory access mode for multi ADC
              mode
             */
            typedef reg_t<0x50000708, 0x00000003, 14, rw_t> MDMA;
            /*
                ADC clock mode
             */
            typedef reg_t<0x50000708, 0x00000003, 16, rw_t> CKMODE;
            /*
                VREFINT enable
             */
            typedef reg_t<0x50000708, 0x00000001, 22, rw_t> VREFEN;
            /*
                Temperature sensor enable
             */
            typedef reg_t<0x50000708, 0x00000001, 23, rw_t> TSEN;
            /*
                VBAT enable
             */
            typedef reg_t<0x50000708, 0x00000001, 24, rw_t> VBATEN;
        };
        /*
            ADC common regular data register for dual
          and triple modes
         */
        namespace CDR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x5000070c, 0xffffffff, 0, ro_t> CDR_REG;
            /*
                Regular data of the slave
              ADC
             */
            typedef reg_t<0x5000070c, 0x0000ffff, 16, ro_t> RDATA_SLV;
            /*
                Regular data of the master
              ADC
             */
            typedef reg_t<0x5000070c, 0x0000ffff, 0, ro_t> RDATA_MST;
        };
    };
    /*
        System configuration controller _Comparator and
      Operational amplifier
     */
    namespace SYSCFG_COMP_OPAMP {
        /*
            configuration register 1
         */
        namespace SYSCFG_CFGR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40010000, 0xffffffff, 0, rw_t> SYSCFG_CFGR1_REG;
            /*
                Memory mapping selection
              bits
             */
            typedef reg_t<0x40010000, 0x00000003, 0, rw_t> MEM_MODE;
            /*
                USB interrupt remap
             */
            typedef reg_t<0x40010000, 0x00000001, 5, rw_t> USB_IT_RMP;
            /*
                Timer 1 ITR3 selection
             */
            typedef reg_t<0x40010000, 0x00000001, 6, rw_t> TIM1_ITR_RMP;
            /*
                DAC trigger remap (when TSEL =
              001)
             */
            typedef reg_t<0x40010000, 0x00000001, 7, rw_t> DAC_TRIG_RMP;
            /*
                ADC24 DMA remapping bit
             */
            typedef reg_t<0x40010000, 0x00000001, 8, rw_t> ADC24_DMA_RMP;
            /*
                TIM16 DMA request remapping
              bit
             */
            typedef reg_t<0x40010000, 0x00000001, 11, rw_t> TIM16_DMA_RMP;
            /*
                TIM17 DMA request remapping
              bit
             */
            typedef reg_t<0x40010000, 0x00000001, 12, rw_t> TIM17_DMA_RMP;
            /*
                TIM6 and DAC1 DMA request remapping
              bit
             */
            typedef reg_t<0x40010000, 0x00000001, 13, rw_t> TIM6_DAC1_DMA_RMP;
            /*
                TIM7 and DAC2 DMA request remapping
              bit
             */
            typedef reg_t<0x40010000, 0x00000001, 14, rw_t> TIM7_DAC2_DMA_RMP;
            /*
                Fast Mode Plus (FM+) driving capability
              activation bits.
             */
            typedef reg_t<0x40010000, 0x00000001, 16, rw_t> I2C_PB6_FM;
            /*
                Fast Mode Plus (FM+) driving capability
              activation bits.
             */
            typedef reg_t<0x40010000, 0x00000001, 17, rw_t> I2C_PB7_FM;
            /*
                Fast Mode Plus (FM+) driving capability
              activation bits.
             */
            typedef reg_t<0x40010000, 0x00000001, 18, rw_t> I2C_PB8_FM;
            /*
                Fast Mode Plus (FM+) driving capability
              activation bits.
             */
            typedef reg_t<0x40010000, 0x00000001, 19, rw_t> I2C_PB9_FM;
            /*
                I2C1 Fast Mode Plus
             */
            typedef reg_t<0x40010000, 0x00000001, 20, rw_t> I2C1_FM;
            /*
                I2C2 Fast Mode Plus
             */
            typedef reg_t<0x40010000, 0x00000001, 21, rw_t> I2C2_FM;
            /*
                Encoder mode
             */
            typedef reg_t<0x40010000, 0x00000003, 22, rw_t> ENCODER_MODE;
            /*
                Interrupt enable bits from
              FPU
             */
            typedef reg_t<0x40010000, 0x0000003f, 26, rw_t> FPU_IT;
        };
        /*
            external interrupt configuration register
          1
         */
        namespace SYSCFG_EXTICR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40010008, 0xffffffff, 0, rw_t> SYSCFG_EXTICR1_REG;
            /*
                EXTI 3 configuration bits
             */
            typedef reg_t<0x40010008, 0x0000000f, 12, rw_t> EXTI3;
            /*
                EXTI 2 configuration bits
             */
            typedef reg_t<0x40010008, 0x0000000f, 8, rw_t> EXTI2;
            /*
                EXTI 1 configuration bits
             */
            typedef reg_t<0x40010008, 0x0000000f, 4, rw_t> EXTI1;
            /*
                EXTI 0 configuration bits
             */
            typedef reg_t<0x40010008, 0x0000000f, 0, rw_t> EXTI0;
        };
        /*
            external interrupt configuration register
          2
         */
        namespace SYSCFG_EXTICR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x4001000c, 0xffffffff, 0, rw_t> SYSCFG_EXTICR2_REG;
            /*
                EXTI 7 configuration bits
             */
            typedef reg_t<0x4001000c, 0x0000000f, 12, rw_t> EXTI7;
            /*
                EXTI 6 configuration bits
             */
            typedef reg_t<0x4001000c, 0x0000000f, 8, rw_t> EXTI6;
            /*
                EXTI 5 configuration bits
             */
            typedef reg_t<0x4001000c, 0x0000000f, 4, rw_t> EXTI5;
            /*
                EXTI 4 configuration bits
             */
            typedef reg_t<0x4001000c, 0x0000000f, 0, rw_t> EXTI4;
        };
        /*
            external interrupt configuration register
          3
         */
        namespace SYSCFG_EXTICR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40010010, 0xffffffff, 0, rw_t> SYSCFG_EXTICR3_REG;
            /*
                EXTI 11 configuration bits
             */
            typedef reg_t<0x40010010, 0x0000000f, 12, rw_t> EXTI11;
            /*
                EXTI 10 configuration bits
             */
            typedef reg_t<0x40010010, 0x0000000f, 8, rw_t> EXTI10;
            /*
                EXTI 9 configuration bits
             */
            typedef reg_t<0x40010010, 0x0000000f, 4, rw_t> EXTI9;
            /*
                EXTI 8 configuration bits
             */
            typedef reg_t<0x40010010, 0x0000000f, 0, rw_t> EXTI8;
        };
        /*
            external interrupt configuration register
          4
         */
        namespace SYSCFG_EXTICR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40010014, 0xffffffff, 0, rw_t> SYSCFG_EXTICR4_REG;
            /*
                EXTI 15 configuration bits
             */
            typedef reg_t<0x40010014, 0x0000000f, 12, rw_t> EXTI15;
            /*
                EXTI 14 configuration bits
             */
            typedef reg_t<0x40010014, 0x0000000f, 8, rw_t> EXTI14;
            /*
                EXTI 13 configuration bits
             */
            typedef reg_t<0x40010014, 0x0000000f, 4, rw_t> EXTI13;
            /*
                EXTI 12 configuration bits
             */
            typedef reg_t<0x40010014, 0x0000000f, 0, rw_t> EXTI12;
        };
        /*
            configuration register 2
         */
        namespace SYSCFG_CFGR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40010018, 0xffffffff, 0, rw_t> SYSCFG_CFGR2_REG;
            /*
                Cortex-M0 LOCKUP bit enable
              bit
             */
            typedef reg_t<0x40010018, 0x00000001, 0, rw_t> LOCUP_LOCK;
            /*
                SRAM parity lock bit
             */
            typedef reg_t<0x40010018, 0x00000001, 1, rw_t> SRAM_PARITY_LOCK;
            /*
                PVD lock enable bit
             */
            typedef reg_t<0x40010018, 0x00000001, 2, rw_t> PVD_LOCK;
            /*
                Bypass address bit 29 in parity
              calculation
             */
            typedef reg_t<0x40010018, 0x00000001, 4, rw_t> BYP_ADD_PAR;
            /*
                SRAM parity flag
             */
            typedef reg_t<0x40010018, 0x00000001, 8, rw_t> SRAM_PEF;
        };
        /*
            CCM SRAM protection register
         */
        namespace SYSCFG_RCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40010004, 0xffffffff, 0, rw_t> SYSCFG_RCR_REG;
            /*
                CCM SRAM page write protection
              bit
             */
            typedef reg_t<0x40010004, 0x00000001, 0, rw_t> PAGE0_WP;
            /*
                CCM SRAM page write protection
              bit
             */
            typedef reg_t<0x40010004, 0x00000001, 1, rw_t> PAGE1_WP;
            /*
                CCM SRAM page write protection
              bit
             */
            typedef reg_t<0x40010004, 0x00000001, 2, rw_t> PAGE2_WP;
            /*
                CCM SRAM page write protection
              bit
             */
            typedef reg_t<0x40010004, 0x00000001, 3, rw_t> PAGE3_WP;
            /*
                CCM SRAM page write protection
              bit
             */
            typedef reg_t<0x40010004, 0x00000001, 4, rw_t> PAGE4_WP;
            /*
                CCM SRAM page write protection
              bit
             */
            typedef reg_t<0x40010004, 0x00000001, 5, rw_t> PAGE5_WP;
            /*
                CCM SRAM page write protection
              bit
             */
            typedef reg_t<0x40010004, 0x00000001, 6, rw_t> PAGE6_WP;
            /*
                CCM SRAM page write protection
              bit
             */
            typedef reg_t<0x40010004, 0x00000001, 7, rw_t> PAGE7_WP;
        };
        /*
            control and status register
         */
        namespace COMP1_CSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Comparator 1 enable
             */
            typedef reg_t<0x4001001c, 0x00000001, 0, rw_t> COMP1EN;
            /*
                COMP1_INP_DAC
             */
            typedef reg_t<0x4001001c, 0x00000001, 1, rw_t> COMP1_INP_DAC;
            /*
                Comparator 1 mode
             */
            typedef reg_t<0x4001001c, 0x00000003, 2, rw_t> COMP1MODE;
            /*
                Comparator 1 inverting input
              selection
             */
            typedef reg_t<0x4001001c, 0x00000007, 4, rw_t> COMP1INSEL;
            /*
                Comparator 1 output
              selection
             */
            typedef reg_t<0x4001001c, 0x0000000f, 10, rw_t> COMP1_OUT_SEL;
            /*
                Comparator 1 output
              polarity
             */
            typedef reg_t<0x4001001c, 0x00000001, 15, rw_t> COMP1POL;
            /*
                Comparator 1 hysteresis
             */
            typedef reg_t<0x4001001c, 0x00000003, 16, rw_t> COMP1HYST;
            /*
                Comparator 1 blanking
              source
             */
            typedef reg_t<0x4001001c, 0x00000007, 18, rw_t> COMP1_BLANKING;
            /*
                Comparator 1 output
             */
            typedef reg_t<0x4001001c, 0x00000001, 30, ro_t> COMP1OUT;
            /*
                Comparator 1 lock
             */
            typedef reg_t<0x4001001c, 0x00000001, 31, rw_t> COMP1LOCK;
        };
        /*
            control and status register
         */
        namespace COMP2_CSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0x40010020, 0xffffffff, 0, rw_t> COMP2_CSR_REG;
            /*
                Comparator 2 enable
             */
            typedef reg_t<0x40010020, 0x00000001, 0, rw_t> COMP2EN;
            /*
                Comparator 2 mode
             */
            typedef reg_t<0x40010020, 0x00000003, 2, rw_t> COMP2MODE;
            /*
                Comparator 2 inverting input
              selection
             */
            typedef reg_t<0x40010020, 0x00000007, 4, rw_t> COMP2INSEL;
            /*
                Comparator 2 non inverted input
              selection
             */
            typedef reg_t<0x40010020, 0x00000001, 7, rw_t> COMP2INPSEL;
            /*
                Comparator 1inverting input
              selection
             */
            typedef reg_t<0x40010020, 0x00000001, 9, rw_t> COMP2INMSEL;
            /*
                Comparator 2 output
              selection
             */
            typedef reg_t<0x40010020, 0x0000000f, 10, rw_t> COMP2_OUT_SEL;
            /*
                Comparator 2 output
              polarity
             */
            typedef reg_t<0x40010020, 0x00000001, 15, rw_t> COMP2POL;
            /*
                Comparator 2 hysteresis
             */
            typedef reg_t<0x40010020, 0x00000003, 16, rw_t> COMP2HYST;
            /*
                Comparator 2 blanking
              source
             */
            typedef reg_t<0x40010020, 0x00000007, 18, rw_t> COMP2_BLANKING;
            /*
                Comparator 2 lock
             */
            typedef reg_t<0x40010020, 0x00000001, 31, rw_t> COMP2LOCK;
        };
        /*
            control and status register
         */
        namespace COMP3_CSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Comparator 3 enable
             */
            typedef reg_t<0x40010024, 0x00000001, 0, rw_t> COMP3EN;
            /*
                Comparator 3 mode
             */
            typedef reg_t<0x40010024, 0x00000003, 2, rw_t> COMP3MODE;
            /*
                Comparator 3 inverting input
              selection
             */
            typedef reg_t<0x40010024, 0x00000007, 4, rw_t> COMP3INSEL;
            /*
                Comparator 3 non inverted input
              selection
             */
            typedef reg_t<0x40010024, 0x00000001, 7, rw_t> COMP3INPSEL;
            /*
                Comparator 3 output
              selection
             */
            typedef reg_t<0x40010024, 0x0000000f, 10, rw_t> COMP3_OUT_SEL;
            /*
                Comparator 3 output
              polarity
             */
            typedef reg_t<0x40010024, 0x00000001, 15, rw_t> COMP3POL;
            /*
                Comparator 3 hysteresis
             */
            typedef reg_t<0x40010024, 0x00000003, 16, rw_t> COMP3HYST;
            /*
                Comparator 3 blanking
              source
             */
            typedef reg_t<0x40010024, 0x00000007, 18, rw_t> COMP3_BLANKING;
            /*
                Comparator 3 output
             */
            typedef reg_t<0x40010024, 0x00000001, 30, ro_t> COMP3OUT;
            /*
                Comparator 3 lock
             */
            typedef reg_t<0x40010024, 0x00000001, 31, rw_t> COMP3LOCK;
        };
        /*
            control and status register
         */
        namespace COMP4_CSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Comparator 4 enable
             */
            typedef reg_t<0x40010028, 0x00000001, 0, rw_t> COMP4EN;
            /*
                Comparator 4 mode
             */
            typedef reg_t<0x40010028, 0x00000003, 2, rw_t> COMP4MODE;
            /*
                Comparator 4 inverting input
              selection
             */
            typedef reg_t<0x40010028, 0x00000007, 4, rw_t> COMP4INSEL;
            /*
                Comparator 4 non inverted input
              selection
             */
            typedef reg_t<0x40010028, 0x00000001, 7, rw_t> COMP4INPSEL;
            /*
                Comparator 4 window mode
             */
            typedef reg_t<0x40010028, 0x00000001, 9, rw_t> COM4WINMODE;
            /*
                Comparator 4 output
              selection
             */
            typedef reg_t<0x40010028, 0x0000000f, 10, rw_t> COMP4_OUT_SEL;
            /*
                Comparator 4 output
              polarity
             */
            typedef reg_t<0x40010028, 0x00000001, 15, rw_t> COMP4POL;
            /*
                Comparator 4 hysteresis
             */
            typedef reg_t<0x40010028, 0x00000003, 16, rw_t> COMP4HYST;
            /*
                Comparator 4 blanking
              source
             */
            typedef reg_t<0x40010028, 0x00000007, 18, rw_t> COMP4_BLANKING;
            /*
                Comparator 4 output
             */
            typedef reg_t<0x40010028, 0x00000001, 30, ro_t> COMP4OUT;
            /*
                Comparator 4 lock
             */
            typedef reg_t<0x40010028, 0x00000001, 31, rw_t> COMP4LOCK;
        };
        /*
            control and status register
         */
        namespace COMP5_CSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Comparator 5 enable
             */
            typedef reg_t<0x4001002c, 0x00000001, 0, rw_t> COMP5EN;
            /*
                Comparator 5 mode
             */
            typedef reg_t<0x4001002c, 0x00000003, 2, rw_t> COMP5MODE;
            /*
                Comparator 5 inverting input
              selection
             */
            typedef reg_t<0x4001002c, 0x00000007, 4, rw_t> COMP5INSEL;
            /*
                Comparator 5 non inverted input
              selection
             */
            typedef reg_t<0x4001002c, 0x00000001, 7, rw_t> COMP5INPSEL;
            /*
                Comparator 5 output
              selection
             */
            typedef reg_t<0x4001002c, 0x0000000f, 10, rw_t> COMP5_OUT_SEL;
            /*
                Comparator 5 output
              polarity
             */
            typedef reg_t<0x4001002c, 0x00000001, 15, rw_t> COMP5POL;
            /*
                Comparator 5 hysteresis
             */
            typedef reg_t<0x4001002c, 0x00000003, 16, rw_t> COMP5HYST;
            /*
                Comparator 5 blanking
              source
             */
            typedef reg_t<0x4001002c, 0x00000007, 18, rw_t> COMP5_BLANKING;
            /*
                Comparator51 output
             */
            typedef reg_t<0x4001002c, 0x00000001, 30, ro_t> COMP5OUT;
            /*
                Comparator 5 lock
             */
            typedef reg_t<0x4001002c, 0x00000001, 31, rw_t> COMP5LOCK;
        };
        /*
            control and status register
         */
        namespace COMP6_CSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Comparator 6 enable
             */
            typedef reg_t<0x40010030, 0x00000001, 0, rw_t> COMP6EN;
            /*
                Comparator 6 mode
             */
            typedef reg_t<0x40010030, 0x00000003, 2, rw_t> COMP6MODE;
            /*
                Comparator 6 inverting input
              selection
             */
            typedef reg_t<0x40010030, 0x00000007, 4, rw_t> COMP6INSEL;
            /*
                Comparator 6 non inverted input
              selection
             */
            typedef reg_t<0x40010030, 0x00000001, 7, rw_t> COMP6INPSEL;
            /*
                Comparator 6 window mode
             */
            typedef reg_t<0x40010030, 0x00000001, 9, rw_t> COM6WINMODE;
            /*
                Comparator 6 output
              selection
             */
            typedef reg_t<0x40010030, 0x0000000f, 10, rw_t> COMP6_OUT_SEL;
            /*
                Comparator 6 output
              polarity
             */
            typedef reg_t<0x40010030, 0x00000001, 15, rw_t> COMP6POL;
            /*
                Comparator 6 hysteresis
             */
            typedef reg_t<0x40010030, 0x00000003, 16, rw_t> COMP6HYST;
            /*
                Comparator 6 blanking
              source
             */
            typedef reg_t<0x40010030, 0x00000007, 18, rw_t> COMP6_BLANKING;
            /*
                Comparator 6 output
             */
            typedef reg_t<0x40010030, 0x00000001, 30, ro_t> COMP6OUT;
            /*
                Comparator 6 lock
             */
            typedef reg_t<0x40010030, 0x00000001, 31, rw_t> COMP6LOCK;
        };
        /*
            control and status register
         */
        namespace COMP7_CSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                Comparator 7 enable
             */
            typedef reg_t<0x40010034, 0x00000001, 0, rw_t> COMP7EN;
            /*
                Comparator 7 mode
             */
            typedef reg_t<0x40010034, 0x00000003, 2, rw_t> COMP7MODE;
            /*
                Comparator 7 inverting input
              selection
             */
            typedef reg_t<0x40010034, 0x00000007, 4, rw_t> COMP7INSEL;
            /*
                Comparator 7 non inverted input
              selection
             */
            typedef reg_t<0x40010034, 0x00000001, 7, rw_t> COMP7INPSEL;
            /*
                Comparator 7 output
              selection
             */
            typedef reg_t<0x40010034, 0x0000000f, 10, rw_t> COMP7_OUT_SEL;
            /*
                Comparator 7 output
              polarity
             */
            typedef reg_t<0x40010034, 0x00000001, 15, rw_t> COMP7POL;
            /*
                Comparator 7 hysteresis
             */
            typedef reg_t<0x40010034, 0x00000003, 16, rw_t> COMP7HYST;
            /*
                Comparator 7 blanking
              source
             */
            typedef reg_t<0x40010034, 0x00000007, 18, rw_t> COMP7_BLANKING;
            /*
                Comparator 7 output
             */
            typedef reg_t<0x40010034, 0x00000001, 30, ro_t> COMP7OUT;
            /*
                Comparator 7 lock
             */
            typedef reg_t<0x40010034, 0x00000001, 31, rw_t> COMP7LOCK;
        };
        /*
            control register
         */
        namespace OPAMP1_CSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                OPAMP1 enable
             */
            typedef reg_t<0x40010038, 0x00000001, 0, rw_t> OPAMP1_EN;
            /*
                FORCE_VP
             */
            typedef reg_t<0x40010038, 0x00000001, 1, rw_t> FORCE_VP;
            /*
                OPAMP1 Non inverting input
              selection
             */
            typedef reg_t<0x40010038, 0x00000003, 2, rw_t> VP_SEL;
            /*
                OPAMP1 inverting input
              selection
             */
            typedef reg_t<0x40010038, 0x00000003, 5, rw_t> VM_SEL;
            /*
                Timer controlled Mux mode
              enable
             */
            typedef reg_t<0x40010038, 0x00000001, 7, rw_t> TCM_EN;
            /*
                OPAMP1 inverting input secondary
              selection
             */
            typedef reg_t<0x40010038, 0x00000001, 8, rw_t> VMS_SEL;
            /*
                OPAMP1 Non inverting input secondary
              selection
             */
            typedef reg_t<0x40010038, 0x00000003, 9, rw_t> VPS_SEL;
            /*
                Calibration mode enable
             */
            typedef reg_t<0x40010038, 0x00000001, 11, rw_t> CALON;
            /*
                Calibration selection
             */
            typedef reg_t<0x40010038, 0x00000003, 12, rw_t> CALSEL;
            /*
                Gain in PGA mode
             */
            typedef reg_t<0x40010038, 0x0000000f, 14, rw_t> PGA_GAIN;
            /*
                User trimming enable
             */
            typedef reg_t<0x40010038, 0x00000001, 18, rw_t> USER_TRIM;
            /*
                Offset trimming value
              (PMOS)
             */
            typedef reg_t<0x40010038, 0x0000001f, 19, rw_t> TRIMOFFSETP;
            /*
                Offset trimming value
              (NMOS)
             */
            typedef reg_t<0x40010038, 0x0000001f, 24, rw_t> TRIMOFFSETN;
            /*
                TSTREF
             */
            typedef reg_t<0x40010038, 0x00000001, 29, rw_t> TSTREF;
            /*
                OPAMP 1 ouput status flag
             */
            typedef reg_t<0x40010038, 0x00000001, 30, ro_t> OUTCAL;
            /*
                OPAMP 1 lock
             */
            typedef reg_t<0x40010038, 0x00000001, 31, rw_t> LOCK;
        };
        /*
            control register
         */
        namespace OPAMP2_CSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                OPAMP2 enable
             */
            typedef reg_t<0x4001003c, 0x00000001, 0, rw_t> OPAMP2EN;
            /*
                FORCE_VP
             */
            typedef reg_t<0x4001003c, 0x00000001, 1, rw_t> FORCE_VP;
            /*
                OPAMP2 Non inverting input
              selection
             */
            typedef reg_t<0x4001003c, 0x00000003, 2, rw_t> VP_SEL;
            /*
                OPAMP2 inverting input
              selection
             */
            typedef reg_t<0x4001003c, 0x00000003, 5, rw_t> VM_SEL;
            /*
                Timer controlled Mux mode
              enable
             */
            typedef reg_t<0x4001003c, 0x00000001, 7, rw_t> TCM_EN;
            /*
                OPAMP2 inverting input secondary
              selection
             */
            typedef reg_t<0x4001003c, 0x00000001, 8, rw_t> VMS_SEL;
            /*
                OPAMP2 Non inverting input secondary
              selection
             */
            typedef reg_t<0x4001003c, 0x00000003, 9, rw_t> VPS_SEL;
            /*
                Calibration mode enable
             */
            typedef reg_t<0x4001003c, 0x00000001, 11, rw_t> CALON;
            /*
                Calibration selection
             */
            typedef reg_t<0x4001003c, 0x00000003, 12, rw_t> CAL_SEL;
            /*
                Gain in PGA mode
             */
            typedef reg_t<0x4001003c, 0x0000000f, 14, rw_t> PGA_GAIN;
            /*
                User trimming enable
             */
            typedef reg_t<0x4001003c, 0x00000001, 18, rw_t> USER_TRIM;
            /*
                Offset trimming value
              (PMOS)
             */
            typedef reg_t<0x4001003c, 0x0000001f, 19, rw_t> TRIMOFFSETP;
            /*
                Offset trimming value
              (NMOS)
             */
            typedef reg_t<0x4001003c, 0x0000001f, 24, rw_t> TRIMOFFSETN;
            /*
                TSTREF
             */
            typedef reg_t<0x4001003c, 0x00000001, 29, rw_t> TSTREF;
            /*
                OPAMP 2 ouput status flag
             */
            typedef reg_t<0x4001003c, 0x00000001, 30, ro_t> OUTCAL;
            /*
                OPAMP 2 lock
             */
            typedef reg_t<0x4001003c, 0x00000001, 31, rw_t> LOCK;
        };
        /*
            control register
         */
        namespace OPAMP3_CSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                OPAMP3 enable
             */
            typedef reg_t<0x40010040, 0x00000001, 0, rw_t> OPAMP3EN;
            /*
                FORCE_VP
             */
            typedef reg_t<0x40010040, 0x00000001, 1, rw_t> FORCE_VP;
            /*
                OPAMP3 Non inverting input
              selection
             */
            typedef reg_t<0x40010040, 0x00000003, 2, rw_t> VP_SEL;
            /*
                OPAMP3 inverting input
              selection
             */
            typedef reg_t<0x40010040, 0x00000003, 5, rw_t> VM_SEL;
            /*
                Timer controlled Mux mode
              enable
             */
            typedef reg_t<0x40010040, 0x00000001, 7, rw_t> TCM_EN;
            /*
                OPAMP3 inverting input secondary
              selection
             */
            typedef reg_t<0x40010040, 0x00000001, 8, rw_t> VMS_SEL;
            /*
                OPAMP3 Non inverting input secondary
              selection
             */
            typedef reg_t<0x40010040, 0x00000003, 9, rw_t> VPS_SEL;
            /*
                Calibration mode enable
             */
            typedef reg_t<0x40010040, 0x00000001, 11, rw_t> CALON;
            /*
                Calibration selection
             */
            typedef reg_t<0x40010040, 0x00000003, 12, rw_t> CALSEL;
            /*
                Gain in PGA mode
             */
            typedef reg_t<0x40010040, 0x0000000f, 14, rw_t> PGA_GAIN;
            /*
                User trimming enable
             */
            typedef reg_t<0x40010040, 0x00000001, 18, rw_t> USER_TRIM;
            /*
                Offset trimming value
              (PMOS)
             */
            typedef reg_t<0x40010040, 0x0000001f, 19, rw_t> TRIMOFFSETP;
            /*
                Offset trimming value
              (NMOS)
             */
            typedef reg_t<0x40010040, 0x0000001f, 24, rw_t> TRIMOFFSETN;
            /*
                TSTREF
             */
            typedef reg_t<0x40010040, 0x00000001, 29, rw_t> TSTREF;
            /*
                OPAMP 3 ouput status flag
             */
            typedef reg_t<0x40010040, 0x00000001, 30, ro_t> OUTCAL;
            /*
                OPAMP 3 lock
             */
            typedef reg_t<0x40010040, 0x00000001, 31, rw_t> LOCK;
        };
        /*
            control register
         */
        namespace OPAMP4_CSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            /*
                OPAMP4 enable
             */
            typedef reg_t<0x40010044, 0x00000001, 0, rw_t> OPAMP4EN;
            /*
                FORCE_VP
             */
            typedef reg_t<0x40010044, 0x00000001, 1, rw_t> FORCE_VP;
            /*
                OPAMP4 Non inverting input
              selection
             */
            typedef reg_t<0x40010044, 0x00000003, 2, rw_t> VP_SEL;
            /*
                OPAMP4 inverting input
              selection
             */
            typedef reg_t<0x40010044, 0x00000003, 5, rw_t> VM_SEL;
            /*
                Timer controlled Mux mode
              enable
             */
            typedef reg_t<0x40010044, 0x00000001, 7, rw_t> TCM_EN;
            /*
                OPAMP4 inverting input secondary
              selection
             */
            typedef reg_t<0x40010044, 0x00000001, 8, rw_t> VMS_SEL;
            /*
                OPAMP4 Non inverting input secondary
              selection
             */
            typedef reg_t<0x40010044, 0x00000003, 9, rw_t> VPS_SEL;
            /*
                Calibration mode enable
             */
            typedef reg_t<0x40010044, 0x00000001, 11, rw_t> CALON;
            /*
                Calibration selection
             */
            typedef reg_t<0x40010044, 0x00000003, 12, rw_t> CALSEL;
            /*
                Gain in PGA mode
             */
            typedef reg_t<0x40010044, 0x0000000f, 14, rw_t> PGA_GAIN;
            /*
                User trimming enable
             */
            typedef reg_t<0x40010044, 0x00000001, 18, rw_t> USER_TRIM;
            /*
                Offset trimming value
              (PMOS)
             */
            typedef reg_t<0x40010044, 0x0000001f, 19, rw_t> TRIMOFFSETP;
            /*
                Offset trimming value
              (NMOS)
             */
            typedef reg_t<0x40010044, 0x0000001f, 24, rw_t> TRIMOFFSETN;
            /*
                TSTREF
             */
            typedef reg_t<0x40010044, 0x00000001, 29, rw_t> TSTREF;
            /*
                OPAMP 4 ouput status flag
             */
            typedef reg_t<0x40010044, 0x00000001, 30, ro_t> OUTCAL;
            /*
                OPAMP 4 lock
             */
            typedef reg_t<0x40010044, 0x00000001, 31, rw_t> LOCK;
        };
    };
    /*
        Flexible memory controller
     */
    namespace FMC {
        /*
            SRAM/NOR-Flash chip-select control register
          1
         */
        namespace BCR1 {

            static constexpr uint32_t RESETVALUE = 0x000030d0;
            typedef reg_t<0xa0000400, 0xffffffff, 0, rw_t> BCR1_REG;
            /*
                CCLKEN
             */
            typedef reg_t<0xa0000400, 0x00000001, 20, rw_t> CCLKEN;
            /*
                CBURSTRW
             */
            typedef reg_t<0xa0000400, 0x00000001, 19, rw_t> CBURSTRW;
            /*
                ASYNCWAIT
             */
            typedef reg_t<0xa0000400, 0x00000001, 15, rw_t> ASYNCWAIT;
            /*
                EXTMOD
             */
            typedef reg_t<0xa0000400, 0x00000001, 14, rw_t> EXTMOD;
            /*
                WAITEN
             */
            typedef reg_t<0xa0000400, 0x00000001, 13, rw_t> WAITEN;
            /*
                WREN
             */
            typedef reg_t<0xa0000400, 0x00000001, 12, rw_t> WREN;
            /*
                WAITCFG
             */
            typedef reg_t<0xa0000400, 0x00000001, 11, rw_t> WAITCFG;
            /*
                WAITPOL
             */
            typedef reg_t<0xa0000400, 0x00000001, 9, rw_t> WAITPOL;
            /*
                BURSTEN
             */
            typedef reg_t<0xa0000400, 0x00000001, 8, rw_t> BURSTEN;
            /*
                FACCEN
             */
            typedef reg_t<0xa0000400, 0x00000001, 6, rw_t> FACCEN;
            /*
                MWID
             */
            typedef reg_t<0xa0000400, 0x00000003, 4, rw_t> MWID;
            /*
                MTYP
             */
            typedef reg_t<0xa0000400, 0x00000003, 2, rw_t> MTYP;
            /*
                MUXEN
             */
            typedef reg_t<0xa0000400, 0x00000001, 1, rw_t> MUXEN;
            /*
                MBKEN
             */
            typedef reg_t<0xa0000400, 0x00000001, 0, rw_t> MBKEN;
        };
        /*
            SRAM/NOR-Flash chip-select timing register
          1
         */
        namespace BTR1 {

            static constexpr uint32_t RESETVALUE = 0xffffffff;
            typedef reg_t<0xa0000404, 0xffffffff, 0, rw_t> BTR1_REG;
            /*
                ACCMOD
             */
            typedef reg_t<0xa0000404, 0x00000003, 28, rw_t> ACCMOD;
            /*
                DATLAT
             */
            typedef reg_t<0xa0000404, 0x0000000f, 24, rw_t> DATLAT;
            /*
                CLKDIV
             */
            typedef reg_t<0xa0000404, 0x0000000f, 20, rw_t> CLKDIV;
            /*
                BUSTURN
             */
            typedef reg_t<0xa0000404, 0x0000000f, 16, rw_t> BUSTURN;
            /*
                DATAST
             */
            typedef reg_t<0xa0000404, 0x000000ff, 8, rw_t> DATAST;
            /*
                ADDHLD
             */
            typedef reg_t<0xa0000404, 0x0000000f, 4, rw_t> ADDHLD;
            /*
                ADDSET
             */
            typedef reg_t<0xa0000404, 0x0000000f, 0, rw_t> ADDSET;
        };
        /*
            SRAM/NOR-Flash chip-select control register
          2
         */
        namespace BCR2 {

            static constexpr uint32_t RESETVALUE = 0x000030d0;
            typedef reg_t<0xa0000408, 0xffffffff, 0, rw_t> BCR2_REG;
            /*
                CBURSTRW
             */
            typedef reg_t<0xa0000408, 0x00000001, 19, rw_t> CBURSTRW;
            /*
                ASYNCWAIT
             */
            typedef reg_t<0xa0000408, 0x00000001, 15, rw_t> ASYNCWAIT;
            /*
                EXTMOD
             */
            typedef reg_t<0xa0000408, 0x00000001, 14, rw_t> EXTMOD;
            /*
                WAITEN
             */
            typedef reg_t<0xa0000408, 0x00000001, 13, rw_t> WAITEN;
            /*
                WREN
             */
            typedef reg_t<0xa0000408, 0x00000001, 12, rw_t> WREN;
            /*
                WAITCFG
             */
            typedef reg_t<0xa0000408, 0x00000001, 11, rw_t> WAITCFG;
            /*
                WRAPMOD
             */
            typedef reg_t<0xa0000408, 0x00000001, 10, rw_t> WRAPMOD;
            /*
                WAITPOL
             */
            typedef reg_t<0xa0000408, 0x00000001, 9, rw_t> WAITPOL;
            /*
                BURSTEN
             */
            typedef reg_t<0xa0000408, 0x00000001, 8, rw_t> BURSTEN;
            /*
                FACCEN
             */
            typedef reg_t<0xa0000408, 0x00000001, 6, rw_t> FACCEN;
            /*
                MWID
             */
            typedef reg_t<0xa0000408, 0x00000003, 4, rw_t> MWID;
            /*
                MTYP
             */
            typedef reg_t<0xa0000408, 0x00000003, 2, rw_t> MTYP;
            /*
                MUXEN
             */
            typedef reg_t<0xa0000408, 0x00000001, 1, rw_t> MUXEN;
            /*
                MBKEN
             */
            typedef reg_t<0xa0000408, 0x00000001, 0, rw_t> MBKEN;
        };
        /*
            SRAM/NOR-Flash chip-select timing register
          2
         */
        namespace BTR2 {

            static constexpr uint32_t RESETVALUE = 0xffffffff;
            typedef reg_t<0xa000040c, 0xffffffff, 0, rw_t> BTR2_REG;
            /*
                ACCMOD
             */
            typedef reg_t<0xa000040c, 0x00000003, 28, rw_t> ACCMOD;
            /*
                DATLAT
             */
            typedef reg_t<0xa000040c, 0x0000000f, 24, rw_t> DATLAT;
            /*
                CLKDIV
             */
            typedef reg_t<0xa000040c, 0x0000000f, 20, rw_t> CLKDIV;
            /*
                BUSTURN
             */
            typedef reg_t<0xa000040c, 0x0000000f, 16, rw_t> BUSTURN;
            /*
                DATAST
             */
            typedef reg_t<0xa000040c, 0x000000ff, 8, rw_t> DATAST;
            /*
                ADDHLD
             */
            typedef reg_t<0xa000040c, 0x0000000f, 4, rw_t> ADDHLD;
            /*
                ADDSET
             */
            typedef reg_t<0xa000040c, 0x0000000f, 0, rw_t> ADDSET;
        };
        /*
            SRAM/NOR-Flash chip-select control register
          3
         */
        namespace BCR3 {

            static constexpr uint32_t RESETVALUE = 0x000030d0;
            typedef reg_t<0xa0000410, 0xffffffff, 0, rw_t> BCR3_REG;
            /*
                CBURSTRW
             */
            typedef reg_t<0xa0000410, 0x00000001, 19, rw_t> CBURSTRW;
            /*
                ASYNCWAIT
             */
            typedef reg_t<0xa0000410, 0x00000001, 15, rw_t> ASYNCWAIT;
            /*
                EXTMOD
             */
            typedef reg_t<0xa0000410, 0x00000001, 14, rw_t> EXTMOD;
            /*
                WAITEN
             */
            typedef reg_t<0xa0000410, 0x00000001, 13, rw_t> WAITEN;
            /*
                WREN
             */
            typedef reg_t<0xa0000410, 0x00000001, 12, rw_t> WREN;
            /*
                WAITCFG
             */
            typedef reg_t<0xa0000410, 0x00000001, 11, rw_t> WAITCFG;
            /*
                WRAPMOD
             */
            typedef reg_t<0xa0000410, 0x00000001, 10, rw_t> WRAPMOD;
            /*
                WAITPOL
             */
            typedef reg_t<0xa0000410, 0x00000001, 9, rw_t> WAITPOL;
            /*
                BURSTEN
             */
            typedef reg_t<0xa0000410, 0x00000001, 8, rw_t> BURSTEN;
            /*
                FACCEN
             */
            typedef reg_t<0xa0000410, 0x00000001, 6, rw_t> FACCEN;
            /*
                MWID
             */
            typedef reg_t<0xa0000410, 0x00000003, 4, rw_t> MWID;
            /*
                MTYP
             */
            typedef reg_t<0xa0000410, 0x00000003, 2, rw_t> MTYP;
            /*
                MUXEN
             */
            typedef reg_t<0xa0000410, 0x00000001, 1, rw_t> MUXEN;
            /*
                MBKEN
             */
            typedef reg_t<0xa0000410, 0x00000001, 0, rw_t> MBKEN;
        };
        /*
            SRAM/NOR-Flash chip-select timing register
          3
         */
        namespace BTR3 {

            static constexpr uint32_t RESETVALUE = 0xffffffff;
            typedef reg_t<0xa0000414, 0xffffffff, 0, rw_t> BTR3_REG;
            /*
                ACCMOD
             */
            typedef reg_t<0xa0000414, 0x00000003, 28, rw_t> ACCMOD;
            /*
                DATLAT
             */
            typedef reg_t<0xa0000414, 0x0000000f, 24, rw_t> DATLAT;
            /*
                CLKDIV
             */
            typedef reg_t<0xa0000414, 0x0000000f, 20, rw_t> CLKDIV;
            /*
                BUSTURN
             */
            typedef reg_t<0xa0000414, 0x0000000f, 16, rw_t> BUSTURN;
            /*
                DATAST
             */
            typedef reg_t<0xa0000414, 0x000000ff, 8, rw_t> DATAST;
            /*
                ADDHLD
             */
            typedef reg_t<0xa0000414, 0x0000000f, 4, rw_t> ADDHLD;
            /*
                ADDSET
             */
            typedef reg_t<0xa0000414, 0x0000000f, 0, rw_t> ADDSET;
        };
        /*
            SRAM/NOR-Flash chip-select control register
          4
         */
        namespace BCR4 {

            static constexpr uint32_t RESETVALUE = 0x000030d0;
            typedef reg_t<0xa0000418, 0xffffffff, 0, rw_t> BCR4_REG;
            /*
                CBURSTRW
             */
            typedef reg_t<0xa0000418, 0x00000001, 19, rw_t> CBURSTRW;
            /*
                ASYNCWAIT
             */
            typedef reg_t<0xa0000418, 0x00000001, 15, rw_t> ASYNCWAIT;
            /*
                EXTMOD
             */
            typedef reg_t<0xa0000418, 0x00000001, 14, rw_t> EXTMOD;
            /*
                WAITEN
             */
            typedef reg_t<0xa0000418, 0x00000001, 13, rw_t> WAITEN;
            /*
                WREN
             */
            typedef reg_t<0xa0000418, 0x00000001, 12, rw_t> WREN;
            /*
                WAITCFG
             */
            typedef reg_t<0xa0000418, 0x00000001, 11, rw_t> WAITCFG;
            /*
                WRAPMOD
             */
            typedef reg_t<0xa0000418, 0x00000001, 10, rw_t> WRAPMOD;
            /*
                WAITPOL
             */
            typedef reg_t<0xa0000418, 0x00000001, 9, rw_t> WAITPOL;
            /*
                BURSTEN
             */
            typedef reg_t<0xa0000418, 0x00000001, 8, rw_t> BURSTEN;
            /*
                FACCEN
             */
            typedef reg_t<0xa0000418, 0x00000001, 6, rw_t> FACCEN;
            /*
                MWID
             */
            typedef reg_t<0xa0000418, 0x00000003, 4, rw_t> MWID;
            /*
                MTYP
             */
            typedef reg_t<0xa0000418, 0x00000003, 2, rw_t> MTYP;
            /*
                MUXEN
             */
            typedef reg_t<0xa0000418, 0x00000001, 1, rw_t> MUXEN;
            /*
                MBKEN
             */
            typedef reg_t<0xa0000418, 0x00000001, 0, rw_t> MBKEN;
        };
        /*
            SRAM/NOR-Flash chip-select timing register
          4
         */
        namespace BTR4 {

            static constexpr uint32_t RESETVALUE = 0xffffffff;
            typedef reg_t<0xa000041c, 0xffffffff, 0, rw_t> BTR4_REG;
            /*
                ACCMOD
             */
            typedef reg_t<0xa000041c, 0x00000003, 28, rw_t> ACCMOD;
            /*
                DATLAT
             */
            typedef reg_t<0xa000041c, 0x0000000f, 24, rw_t> DATLAT;
            /*
                CLKDIV
             */
            typedef reg_t<0xa000041c, 0x0000000f, 20, rw_t> CLKDIV;
            /*
                BUSTURN
             */
            typedef reg_t<0xa000041c, 0x0000000f, 16, rw_t> BUSTURN;
            /*
                DATAST
             */
            typedef reg_t<0xa000041c, 0x000000ff, 8, rw_t> DATAST;
            /*
                ADDHLD
             */
            typedef reg_t<0xa000041c, 0x0000000f, 4, rw_t> ADDHLD;
            /*
                ADDSET
             */
            typedef reg_t<0xa000041c, 0x0000000f, 0, rw_t> ADDSET;
        };
        /*
            PC Card/NAND Flash control register
          2
         */
        namespace PCR2 {

            static constexpr uint32_t RESETVALUE = 0x00000018;
            typedef reg_t<0xa0000460, 0xffffffff, 0, rw_t> PCR2_REG;
            /*
                ECCPS
             */
            typedef reg_t<0xa0000460, 0x00000007, 17, rw_t> ECCPS;
            /*
                TAR
             */
            typedef reg_t<0xa0000460, 0x0000000f, 13, rw_t> TAR;
            /*
                TCLR
             */
            typedef reg_t<0xa0000460, 0x0000000f, 9, rw_t> TCLR;
            /*
                ECCEN
             */
            typedef reg_t<0xa0000460, 0x00000001, 6, rw_t> ECCEN;
            /*
                PWID
             */
            typedef reg_t<0xa0000460, 0x00000003, 4, rw_t> PWID;
            /*
                PTYP
             */
            typedef reg_t<0xa0000460, 0x00000001, 3, rw_t> PTYP;
            /*
                PBKEN
             */
            typedef reg_t<0xa0000460, 0x00000001, 2, rw_t> PBKEN;
            /*
                PWAITEN
             */
            typedef reg_t<0xa0000460, 0x00000001, 1, rw_t> PWAITEN;
        };
        /*
            FIFO status and interrupt register
          2
         */
        namespace SR2 {

            static constexpr uint32_t RESETVALUE = 0x00000040;
            /*
                FEMPT
             */
            typedef reg_t<0xa0000464, 0x00000001, 6, ro_t> FEMPT;
            /*
                IFEN
             */
            typedef reg_t<0xa0000464, 0x00000001, 5, rw_t> IFEN;
            /*
                ILEN
             */
            typedef reg_t<0xa0000464, 0x00000001, 4, rw_t> ILEN;
            /*
                IREN
             */
            typedef reg_t<0xa0000464, 0x00000001, 3, rw_t> IREN;
            /*
                IFS
             */
            typedef reg_t<0xa0000464, 0x00000001, 2, rw_t> IFS;
            /*
                ILS
             */
            typedef reg_t<0xa0000464, 0x00000001, 1, rw_t> ILS;
            /*
                IRS
             */
            typedef reg_t<0xa0000464, 0x00000001, 0, rw_t> IRS;
        };
        /*
            Common memory space timing register
          2
         */
        namespace PMEM2 {

            static constexpr uint32_t RESETVALUE = 0xfcfcfcfc;
            typedef reg_t<0xa0000468, 0xffffffff, 0, rw_t> PMEM2_REG;
            /*
                MEMHIZx
             */
            typedef reg_t<0xa0000468, 0x000000ff, 24, rw_t> MEMHIZx;
            /*
                MEMHOLDx
             */
            typedef reg_t<0xa0000468, 0x000000ff, 16, rw_t> MEMHOLDx;
            /*
                MEMWAITx
             */
            typedef reg_t<0xa0000468, 0x000000ff, 8, rw_t> MEMWAITx;
            /*
                MEMSETx
             */
            typedef reg_t<0xa0000468, 0x000000ff, 0, rw_t> MEMSETx;
        };
        /*
            Attribute memory space timing register
          2
         */
        namespace PATT2 {

            static constexpr uint32_t RESETVALUE = 0xfcfcfcfc;
            typedef reg_t<0xa000046c, 0xffffffff, 0, rw_t> PATT2_REG;
            /*
                ATTHIZx
             */
            typedef reg_t<0xa000046c, 0x000000ff, 24, rw_t> ATTHIZx;
            /*
                ATTHOLDx
             */
            typedef reg_t<0xa000046c, 0x000000ff, 16, rw_t> ATTHOLDx;
            /*
                ATTWAITx
             */
            typedef reg_t<0xa000046c, 0x000000ff, 8, rw_t> ATTWAITx;
            /*
                ATTSETx
             */
            typedef reg_t<0xa000046c, 0x000000ff, 0, rw_t> ATTSETx;
        };
        /*
            ECC result register 2
         */
        namespace ECCR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xa0000474, 0xffffffff, 0, ro_t> ECCR2_REG;
            /*
                ECCx
             */
            typedef reg_t<0xa0000474, 0xffffffff, 0, ro_t> ECCx;
        };
        /*
            PC Card/NAND Flash control register
          3
         */
        namespace PCR3 {

            static constexpr uint32_t RESETVALUE = 0x00000018;
            typedef reg_t<0xa0000480, 0xffffffff, 0, rw_t> PCR3_REG;
            /*
                ECCPS
             */
            typedef reg_t<0xa0000480, 0x00000007, 17, rw_t> ECCPS;
            /*
                TAR
             */
            typedef reg_t<0xa0000480, 0x0000000f, 13, rw_t> TAR;
            /*
                TCLR
             */
            typedef reg_t<0xa0000480, 0x0000000f, 9, rw_t> TCLR;
            /*
                ECCEN
             */
            typedef reg_t<0xa0000480, 0x00000001, 6, rw_t> ECCEN;
            /*
                PWID
             */
            typedef reg_t<0xa0000480, 0x00000003, 4, rw_t> PWID;
            /*
                PTYP
             */
            typedef reg_t<0xa0000480, 0x00000001, 3, rw_t> PTYP;
            /*
                PBKEN
             */
            typedef reg_t<0xa0000480, 0x00000001, 2, rw_t> PBKEN;
            /*
                PWAITEN
             */
            typedef reg_t<0xa0000480, 0x00000001, 1, rw_t> PWAITEN;
        };
        /*
            FIFO status and interrupt register
          3
         */
        namespace SR3 {

            static constexpr uint32_t RESETVALUE = 0x00000040;
            /*
                FEMPT
             */
            typedef reg_t<0xa0000484, 0x00000001, 6, ro_t> FEMPT;
            /*
                IFEN
             */
            typedef reg_t<0xa0000484, 0x00000001, 5, rw_t> IFEN;
            /*
                ILEN
             */
            typedef reg_t<0xa0000484, 0x00000001, 4, rw_t> ILEN;
            /*
                IREN
             */
            typedef reg_t<0xa0000484, 0x00000001, 3, rw_t> IREN;
            /*
                IFS
             */
            typedef reg_t<0xa0000484, 0x00000001, 2, rw_t> IFS;
            /*
                ILS
             */
            typedef reg_t<0xa0000484, 0x00000001, 1, rw_t> ILS;
            /*
                IRS
             */
            typedef reg_t<0xa0000484, 0x00000001, 0, rw_t> IRS;
        };
        /*
            Common memory space timing register
          3
         */
        namespace PMEM3 {

            static constexpr uint32_t RESETVALUE = 0xfcfcfcfc;
            typedef reg_t<0xa0000488, 0xffffffff, 0, rw_t> PMEM3_REG;
            /*
                MEMHIZx
             */
            typedef reg_t<0xa0000488, 0x000000ff, 24, rw_t> MEMHIZx;
            /*
                MEMHOLDx
             */
            typedef reg_t<0xa0000488, 0x000000ff, 16, rw_t> MEMHOLDx;
            /*
                MEMWAITx
             */
            typedef reg_t<0xa0000488, 0x000000ff, 8, rw_t> MEMWAITx;
            /*
                MEMSETx
             */
            typedef reg_t<0xa0000488, 0x000000ff, 0, rw_t> MEMSETx;
        };
        /*
            Attribute memory space timing register
          3
         */
        namespace PATT3 {

            static constexpr uint32_t RESETVALUE = 0xfcfcfcfc;
            typedef reg_t<0xa000048c, 0xffffffff, 0, rw_t> PATT3_REG;
            /*
                ATTHIZx
             */
            typedef reg_t<0xa000048c, 0x000000ff, 24, rw_t> ATTHIZx;
            /*
                ATTHOLDx
             */
            typedef reg_t<0xa000048c, 0x000000ff, 16, rw_t> ATTHOLDx;
            /*
                ATTWAITx
             */
            typedef reg_t<0xa000048c, 0x000000ff, 8, rw_t> ATTWAITx;
            /*
                ATTSETx
             */
            typedef reg_t<0xa000048c, 0x000000ff, 0, rw_t> ATTSETx;
        };
        /*
            ECC result register 3
         */
        namespace ECCR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xa0000494, 0xffffffff, 0, ro_t> ECCR3_REG;
            /*
                ECCx
             */
            typedef reg_t<0xa0000494, 0xffffffff, 0, ro_t> ECCx;
        };
        /*
            PC Card/NAND Flash control register
          4
         */
        namespace PCR4 {

            static constexpr uint32_t RESETVALUE = 0x00000018;
            typedef reg_t<0xa00004a0, 0xffffffff, 0, rw_t> PCR4_REG;
            /*
                ECCPS
             */
            typedef reg_t<0xa00004a0, 0x00000007, 17, rw_t> ECCPS;
            /*
                TAR
             */
            typedef reg_t<0xa00004a0, 0x0000000f, 13, rw_t> TAR;
            /*
                TCLR
             */
            typedef reg_t<0xa00004a0, 0x0000000f, 9, rw_t> TCLR;
            /*
                ECCEN
             */
            typedef reg_t<0xa00004a0, 0x00000001, 6, rw_t> ECCEN;
            /*
                PWID
             */
            typedef reg_t<0xa00004a0, 0x00000003, 4, rw_t> PWID;
            /*
                PTYP
             */
            typedef reg_t<0xa00004a0, 0x00000001, 3, rw_t> PTYP;
            /*
                PBKEN
             */
            typedef reg_t<0xa00004a0, 0x00000001, 2, rw_t> PBKEN;
            /*
                PWAITEN
             */
            typedef reg_t<0xa00004a0, 0x00000001, 1, rw_t> PWAITEN;
        };
        /*
            FIFO status and interrupt register
          4
         */
        namespace SR4 {

            static constexpr uint32_t RESETVALUE = 0x00000040;
            /*
                FEMPT
             */
            typedef reg_t<0xa00004a4, 0x00000001, 6, ro_t> FEMPT;
            /*
                IFEN
             */
            typedef reg_t<0xa00004a4, 0x00000001, 5, rw_t> IFEN;
            /*
                ILEN
             */
            typedef reg_t<0xa00004a4, 0x00000001, 4, rw_t> ILEN;
            /*
                IREN
             */
            typedef reg_t<0xa00004a4, 0x00000001, 3, rw_t> IREN;
            /*
                IFS
             */
            typedef reg_t<0xa00004a4, 0x00000001, 2, rw_t> IFS;
            /*
                ILS
             */
            typedef reg_t<0xa00004a4, 0x00000001, 1, rw_t> ILS;
            /*
                IRS
             */
            typedef reg_t<0xa00004a4, 0x00000001, 0, rw_t> IRS;
        };
        /*
            Common memory space timing register
          4
         */
        namespace PMEM4 {

            static constexpr uint32_t RESETVALUE = 0xfcfcfcfc;
            typedef reg_t<0xa00004a8, 0xffffffff, 0, rw_t> PMEM4_REG;
            /*
                MEMHIZx
             */
            typedef reg_t<0xa00004a8, 0x000000ff, 24, rw_t> MEMHIZx;
            /*
                MEMHOLDx
             */
            typedef reg_t<0xa00004a8, 0x000000ff, 16, rw_t> MEMHOLDx;
            /*
                MEMWAITx
             */
            typedef reg_t<0xa00004a8, 0x000000ff, 8, rw_t> MEMWAITx;
            /*
                MEMSETx
             */
            typedef reg_t<0xa00004a8, 0x000000ff, 0, rw_t> MEMSETx;
        };
        /*
            Attribute memory space timing register
          4
         */
        namespace PATT4 {

            static constexpr uint32_t RESETVALUE = 0xfcfcfcfc;
            typedef reg_t<0xa00004ac, 0xffffffff, 0, rw_t> PATT4_REG;
            /*
                ATTHIZx
             */
            typedef reg_t<0xa00004ac, 0x000000ff, 24, rw_t> ATTHIZx;
            /*
                ATTHOLDx
             */
            typedef reg_t<0xa00004ac, 0x000000ff, 16, rw_t> ATTHOLDx;
            /*
                ATTWAITx
             */
            typedef reg_t<0xa00004ac, 0x000000ff, 8, rw_t> ATTWAITx;
            /*
                ATTSETx
             */
            typedef reg_t<0xa00004ac, 0x000000ff, 0, rw_t> ATTSETx;
        };
        /*
            I/O space timing register 4
         */
        namespace PIO4 {

            static constexpr uint32_t RESETVALUE = 0xfcfcfcfc;
            typedef reg_t<0xa00004b0, 0xffffffff, 0, rw_t> PIO4_REG;
            /*
                IOHIZx
             */
            typedef reg_t<0xa00004b0, 0x000000ff, 24, rw_t> IOHIZx;
            /*
                IOHOLDx
             */
            typedef reg_t<0xa00004b0, 0x000000ff, 16, rw_t> IOHOLDx;
            /*
                IOWAITx
             */
            typedef reg_t<0xa00004b0, 0x000000ff, 8, rw_t> IOWAITx;
            /*
                IOSETx
             */
            typedef reg_t<0xa00004b0, 0x000000ff, 0, rw_t> IOSETx;
        };
        /*
            SRAM/NOR-Flash write timing registers
          1
         */
        namespace BWTR1 {

            static constexpr uint32_t RESETVALUE = 0x0fffffff;
            typedef reg_t<0xa0000504, 0xffffffff, 0, rw_t> BWTR1_REG;
            /*
                ACCMOD
             */
            typedef reg_t<0xa0000504, 0x00000003, 28, rw_t> ACCMOD;
            /*
                DATLAT
             */
            typedef reg_t<0xa0000504, 0x0000000f, 24, rw_t> DATLAT;
            /*
                CLKDIV
             */
            typedef reg_t<0xa0000504, 0x0000000f, 20, rw_t> CLKDIV;
            /*
                Bus turnaround phase
              duration
             */
            typedef reg_t<0xa0000504, 0x0000000f, 16, rw_t> BUSTURN;
            /*
                DATAST
             */
            typedef reg_t<0xa0000504, 0x000000ff, 8, rw_t> DATAST;
            /*
                ADDHLD
             */
            typedef reg_t<0xa0000504, 0x0000000f, 4, rw_t> ADDHLD;
            /*
                ADDSET
             */
            typedef reg_t<0xa0000504, 0x0000000f, 0, rw_t> ADDSET;
        };
        /*
            SRAM/NOR-Flash write timing registers
          2
         */
        namespace BWTR2 {

            static constexpr uint32_t RESETVALUE = 0x0fffffff;
            typedef reg_t<0xa000050c, 0xffffffff, 0, rw_t> BWTR2_REG;
            /*
                ACCMOD
             */
            typedef reg_t<0xa000050c, 0x00000003, 28, rw_t> ACCMOD;
            /*
                DATLAT
             */
            typedef reg_t<0xa000050c, 0x0000000f, 24, rw_t> DATLAT;
            /*
                CLKDIV
             */
            typedef reg_t<0xa000050c, 0x0000000f, 20, rw_t> CLKDIV;
            /*
                Bus turnaround phase
              duration
             */
            typedef reg_t<0xa000050c, 0x0000000f, 16, rw_t> BUSTURN;
            /*
                DATAST
             */
            typedef reg_t<0xa000050c, 0x000000ff, 8, rw_t> DATAST;
            /*
                ADDHLD
             */
            typedef reg_t<0xa000050c, 0x0000000f, 4, rw_t> ADDHLD;
            /*
                ADDSET
             */
            typedef reg_t<0xa000050c, 0x0000000f, 0, rw_t> ADDSET;
        };
        /*
            SRAM/NOR-Flash write timing registers
          3
         */
        namespace BWTR3 {

            static constexpr uint32_t RESETVALUE = 0x0fffffff;
            typedef reg_t<0xa0000514, 0xffffffff, 0, rw_t> BWTR3_REG;
            /*
                ACCMOD
             */
            typedef reg_t<0xa0000514, 0x00000003, 28, rw_t> ACCMOD;
            /*
                DATLAT
             */
            typedef reg_t<0xa0000514, 0x0000000f, 24, rw_t> DATLAT;
            /*
                CLKDIV
             */
            typedef reg_t<0xa0000514, 0x0000000f, 20, rw_t> CLKDIV;
            /*
                Bus turnaround phase
              duration
             */
            typedef reg_t<0xa0000514, 0x0000000f, 16, rw_t> BUSTURN;
            /*
                DATAST
             */
            typedef reg_t<0xa0000514, 0x000000ff, 8, rw_t> DATAST;
            /*
                ADDHLD
             */
            typedef reg_t<0xa0000514, 0x0000000f, 4, rw_t> ADDHLD;
            /*
                ADDSET
             */
            typedef reg_t<0xa0000514, 0x0000000f, 0, rw_t> ADDSET;
        };
        /*
            SRAM/NOR-Flash write timing registers
          4
         */
        namespace BWTR4 {

            static constexpr uint32_t RESETVALUE = 0x0fffffff;
            typedef reg_t<0xa000051c, 0xffffffff, 0, rw_t> BWTR4_REG;
            /*
                ACCMOD
             */
            typedef reg_t<0xa000051c, 0x00000003, 28, rw_t> ACCMOD;
            /*
                DATLAT
             */
            typedef reg_t<0xa000051c, 0x0000000f, 24, rw_t> DATLAT;
            /*
                CLKDIV
             */
            typedef reg_t<0xa000051c, 0x0000000f, 20, rw_t> CLKDIV;
            /*
                Bus turnaround phase
              duration
             */
            typedef reg_t<0xa000051c, 0x0000000f, 16, rw_t> BUSTURN;
            /*
                DATAST
             */
            typedef reg_t<0xa000051c, 0x000000ff, 8, rw_t> DATAST;
            /*
                ADDHLD
             */
            typedef reg_t<0xa000051c, 0x0000000f, 4, rw_t> ADDHLD;
            /*
                ADDSET
             */
            typedef reg_t<0xa000051c, 0x0000000f, 0, rw_t> ADDSET;
        };
    };
    /*
        Nested Vectored Interrupt
      Controller
     */
    namespace NVIC {
        /*
            Interrupt Set-Enable Register
         */
        namespace ISER0 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e100, 0xffffffff, 0, rw_t> ISER0_REG;
            /*
                SETENA
             */
            typedef reg_t<0xe000e100, 0xffffffff, 0, rw_t> SETENA;
        };
        /*
            Interrupt Set-Enable Register
         */
        namespace ISER1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e104, 0xffffffff, 0, rw_t> ISER1_REG;
            /*
                SETENA
             */
            typedef reg_t<0xe000e104, 0xffffffff, 0, rw_t> SETENA;
        };
        /*
            Interrupt Set-Enable Register
         */
        namespace ISER2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e108, 0xffffffff, 0, rw_t> ISER2_REG;
            /*
                SETENA
             */
            typedef reg_t<0xe000e108, 0xffffffff, 0, rw_t> SETENA;
        };
        /*
            Interrupt Clear-Enable
          Register
         */
        namespace ICER0 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e180, 0xffffffff, 0, rw_t> ICER0_REG;
            /*
                CLRENA
             */
            typedef reg_t<0xe000e180, 0xffffffff, 0, rw_t> CLRENA;
        };
        /*
            Interrupt Clear-Enable
          Register
         */
        namespace ICER1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e184, 0xffffffff, 0, rw_t> ICER1_REG;
            /*
                CLRENA
             */
            typedef reg_t<0xe000e184, 0xffffffff, 0, rw_t> CLRENA;
        };
        /*
            Interrupt Clear-Enable
          Register
         */
        namespace ICER2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e188, 0xffffffff, 0, rw_t> ICER2_REG;
            /*
                CLRENA
             */
            typedef reg_t<0xe000e188, 0xffffffff, 0, rw_t> CLRENA;
        };
        /*
            Interrupt Set-Pending Register
         */
        namespace ISPR0 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e200, 0xffffffff, 0, rw_t> ISPR0_REG;
            /*
                SETPEND
             */
            typedef reg_t<0xe000e200, 0xffffffff, 0, rw_t> SETPEND;
        };
        /*
            Interrupt Set-Pending Register
         */
        namespace ISPR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e204, 0xffffffff, 0, rw_t> ISPR1_REG;
            /*
                SETPEND
             */
            typedef reg_t<0xe000e204, 0xffffffff, 0, rw_t> SETPEND;
        };
        /*
            Interrupt Set-Pending Register
         */
        namespace ISPR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e208, 0xffffffff, 0, rw_t> ISPR2_REG;
            /*
                SETPEND
             */
            typedef reg_t<0xe000e208, 0xffffffff, 0, rw_t> SETPEND;
        };
        /*
            Interrupt Clear-Pending
          Register
         */
        namespace ICPR0 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e280, 0xffffffff, 0, rw_t> ICPR0_REG;
            /*
                CLRPEND
             */
            typedef reg_t<0xe000e280, 0xffffffff, 0, rw_t> CLRPEND;
        };
        /*
            Interrupt Clear-Pending
          Register
         */
        namespace ICPR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e284, 0xffffffff, 0, rw_t> ICPR1_REG;
            /*
                CLRPEND
             */
            typedef reg_t<0xe000e284, 0xffffffff, 0, rw_t> CLRPEND;
        };
        /*
            Interrupt Clear-Pending
          Register
         */
        namespace ICPR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e288, 0xffffffff, 0, rw_t> ICPR2_REG;
            /*
                CLRPEND
             */
            typedef reg_t<0xe000e288, 0xffffffff, 0, rw_t> CLRPEND;
        };
        /*
            Interrupt Active Bit Register
         */
        namespace IABR0 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e300, 0xffffffff, 0, ro_t> IABR0_REG;
            /*
                ACTIVE
             */
            typedef reg_t<0xe000e300, 0xffffffff, 0, ro_t> ACTIVE;
        };
        /*
            Interrupt Active Bit Register
         */
        namespace IABR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e304, 0xffffffff, 0, ro_t> IABR1_REG;
            /*
                ACTIVE
             */
            typedef reg_t<0xe000e304, 0xffffffff, 0, ro_t> ACTIVE;
        };
        /*
            Interrupt Active Bit Register
         */
        namespace IABR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e308, 0xffffffff, 0, ro_t> IABR2_REG;
            /*
                ACTIVE
             */
            typedef reg_t<0xe000e308, 0xffffffff, 0, ro_t> ACTIVE;
        };
        /*
            Interrupt Priority Register
         */
        namespace IPR0 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e400, 0xffffffff, 0, rw_t> IPR0_REG;
            /*
                IPR_N0
             */
            typedef reg_t<0xe000e400, 0x000000ff, 0, rw_t> IPR_N0;
            /*
                IPR_N1
             */
            typedef reg_t<0xe000e400, 0x000000ff, 8, rw_t> IPR_N1;
            /*
                IPR_N2
             */
            typedef reg_t<0xe000e400, 0x000000ff, 16, rw_t> IPR_N2;
            /*
                IPR_N3
             */
            typedef reg_t<0xe000e400, 0x000000ff, 24, rw_t> IPR_N3;
        };
        /*
            Interrupt Priority Register
         */
        namespace IPR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e404, 0xffffffff, 0, rw_t> IPR1_REG;
            /*
                IPR_N0
             */
            typedef reg_t<0xe000e404, 0x000000ff, 0, rw_t> IPR_N0;
            /*
                IPR_N1
             */
            typedef reg_t<0xe000e404, 0x000000ff, 8, rw_t> IPR_N1;
            /*
                IPR_N2
             */
            typedef reg_t<0xe000e404, 0x000000ff, 16, rw_t> IPR_N2;
            /*
                IPR_N3
             */
            typedef reg_t<0xe000e404, 0x000000ff, 24, rw_t> IPR_N3;
        };
        /*
            Interrupt Priority Register
         */
        namespace IPR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e408, 0xffffffff, 0, rw_t> IPR2_REG;
            /*
                IPR_N0
             */
            typedef reg_t<0xe000e408, 0x000000ff, 0, rw_t> IPR_N0;
            /*
                IPR_N1
             */
            typedef reg_t<0xe000e408, 0x000000ff, 8, rw_t> IPR_N1;
            /*
                IPR_N2
             */
            typedef reg_t<0xe000e408, 0x000000ff, 16, rw_t> IPR_N2;
            /*
                IPR_N3
             */
            typedef reg_t<0xe000e408, 0x000000ff, 24, rw_t> IPR_N3;
        };
        /*
            Interrupt Priority Register
         */
        namespace IPR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e40c, 0xffffffff, 0, rw_t> IPR3_REG;
            /*
                IPR_N0
             */
            typedef reg_t<0xe000e40c, 0x000000ff, 0, rw_t> IPR_N0;
            /*
                IPR_N1
             */
            typedef reg_t<0xe000e40c, 0x000000ff, 8, rw_t> IPR_N1;
            /*
                IPR_N2
             */
            typedef reg_t<0xe000e40c, 0x000000ff, 16, rw_t> IPR_N2;
            /*
                IPR_N3
             */
            typedef reg_t<0xe000e40c, 0x000000ff, 24, rw_t> IPR_N3;
        };
        /*
            Interrupt Priority Register
         */
        namespace IPR4 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e410, 0xffffffff, 0, rw_t> IPR4_REG;
            /*
                IPR_N0
             */
            typedef reg_t<0xe000e410, 0x000000ff, 0, rw_t> IPR_N0;
            /*
                IPR_N1
             */
            typedef reg_t<0xe000e410, 0x000000ff, 8, rw_t> IPR_N1;
            /*
                IPR_N2
             */
            typedef reg_t<0xe000e410, 0x000000ff, 16, rw_t> IPR_N2;
            /*
                IPR_N3
             */
            typedef reg_t<0xe000e410, 0x000000ff, 24, rw_t> IPR_N3;
        };
        /*
            Interrupt Priority Register
         */
        namespace IPR5 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e414, 0xffffffff, 0, rw_t> IPR5_REG;
            /*
                IPR_N0
             */
            typedef reg_t<0xe000e414, 0x000000ff, 0, rw_t> IPR_N0;
            /*
                IPR_N1
             */
            typedef reg_t<0xe000e414, 0x000000ff, 8, rw_t> IPR_N1;
            /*
                IPR_N2
             */
            typedef reg_t<0xe000e414, 0x000000ff, 16, rw_t> IPR_N2;
            /*
                IPR_N3
             */
            typedef reg_t<0xe000e414, 0x000000ff, 24, rw_t> IPR_N3;
        };
        /*
            Interrupt Priority Register
         */
        namespace IPR6 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e418, 0xffffffff, 0, rw_t> IPR6_REG;
            /*
                IPR_N0
             */
            typedef reg_t<0xe000e418, 0x000000ff, 0, rw_t> IPR_N0;
            /*
                IPR_N1
             */
            typedef reg_t<0xe000e418, 0x000000ff, 8, rw_t> IPR_N1;
            /*
                IPR_N2
             */
            typedef reg_t<0xe000e418, 0x000000ff, 16, rw_t> IPR_N2;
            /*
                IPR_N3
             */
            typedef reg_t<0xe000e418, 0x000000ff, 24, rw_t> IPR_N3;
        };
        /*
            Interrupt Priority Register
         */
        namespace IPR7 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e41c, 0xffffffff, 0, rw_t> IPR7_REG;
            /*
                IPR_N0
             */
            typedef reg_t<0xe000e41c, 0x000000ff, 0, rw_t> IPR_N0;
            /*
                IPR_N1
             */
            typedef reg_t<0xe000e41c, 0x000000ff, 8, rw_t> IPR_N1;
            /*
                IPR_N2
             */
            typedef reg_t<0xe000e41c, 0x000000ff, 16, rw_t> IPR_N2;
            /*
                IPR_N3
             */
            typedef reg_t<0xe000e41c, 0x000000ff, 24, rw_t> IPR_N3;
        };
        /*
            Interrupt Priority Register
         */
        namespace IPR8 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e420, 0xffffffff, 0, rw_t> IPR8_REG;
            /*
                IPR_N0
             */
            typedef reg_t<0xe000e420, 0x000000ff, 0, rw_t> IPR_N0;
            /*
                IPR_N1
             */
            typedef reg_t<0xe000e420, 0x000000ff, 8, rw_t> IPR_N1;
            /*
                IPR_N2
             */
            typedef reg_t<0xe000e420, 0x000000ff, 16, rw_t> IPR_N2;
            /*
                IPR_N3
             */
            typedef reg_t<0xe000e420, 0x000000ff, 24, rw_t> IPR_N3;
        };
        /*
            Interrupt Priority Register
         */
        namespace IPR9 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e424, 0xffffffff, 0, rw_t> IPR9_REG;
            /*
                IPR_N0
             */
            typedef reg_t<0xe000e424, 0x000000ff, 0, rw_t> IPR_N0;
            /*
                IPR_N1
             */
            typedef reg_t<0xe000e424, 0x000000ff, 8, rw_t> IPR_N1;
            /*
                IPR_N2
             */
            typedef reg_t<0xe000e424, 0x000000ff, 16, rw_t> IPR_N2;
            /*
                IPR_N3
             */
            typedef reg_t<0xe000e424, 0x000000ff, 24, rw_t> IPR_N3;
        };
        /*
            Interrupt Priority Register
         */
        namespace IPR10 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e428, 0xffffffff, 0, rw_t> IPR10_REG;
            /*
                IPR_N0
             */
            typedef reg_t<0xe000e428, 0x000000ff, 0, rw_t> IPR_N0;
            /*
                IPR_N1
             */
            typedef reg_t<0xe000e428, 0x000000ff, 8, rw_t> IPR_N1;
            /*
                IPR_N2
             */
            typedef reg_t<0xe000e428, 0x000000ff, 16, rw_t> IPR_N2;
            /*
                IPR_N3
             */
            typedef reg_t<0xe000e428, 0x000000ff, 24, rw_t> IPR_N3;
        };
        /*
            Interrupt Priority Register
         */
        namespace IPR11 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e42c, 0xffffffff, 0, rw_t> IPR11_REG;
            /*
                IPR_N0
             */
            typedef reg_t<0xe000e42c, 0x000000ff, 0, rw_t> IPR_N0;
            /*
                IPR_N1
             */
            typedef reg_t<0xe000e42c, 0x000000ff, 8, rw_t> IPR_N1;
            /*
                IPR_N2
             */
            typedef reg_t<0xe000e42c, 0x000000ff, 16, rw_t> IPR_N2;
            /*
                IPR_N3
             */
            typedef reg_t<0xe000e42c, 0x000000ff, 24, rw_t> IPR_N3;
        };
        /*
            Interrupt Priority Register
         */
        namespace IPR12 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e430, 0xffffffff, 0, rw_t> IPR12_REG;
            /*
                IPR_N0
             */
            typedef reg_t<0xe000e430, 0x000000ff, 0, rw_t> IPR_N0;
            /*
                IPR_N1
             */
            typedef reg_t<0xe000e430, 0x000000ff, 8, rw_t> IPR_N1;
            /*
                IPR_N2
             */
            typedef reg_t<0xe000e430, 0x000000ff, 16, rw_t> IPR_N2;
            /*
                IPR_N3
             */
            typedef reg_t<0xe000e430, 0x000000ff, 24, rw_t> IPR_N3;
        };
        /*
            Interrupt Priority Register
         */
        namespace IPR13 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e434, 0xffffffff, 0, rw_t> IPR13_REG;
            /*
                IPR_N0
             */
            typedef reg_t<0xe000e434, 0x000000ff, 0, rw_t> IPR_N0;
            /*
                IPR_N1
             */
            typedef reg_t<0xe000e434, 0x000000ff, 8, rw_t> IPR_N1;
            /*
                IPR_N2
             */
            typedef reg_t<0xe000e434, 0x000000ff, 16, rw_t> IPR_N2;
            /*
                IPR_N3
             */
            typedef reg_t<0xe000e434, 0x000000ff, 24, rw_t> IPR_N3;
        };
        /*
            Interrupt Priority Register
         */
        namespace IPR14 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e438, 0xffffffff, 0, rw_t> IPR14_REG;
            /*
                IPR_N0
             */
            typedef reg_t<0xe000e438, 0x000000ff, 0, rw_t> IPR_N0;
            /*
                IPR_N1
             */
            typedef reg_t<0xe000e438, 0x000000ff, 8, rw_t> IPR_N1;
            /*
                IPR_N2
             */
            typedef reg_t<0xe000e438, 0x000000ff, 16, rw_t> IPR_N2;
            /*
                IPR_N3
             */
            typedef reg_t<0xe000e438, 0x000000ff, 24, rw_t> IPR_N3;
        };
        /*
            Interrupt Priority Register
         */
        namespace IPR15 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e43c, 0xffffffff, 0, rw_t> IPR15_REG;
            /*
                IPR_N0
             */
            typedef reg_t<0xe000e43c, 0x000000ff, 0, rw_t> IPR_N0;
            /*
                IPR_N1
             */
            typedef reg_t<0xe000e43c, 0x000000ff, 8, rw_t> IPR_N1;
            /*
                IPR_N2
             */
            typedef reg_t<0xe000e43c, 0x000000ff, 16, rw_t> IPR_N2;
            /*
                IPR_N3
             */
            typedef reg_t<0xe000e43c, 0x000000ff, 24, rw_t> IPR_N3;
        };
        /*
            Interrupt Priority Register
         */
        namespace IPR16 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e440, 0xffffffff, 0, rw_t> IPR16_REG;
            /*
                IPR_N0
             */
            typedef reg_t<0xe000e440, 0x000000ff, 0, rw_t> IPR_N0;
            /*
                IPR_N1
             */
            typedef reg_t<0xe000e440, 0x000000ff, 8, rw_t> IPR_N1;
            /*
                IPR_N2
             */
            typedef reg_t<0xe000e440, 0x000000ff, 16, rw_t> IPR_N2;
            /*
                IPR_N3
             */
            typedef reg_t<0xe000e440, 0x000000ff, 24, rw_t> IPR_N3;
        };
        /*
            Interrupt Priority Register
         */
        namespace IPR17 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e444, 0xffffffff, 0, rw_t> IPR17_REG;
            /*
                IPR_N0
             */
            typedef reg_t<0xe000e444, 0x000000ff, 0, rw_t> IPR_N0;
            /*
                IPR_N1
             */
            typedef reg_t<0xe000e444, 0x000000ff, 8, rw_t> IPR_N1;
            /*
                IPR_N2
             */
            typedef reg_t<0xe000e444, 0x000000ff, 16, rw_t> IPR_N2;
            /*
                IPR_N3
             */
            typedef reg_t<0xe000e444, 0x000000ff, 24, rw_t> IPR_N3;
        };
        /*
            Interrupt Priority Register
         */
        namespace IPR18 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e448, 0xffffffff, 0, rw_t> IPR18_REG;
            /*
                IPR_N0
             */
            typedef reg_t<0xe000e448, 0x000000ff, 0, rw_t> IPR_N0;
            /*
                IPR_N1
             */
            typedef reg_t<0xe000e448, 0x000000ff, 8, rw_t> IPR_N1;
            /*
                IPR_N2
             */
            typedef reg_t<0xe000e448, 0x000000ff, 16, rw_t> IPR_N2;
            /*
                IPR_N3
             */
            typedef reg_t<0xe000e448, 0x000000ff, 24, rw_t> IPR_N3;
        };
        /*
            Interrupt Priority Register
         */
        namespace IPR19 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e44c, 0xffffffff, 0, rw_t> IPR19_REG;
            /*
                IPR_N0
             */
            typedef reg_t<0xe000e44c, 0x000000ff, 0, rw_t> IPR_N0;
            /*
                IPR_N1
             */
            typedef reg_t<0xe000e44c, 0x000000ff, 8, rw_t> IPR_N1;
            /*
                IPR_N2
             */
            typedef reg_t<0xe000e44c, 0x000000ff, 16, rw_t> IPR_N2;
            /*
                IPR_N3
             */
            typedef reg_t<0xe000e44c, 0x000000ff, 24, rw_t> IPR_N3;
        };
        /*
            Interrupt Priority Register
         */
        namespace IPR20 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e450, 0xffffffff, 0, rw_t> IPR20_REG;
            /*
                IPR_N0
             */
            typedef reg_t<0xe000e450, 0x000000ff, 0, rw_t> IPR_N0;
            /*
                IPR_N1
             */
            typedef reg_t<0xe000e450, 0x000000ff, 8, rw_t> IPR_N1;
            /*
                IPR_N2
             */
            typedef reg_t<0xe000e450, 0x000000ff, 16, rw_t> IPR_N2;
            /*
                IPR_N3
             */
            typedef reg_t<0xe000e450, 0x000000ff, 24, rw_t> IPR_N3;
        };
    };
    /*
        Floting point unit
     */
    namespace FPU {
        /*
            Floating-point context control
          register
         */
        namespace FPCCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000ef34, 0xffffffff, 0, rw_t> FPCCR_REG;
            /*
                LSPACT
             */
            typedef reg_t<0xe000ef34, 0x00000001, 0, rw_t> LSPACT;
            /*
                USER
             */
            typedef reg_t<0xe000ef34, 0x00000001, 1, rw_t> USER;
            /*
                THREAD
             */
            typedef reg_t<0xe000ef34, 0x00000001, 3, rw_t> THREAD;
            /*
                HFRDY
             */
            typedef reg_t<0xe000ef34, 0x00000001, 4, rw_t> HFRDY;
            /*
                MMRDY
             */
            typedef reg_t<0xe000ef34, 0x00000001, 5, rw_t> MMRDY;
            /*
                BFRDY
             */
            typedef reg_t<0xe000ef34, 0x00000001, 6, rw_t> BFRDY;
            /*
                MONRDY
             */
            typedef reg_t<0xe000ef34, 0x00000001, 8, rw_t> MONRDY;
            /*
                LSPEN
             */
            typedef reg_t<0xe000ef34, 0x00000001, 30, rw_t> LSPEN;
            /*
                ASPEN
             */
            typedef reg_t<0xe000ef34, 0x00000001, 31, rw_t> ASPEN;
        };
        /*
            Floating-point context address
          register
         */
        namespace FPCAR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000ef38, 0xffffffff, 0, rw_t> FPCAR_REG;
            /*
                Location of unpopulated
              floating-point
             */
            typedef reg_t<0xe000ef38, 0x1fffffff, 3, rw_t> ADDRESS;
        };
        /*
            Floating-point status control
          register
         */
        namespace FPSCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000ef3c, 0xffffffff, 0, rw_t> FPSCR_REG;
            /*
                Invalid operation cumulative exception
              bit
             */
            typedef reg_t<0xe000ef3c, 0x00000001, 0, rw_t> IOC;
            /*
                Division by zero cumulative exception
              bit.
             */
            typedef reg_t<0xe000ef3c, 0x00000001, 1, rw_t> DZC;
            /*
                Overflow cumulative exception
              bit
             */
            typedef reg_t<0xe000ef3c, 0x00000001, 2, rw_t> OFC;
            /*
                Underflow cumulative exception
              bit
             */
            typedef reg_t<0xe000ef3c, 0x00000001, 3, rw_t> UFC;
            /*
                Inexact cumulative exception
              bit
             */
            typedef reg_t<0xe000ef3c, 0x00000001, 4, rw_t> IXC;
            /*
                Input denormal cumulative exception
              bit.
             */
            typedef reg_t<0xe000ef3c, 0x00000001, 7, rw_t> IDC;
            /*
                Rounding Mode control
              field
             */
            typedef reg_t<0xe000ef3c, 0x00000003, 22, rw_t> RMode;
            /*
                Flush-to-zero mode control
              bit:
             */
            typedef reg_t<0xe000ef3c, 0x00000001, 24, rw_t> FZ;
            /*
                Default NaN mode control
              bit
             */
            typedef reg_t<0xe000ef3c, 0x00000001, 25, rw_t> DN;
            /*
                Alternative half-precision control
              bit
             */
            typedef reg_t<0xe000ef3c, 0x00000001, 26, rw_t> AHP;
            /*
                Overflow condition code
              flag
             */
            typedef reg_t<0xe000ef3c, 0x00000001, 28, rw_t> V;
            /*
                Carry condition code flag
             */
            typedef reg_t<0xe000ef3c, 0x00000001, 29, rw_t> C;
            /*
                Zero condition code flag
             */
            typedef reg_t<0xe000ef3c, 0x00000001, 30, rw_t> Z;
            /*
                Negative condition code
              flag
             */
            typedef reg_t<0xe000ef3c, 0x00000001, 31, rw_t> N;
        };
    };
    /*
        Memory protection unit
     */
    namespace MPU {
        /*
            MPU type register
         */
        namespace MPU_TYPER {

            static constexpr uint32_t RESETVALUE = 0x00000800;
            typedef reg_t<0xe000ed90, 0xffffffff, 0, ro_t> MPU_TYPER_REG;
            /*
                Separate flag
             */
            typedef reg_t<0xe000ed90, 0x00000001, 0, ro_t> SEPARATE;
            /*
                Number of MPU data regions
             */
            typedef reg_t<0xe000ed90, 0x000000ff, 8, ro_t> DREGION;
            /*
                Number of MPU instruction
              regions
             */
            typedef reg_t<0xe000ed90, 0x000000ff, 16, ro_t> IREGION;
        };
        /*
            MPU control register
         */
        namespace MPU_CTRL {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000ed94, 0xffffffff, 0, ro_t> MPU_CTRL_REG;
            /*
                Enables the MPU
             */
            typedef reg_t<0xe000ed94, 0x00000001, 0, ro_t> ENABLE;
            /*
                Enables the operation of MPU during hard
              fault
             */
            typedef reg_t<0xe000ed94, 0x00000001, 1, ro_t> HFNMIENA;
            /*
                Enable priviliged software access to
              default memory map
             */
            typedef reg_t<0xe000ed94, 0x00000001, 2, ro_t> PRIVDEFENA;
        };
        /*
            MPU region number register
         */
        namespace MPU_RNR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000ed98, 0xffffffff, 0, rw_t> MPU_RNR_REG;
            /*
                MPU region
             */
            typedef reg_t<0xe000ed98, 0x000000ff, 0, rw_t> REGION;
        };
        /*
            MPU region base address
          register
         */
        namespace MPU_RBAR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000ed9c, 0xffffffff, 0, rw_t> MPU_RBAR_REG;
            /*
                MPU region field
             */
            typedef reg_t<0xe000ed9c, 0x0000000f, 0, rw_t> REGION;
            /*
                MPU region number valid
             */
            typedef reg_t<0xe000ed9c, 0x00000001, 4, rw_t> VALID;
            /*
                Region base address field
             */
            typedef reg_t<0xe000ed9c, 0x07ffffff, 5, rw_t> ADDR;
        };
        /*
            MPU region attribute and size
          register
         */
        namespace MPU_RASR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000eda0, 0xffffffff, 0, rw_t> MPU_RASR_REG;
            /*
                Region enable bit.
             */
            typedef reg_t<0xe000eda0, 0x00000001, 0, rw_t> ENABLE;
            /*
                Size of the MPU protection
              region
             */
            typedef reg_t<0xe000eda0, 0x0000001f, 1, rw_t> SIZE;
            /*
                Subregion disable bits
             */
            typedef reg_t<0xe000eda0, 0x000000ff, 8, rw_t> SRD;
            /*
                memory attribute
             */
            typedef reg_t<0xe000eda0, 0x00000001, 16, rw_t> B;
            /*
                memory attribute
             */
            typedef reg_t<0xe000eda0, 0x00000001, 17, rw_t> C;
            /*
                Shareable memory attribute
             */
            typedef reg_t<0xe000eda0, 0x00000001, 18, rw_t> S;
            /*
                memory attribute
             */
            typedef reg_t<0xe000eda0, 0x00000007, 19, rw_t> TEX;
            /*
                Access permission
             */
            typedef reg_t<0xe000eda0, 0x00000007, 24, rw_t> AP;
            /*
                Instruction access disable
              bit
             */
            typedef reg_t<0xe000eda0, 0x00000001, 28, rw_t> XN;
        };
    };
    /*
        SysTick timer
     */
    namespace STK {
        /*
            SysTick control and status
          register
         */
        namespace CTRL {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e010, 0xffffffff, 0, rw_t> CTRL_REG;
            /*
                Counter enable
             */
            typedef reg_t<0xe000e010, 0x00000001, 0, rw_t> ENABLE;
            /*
                SysTick exception request
              enable
             */
            typedef reg_t<0xe000e010, 0x00000001, 1, rw_t> TICKINT;
            /*
                Clock source selection
             */
            typedef reg_t<0xe000e010, 0x00000001, 2, rw_t> CLKSOURCE;
            /*
                COUNTFLAG
             */
            typedef reg_t<0xe000e010, 0x00000001, 16, rw_t> COUNTFLAG;
        };
        /*
            SysTick reload value register
         */
        namespace LOAD {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e014, 0xffffffff, 0, rw_t> LOAD_REG;
            /*
                RELOAD value
             */
            typedef reg_t<0xe000e014, 0x00ffffff, 0, rw_t> RELOAD;
        };
        /*
            SysTick current value register
         */
        namespace VAL {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e018, 0xffffffff, 0, rw_t> VAL_REG;
            /*
                Current counter value
             */
            typedef reg_t<0xe000e018, 0x00ffffff, 0, rw_t> CURRENT;
        };
        /*
            SysTick calibration value
          register
         */
        namespace CALIB {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e01c, 0xffffffff, 0, rw_t> CALIB_REG;
            /*
                Calibration value
             */
            typedef reg_t<0xe000e01c, 0x00ffffff, 0, rw_t> TENMS;
            /*
                SKEW flag: Indicates whether the TENMS
              value is exact
             */
            typedef reg_t<0xe000e01c, 0x00000001, 30, rw_t> SKEW;
            /*
                NOREF flag. Reads as zero
             */
            typedef reg_t<0xe000e01c, 0x00000001, 31, rw_t> NOREF;
        };
    };
    /*
        System control block
     */
    namespace SCB {
        /*
            CPUID base register
         */
        namespace CPUID {

            static constexpr uint32_t RESETVALUE = 0x410fc241;
            typedef reg_t<0xe000ed00, 0xffffffff, 0, ro_t> CPUID_REG;
            /*
                Revision number
             */
            typedef reg_t<0xe000ed00, 0x0000000f, 0, ro_t> Revision;
            /*
                Part number of the
              processor
             */
            typedef reg_t<0xe000ed00, 0x00000fff, 4, ro_t> PartNo;
            /*
                Reads as 0xF
             */
            typedef reg_t<0xe000ed00, 0x0000000f, 16, ro_t> Constant;
            /*
                Variant number
             */
            typedef reg_t<0xe000ed00, 0x0000000f, 20, ro_t> Variant;
            /*
                Implementer code
             */
            typedef reg_t<0xe000ed00, 0x000000ff, 24, ro_t> Implementer;
        };
        /*
            Interrupt control and state
          register
         */
        namespace ICSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000ed04, 0xffffffff, 0, rw_t> ICSR_REG;
            /*
                Active vector
             */
            typedef reg_t<0xe000ed04, 0x000001ff, 0, rw_t> VECTACTIVE;
            /*
                Return to base level
             */
            typedef reg_t<0xe000ed04, 0x00000001, 11, rw_t> RETTOBASE;
            /*
                Pending vector
             */
            typedef reg_t<0xe000ed04, 0x0000007f, 12, rw_t> VECTPENDING;
            /*
                Interrupt pending flag
             */
            typedef reg_t<0xe000ed04, 0x00000001, 22, rw_t> ISRPENDING;
            /*
                SysTick exception clear-pending
              bit
             */
            typedef reg_t<0xe000ed04, 0x00000001, 25, rw_t> PENDSTCLR;
            /*
                SysTick exception set-pending
              bit
             */
            typedef reg_t<0xe000ed04, 0x00000001, 26, rw_t> PENDSTSET;
            /*
                PendSV clear-pending bit
             */
            typedef reg_t<0xe000ed04, 0x00000001, 27, rw_t> PENDSVCLR;
            /*
                PendSV set-pending bit
             */
            typedef reg_t<0xe000ed04, 0x00000001, 28, rw_t> PENDSVSET;
            /*
                NMI set-pending bit.
             */
            typedef reg_t<0xe000ed04, 0x00000001, 31, rw_t> NMIPENDSET;
        };
        /*
            Vector table offset register
         */
        namespace VTOR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000ed08, 0xffffffff, 0, rw_t> VTOR_REG;
            /*
                Vector table base offset
              field
             */
            typedef reg_t<0xe000ed08, 0x001fffff, 9, rw_t> TBLOFF;
        };
        /*
            Application interrupt and reset control
          register
         */
        namespace AIRCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000ed0c, 0xffffffff, 0, rw_t> AIRCR_REG;
            /*
                VECTRESET
             */
            typedef reg_t<0xe000ed0c, 0x00000001, 0, rw_t> VECTRESET;
            /*
                VECTCLRACTIVE
             */
            typedef reg_t<0xe000ed0c, 0x00000001, 1, rw_t> VECTCLRACTIVE;
            /*
                SYSRESETREQ
             */
            typedef reg_t<0xe000ed0c, 0x00000001, 2, rw_t> SYSRESETREQ;
            /*
                PRIGROUP
             */
            typedef reg_t<0xe000ed0c, 0x00000007, 8, rw_t> PRIGROUP;
            /*
                ENDIANESS
             */
            typedef reg_t<0xe000ed0c, 0x00000001, 15, rw_t> ENDIANESS;
            /*
                Register key
             */
            typedef reg_t<0xe000ed0c, 0x0000ffff, 16, rw_t> VECTKEYSTAT;
        };
        /*
            System control register
         */
        namespace SCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000ed10, 0xffffffff, 0, rw_t> SCR_REG;
            /*
                SLEEPONEXIT
             */
            typedef reg_t<0xe000ed10, 0x00000001, 1, rw_t> SLEEPONEXIT;
            /*
                SLEEPDEEP
             */
            typedef reg_t<0xe000ed10, 0x00000001, 2, rw_t> SLEEPDEEP;
            /*
                Send Event on Pending bit
             */
            typedef reg_t<0xe000ed10, 0x00000001, 4, rw_t> SEVEONPEND;
        };
        /*
            Configuration and control
          register
         */
        namespace CCR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000ed14, 0xffffffff, 0, rw_t> CCR_REG;
            /*
                Configures how the processor enters
              Thread mode
             */
            typedef reg_t<0xe000ed14, 0x00000001, 0, rw_t> NONBASETHRDENA;
            /*
                USERSETMPEND
             */
            typedef reg_t<0xe000ed14, 0x00000001, 1, rw_t> USERSETMPEND;
            /*
                UNALIGN_ TRP
             */
            typedef reg_t<0xe000ed14, 0x00000001, 3, rw_t> UNALIGN__TRP;
            /*
                DIV_0_TRP
             */
            typedef reg_t<0xe000ed14, 0x00000001, 4, rw_t> DIV_0_TRP;
            /*
                BFHFNMIGN
             */
            typedef reg_t<0xe000ed14, 0x00000001, 8, rw_t> BFHFNMIGN;
            /*
                STKALIGN
             */
            typedef reg_t<0xe000ed14, 0x00000001, 9, rw_t> STKALIGN;
        };
        /*
            System handler priority
          registers
         */
        namespace SHPR1 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000ed18, 0xffffffff, 0, rw_t> SHPR1_REG;
            /*
                Priority of system handler
              4
             */
            typedef reg_t<0xe000ed18, 0x000000ff, 0, rw_t> PRI_4;
            /*
                Priority of system handler
              5
             */
            typedef reg_t<0xe000ed18, 0x000000ff, 8, rw_t> PRI_5;
            /*
                Priority of system handler
              6
             */
            typedef reg_t<0xe000ed18, 0x000000ff, 16, rw_t> PRI_6;
        };
        /*
            System handler priority
          registers
         */
        namespace SHPR2 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000ed1c, 0xffffffff, 0, rw_t> SHPR2_REG;
            /*
                Priority of system handler
              11
             */
            typedef reg_t<0xe000ed1c, 0x000000ff, 24, rw_t> PRI_11;
        };
        /*
            System handler priority
          registers
         */
        namespace SHPR3 {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000ed20, 0xffffffff, 0, rw_t> SHPR3_REG;
            /*
                Priority of system handler
              14
             */
            typedef reg_t<0xe000ed20, 0x000000ff, 16, rw_t> PRI_14;
            /*
                Priority of system handler
              15
             */
            typedef reg_t<0xe000ed20, 0x000000ff, 24, rw_t> PRI_15;
        };
        /*
            System handler control and state
          register
         */
        namespace SHCRS {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000ed24, 0xffffffff, 0, rw_t> SHCRS_REG;
            /*
                Memory management fault exception active
              bit
             */
            typedef reg_t<0xe000ed24, 0x00000001, 0, rw_t> MEMFAULTACT;
            /*
                Bus fault exception active
              bit
             */
            typedef reg_t<0xe000ed24, 0x00000001, 1, rw_t> BUSFAULTACT;
            /*
                Usage fault exception active
              bit
             */
            typedef reg_t<0xe000ed24, 0x00000001, 3, rw_t> USGFAULTACT;
            /*
                SVC call active bit
             */
            typedef reg_t<0xe000ed24, 0x00000001, 7, rw_t> SVCALLACT;
            /*
                Debug monitor active bit
             */
            typedef reg_t<0xe000ed24, 0x00000001, 8, rw_t> MONITORACT;
            /*
                PendSV exception active
              bit
             */
            typedef reg_t<0xe000ed24, 0x00000001, 10, rw_t> PENDSVACT;
            /*
                SysTick exception active
              bit
             */
            typedef reg_t<0xe000ed24, 0x00000001, 11, rw_t> SYSTICKACT;
            /*
                Usage fault exception pending
              bit
             */
            typedef reg_t<0xe000ed24, 0x00000001, 12, rw_t> USGFAULTPENDED;
            /*
                Memory management fault exception
              pending bit
             */
            typedef reg_t<0xe000ed24, 0x00000001, 13, rw_t> MEMFAULTPENDED;
            /*
                Bus fault exception pending
              bit
             */
            typedef reg_t<0xe000ed24, 0x00000001, 14, rw_t> BUSFAULTPENDED;
            /*
                SVC call pending bit
             */
            typedef reg_t<0xe000ed24, 0x00000001, 15, rw_t> SVCALLPENDED;
            /*
                Memory management fault enable
              bit
             */
            typedef reg_t<0xe000ed24, 0x00000001, 16, rw_t> MEMFAULTENA;
            /*
                Bus fault enable bit
             */
            typedef reg_t<0xe000ed24, 0x00000001, 17, rw_t> BUSFAULTENA;
            /*
                Usage fault enable bit
             */
            typedef reg_t<0xe000ed24, 0x00000001, 18, rw_t> USGFAULTENA;
        };
        /*
            Configurable fault status
          register
         */
        namespace CFSR_UFSR_BFSR_MMFSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000ed28, 0xffffffff, 0, rw_t> CFSR_UFSR_BFSR_MMFSR_REG;
            /*
                Instruction access violation
              flag
             */
            typedef reg_t<0xe000ed28, 0x00000001, 1, rw_t> IACCVIOL;
            /*
                Memory manager fault on unstacking for a
              return from exception
             */
            typedef reg_t<0xe000ed28, 0x00000001, 3, rw_t> MUNSTKERR;
            /*
                Memory manager fault on stacking for
              exception entry.
             */
            typedef reg_t<0xe000ed28, 0x00000001, 4, rw_t> MSTKERR;
            /*
                MLSPERR
             */
            typedef reg_t<0xe000ed28, 0x00000001, 5, rw_t> MLSPERR;
            /*
                Memory Management Fault Address Register
              (MMAR) valid flag
             */
            typedef reg_t<0xe000ed28, 0x00000001, 7, rw_t> MMARVALID;
            /*
                Instruction bus error
             */
            typedef reg_t<0xe000ed28, 0x00000001, 8, rw_t> IBUSERR;
            /*
                Precise data bus error
             */
            typedef reg_t<0xe000ed28, 0x00000001, 9, rw_t> PRECISERR;
            /*
                Imprecise data bus error
             */
            typedef reg_t<0xe000ed28, 0x00000001, 10, rw_t> IMPRECISERR;
            /*
                Bus fault on unstacking for a return
              from exception
             */
            typedef reg_t<0xe000ed28, 0x00000001, 11, rw_t> UNSTKERR;
            /*
                Bus fault on stacking for exception
              entry
             */
            typedef reg_t<0xe000ed28, 0x00000001, 12, rw_t> STKERR;
            /*
                Bus fault on floating-point lazy state
              preservation
             */
            typedef reg_t<0xe000ed28, 0x00000001, 13, rw_t> LSPERR;
            /*
                Bus Fault Address Register (BFAR) valid
              flag
             */
            typedef reg_t<0xe000ed28, 0x00000001, 15, rw_t> BFARVALID;
            /*
                Undefined instruction usage
              fault
             */
            typedef reg_t<0xe000ed28, 0x00000001, 16, rw_t> UNDEFINSTR;
            /*
                Invalid state usage fault
             */
            typedef reg_t<0xe000ed28, 0x00000001, 17, rw_t> INVSTATE;
            /*
                Invalid PC load usage
              fault
             */
            typedef reg_t<0xe000ed28, 0x00000001, 18, rw_t> INVPC;
            /*
                No coprocessor usage
              fault.
             */
            typedef reg_t<0xe000ed28, 0x00000001, 19, rw_t> NOCP;
            /*
                Unaligned access usage
              fault
             */
            typedef reg_t<0xe000ed28, 0x00000001, 24, rw_t> UNALIGNED;
            /*
                Divide by zero usage fault
             */
            typedef reg_t<0xe000ed28, 0x00000001, 25, rw_t> DIVBYZERO;
        };
        /*
            Hard fault status register
         */
        namespace HFSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000ed2c, 0xffffffff, 0, rw_t> HFSR_REG;
            /*
                Vector table hard fault
             */
            typedef reg_t<0xe000ed2c, 0x00000001, 1, rw_t> VECTTBL;
            /*
                Forced hard fault
             */
            typedef reg_t<0xe000ed2c, 0x00000001, 30, rw_t> FORCED;
            /*
                Reserved for Debug use
             */
            typedef reg_t<0xe000ed2c, 0x00000001, 31, rw_t> DEBUG_VT;
        };
        /*
            Memory management fault address
          register
         */
        namespace MMFAR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000ed34, 0xffffffff, 0, rw_t> MMFAR_REG;
            /*
                Memory management fault
              address
             */
            typedef reg_t<0xe000ed34, 0xffffffff, 0, rw_t> MMFAR;
        };
        /*
            Bus fault address register
         */
        namespace BFAR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000ed38, 0xffffffff, 0, rw_t> BFAR_REG;
            /*
                Bus fault address
             */
            typedef reg_t<0xe000ed38, 0xffffffff, 0, rw_t> BFAR;
        };
        /*
            Auxiliary fault status
          register
         */
        namespace AFSR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000ed3c, 0xffffffff, 0, rw_t> AFSR_REG;
            /*
                Implementation defined
             */
            typedef reg_t<0xe000ed3c, 0xffffffff, 0, rw_t> IMPDEF;
        };
    };
    /*
        Nested vectored interrupt
      controller
     */
    namespace NVIC_STIR {
        /*
            Software trigger interrupt
          register
         */
        namespace STIR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000ef00, 0xffffffff, 0, rw_t> STIR_REG;
            /*
                Software generated interrupt
              ID
             */
            typedef reg_t<0xe000ef00, 0x000001ff, 0, rw_t> INTID;
        };
    };
    /*
        Floating point unit CPACR
     */
    namespace FPU_CPACR {
        /*
            Coprocessor access control
          register
         */
        namespace CPACR {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000ed88, 0xffffffff, 0, rw_t> CPACR_REG;
            /*
                CP
             */
            typedef reg_t<0xe000ed88, 0x0000000f, 20, rw_t> CP;
        };
    };
    /*
        System control block ACTLR
     */
    namespace SCB_ACTRL {
        /*
            Auxiliary control register
         */
        namespace ACTRL {

            static constexpr uint32_t RESETVALUE = 0x00000000;
            typedef reg_t<0xe000e008, 0xffffffff, 0, rw_t> ACTRL_REG;
            /*
                DISMCYCINT
             */
            typedef reg_t<0xe000e008, 0x00000001, 0, rw_t> DISMCYCINT;
            /*
                DISDEFWBUF
             */
            typedef reg_t<0xe000e008, 0x00000001, 1, rw_t> DISDEFWBUF;
            /*
                DISFOLD
             */
            typedef reg_t<0xe000e008, 0x00000001, 2, rw_t> DISFOLD;
            /*
                DISFPCA
             */
            typedef reg_t<0xe000e008, 0x00000001, 8, rw_t> DISFPCA;
            /*
                DISOOFP
             */
            typedef reg_t<0xe000e008, 0x00000001, 9, rw_t> DISOOFP;
        };
    };
};
